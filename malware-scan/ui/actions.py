from logging import getLogger
from traceback import format_exc
import json

# Import get_redis_client for consistent Redis access
try:
    from app.routes.utils import get_redis_client
    HAS_REDIS_CLIENT = True
except ImportError:
    HAS_REDIS_CLIENT = False


def pre_render(**kwargs):
    logger = getLogger("UI")
    ret = {
        "counter_malware_detected": {
            "value": 0,
            "title": "Malware",
            "subtitle": "Detected",
            "subtitle_color": "danger",
            "svg_color": "danger",
        },
        "counter_files_scanned": {
            "value": 0,
            "title": "Files",
            "subtitle": "Scanned",
            "subtitle_color": "info",
            "svg_color": "info",
        },
        "counter_cache_hits": {
            "value": 0,
            "title": "Cache",
            "subtitle": "Hits",
            "subtitle_color": "success",
            "svg_color": "success",
        },
        "worker_clamav_status": {
            "title": "WORKER CLAMAV STATUS",
            "workers": [],
        },
        "malwarebazaar_stats": {
            "total_hashes": 0,
            "buckets": 16,
            "status": "unknown",
            "full_db_status": "unknown",
            "recent_db_status": "unknown",
            "import_status": "unknown",
            "full_import_start_time": None,
            "full_import_end_time": None,
            "recent_import_start_time": None,
            "recent_import_end_time": None,
            "initialized": False,
            "import_progress": {
                "full": {"total": 0, "processed": 0},
                "recent": {"total": 0, "processed": 0},
            },
        },
        "clamav_stats": {
            "clamav_version": "unknown",
            "definition_version": "unknown",
            "definition_date": "unknown",
            "status": "unknown",
        },
    }

    # Get ClamAV status from all worker instances
    # The ping response now includes MalwareBazaar and ClamAV stats
    stats_collected = False
    try:
        instances = kwargs["bw_instances_utils"].get_instances(status="up")
        for instance in instances:
            worker_status = {
                "name": instance.name,
                "hostname": instance.hostname,
                "status": "error",
                "message": "No response",
            }
            try:
                resp, ping_data = instance.ping("malware-scan")
                if resp and isinstance(ping_data, dict):
                    # ping_data format: {hostname: {"status": "success", "msg": "{\"status\":\"...\",\"message\":\"...\"}"}}
                    instance_data = ping_data.get(instance.hostname, {})

                    # The actual plugin response is JSON-encoded in the 'msg' field
                    msg_json = instance_data.get("msg", "{}")
                    try:
                        plugin_response = json.loads(msg_json)
                        worker_status["status"] = plugin_response.get("status", "error")
                        worker_status["message"] = plugin_response.get("message", "Unknown status")

                        # Extract stats from first successful worker response
                        if not stats_collected and plugin_response.get("status") == "success":
                            # MalwareBazaar stats
                            if "malwarebazaar" in plugin_response:
                                mb_stats = plugin_response["malwarebazaar"]
                                ret["malwarebazaar_stats"]["total_hashes"] = mb_stats.get("total_hashes", 0)
                                ret["malwarebazaar_stats"]["buckets"] = mb_stats.get("buckets", 16)
                                ret["malwarebazaar_stats"]["full_db_status"] = mb_stats.get("full_db_status", "unknown")
                                ret["malwarebazaar_stats"]["recent_db_status"] = mb_stats.get("recent_db_status", "unknown")
                                ret["malwarebazaar_stats"]["import_status"] = mb_stats.get("import_status", "unknown")
                                ret["malwarebazaar_stats"]["full_import_start_time"] = mb_stats.get("full_import_start_time")
                                ret["malwarebazaar_stats"]["full_import_end_time"] = mb_stats.get("full_import_end_time")
                                ret["malwarebazaar_stats"]["recent_import_start_time"] = mb_stats.get("recent_import_start_time")
                                ret["malwarebazaar_stats"]["recent_import_end_time"] = mb_stats.get("recent_import_end_time")
                                ret["malwarebazaar_stats"]["initialized"] = mb_stats.get("initialized", False)
                                ret["malwarebazaar_stats"]["status"] = "success"

                                # Extract import progress if available
                                if "import_progress" in mb_stats:
                                    ret["malwarebazaar_stats"]["import_progress"] = mb_stats["import_progress"]

                            # ClamAV stats
                            if "clamav_stats" in plugin_response:
                                cv_stats = plugin_response["clamav_stats"]
                                ret["clamav_stats"]["clamav_version"] = cv_stats.get("version", "unknown")
                                ret["clamav_stats"]["definition_version"] = cv_stats.get("definitions", "unknown")
                                ret["clamav_stats"]["definition_date"] = cv_stats.get("updated", "unknown")
                                ret["clamav_stats"]["status"] = "success"

                            stats_collected = True

                    except json.JSONDecodeError as e:
                        logger.error(f"Failed to parse JSON from worker {instance.name}: {e}")
                        worker_status["status"] = "error"
                        worker_status["message"] = "Invalid JSON response"
                else:
                    worker_status["status"] = "error"
                    worker_status["message"] = "Invalid response from worker"
            except BaseException as e:
                logger.debug(f"Failed to get ping from {instance.name}: {format_exc()}")
                worker_status["status"] = "error"
                worker_status["message"] = f"Connection error: {str(e)}"

            ret["worker_clamav_status"]["workers"].append(worker_status)

    except BaseException as e:
        logger.error(f"Failed to get worker instances: {e}")
        logger.debug(format_exc())

    # Always query Redis directly for import status (manager-side)
    # The import status is set by scheduler jobs, not workers
    # Workers return historical stats, but import status changes in real-time
    if HAS_REDIS_CLIENT:
        try:
            # Use get_redis_client() for consistent Redis access (handles Sentinel automatically)
            r = get_redis_client()
            logger.debug(f"[Manager pre_render] get_redis_client() returned: {r is not None}")

            if r is not None:
                # Test connection
                try:
                    r.ping()
                    logger.debug("[Manager pre_render] Redis ping successful")
                except Exception as ping_err:
                    logger.debug(f"[Manager pre_render] Redis ping failed: {ping_err}")
                    r = None

            if r is not None:
                # Query import status and database state keys
                import_status = r.get("malware-scan:hashes:import_state")
                full_db_status = r.get("malware-scan:hashes:state:full")
                recent_db_status = r.get("malware-scan:hashes:state:recent")

                # Decode bytes to strings if needed
                if import_status:
                    import_status = import_status.decode() if isinstance(import_status, bytes) else import_status
                if full_db_status:
                    full_db_status = full_db_status.decode() if isinstance(full_db_status, bytes) else full_db_status
                if recent_db_status:
                    recent_db_status = recent_db_status.decode() if isinstance(recent_db_status, bytes) else recent_db_status

                logger.debug(f"[Manager pre_render] Retrieved from Redis: import_status={import_status}, full_db_status={full_db_status}, recent_db_status={recent_db_status}")

                # Set status to success if we got any data from Redis
                if import_status or full_db_status or recent_db_status:
                    ret["malwarebazaar_stats"]["status"] = "success"

                if import_status:
                    ret["malwarebazaar_stats"]["import_status"] = import_status
                    logger.debug(f"[Manager pre_render] Set import_status to: {import_status}")

                if full_db_status:
                    ret["malwarebazaar_stats"]["full_db_status"] = full_db_status

                if recent_db_status:
                    ret["malwarebazaar_stats"]["recent_db_status"] = recent_db_status

                # Get full database timestamps
                full_start = r.get("malware-scan:hashes:import_start_time:full")
                full_end = r.get("malware-scan:hashes:import_end_time:full")
                if full_start:
                    full_start = full_start.decode() if isinstance(full_start, bytes) else full_start
                    ret["malwarebazaar_stats"]["full_import_start_time"] = full_start
                if full_end:
                    full_end = full_end.decode() if isinstance(full_end, bytes) else full_end
                    ret["malwarebazaar_stats"]["full_import_end_time"] = full_end

                # Get recent database timestamps
                recent_start = r.get("malware-scan:hashes:import_start_time:recent")
                recent_end = r.get("malware-scan:hashes:import_end_time:recent")
                if recent_start:
                    recent_start = recent_start.decode() if isinstance(recent_start, bytes) else recent_start
                    ret["malwarebazaar_stats"]["recent_import_start_time"] = recent_start
                if recent_end:
                    recent_end = recent_end.decode() if isinstance(recent_end, bytes) else recent_end
                    ret["malwarebazaar_stats"]["recent_import_end_time"] = recent_end

                # Get import progress data
                buckets = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"]

                # Full database progress
                full_import_total = r.get("malware-scan:hashes:import_total:full")
                if full_import_total:
                    total_str = full_import_total.decode() if isinstance(full_import_total, bytes) else full_import_total
                    ret["malwarebazaar_stats"]["import_progress"]["full"]["total"] = int(total_str)

                # Sum up processed counts from all 16 buckets for full database
                full_processed = 0
                for bucket in buckets:
                    bucket_processed = r.get(f"malware-scan:hashes:import_processed:full:bucket_{bucket}")
                    if bucket_processed:
                        count_str = bucket_processed.decode() if isinstance(bucket_processed, bytes) else bucket_processed
                        full_processed += int(count_str)
                ret["malwarebazaar_stats"]["import_progress"]["full"]["processed"] = full_processed

                # Recent database progress
                recent_import_total = r.get("malware-scan:hashes:import_total:recent")
                if recent_import_total:
                    total_str = recent_import_total.decode() if isinstance(recent_import_total, bytes) else recent_import_total
                    ret["malwarebazaar_stats"]["import_progress"]["recent"]["total"] = int(total_str)

                # Sum up processed counts from all 16 buckets for recent database
                recent_processed = 0
                for bucket in buckets:
                    bucket_processed = r.get(f"malware-scan:hashes:import_processed:recent:bucket_{bucket}")
                    if bucket_processed:
                        count_str = bucket_processed.decode() if isinstance(bucket_processed, bytes) else bucket_processed
                        recent_processed += int(count_str)
                ret["malwarebazaar_stats"]["import_progress"]["recent"]["processed"] = recent_processed

                r.close()
            else:
                logger.debug("[Manager pre_render] Redis client is None, cannot query progress data")
        except BaseException as e:
            logger.debug(f"[Manager pre_render] Failed to query Redis for import progress: {e}")
            logger.debug(format_exc())

    # Get aggregated metrics from all instances
    try:
        data = kwargs["bw_instances_utils"].get_metrics("malware-scan")

        # Update counter values
        ret["counter_malware_detected"]["value"] = data.get("counter_malware_detected", 0)
        ret["counter_files_scanned"]["value"] = data.get("counter_files_scanned", 0)
        ret["counter_cache_hits"]["value"] = data.get("counter_cache_hits", 0)

    except BaseException as e:
        logger.debug(format_exc())
        logger.error(f"Failed to get malware-scan metrics: {e}")
        ret["error"] = str(e)

    return ret


def test_discord(**kwargs):
    """Test Discord webhook by sending test message from manager"""
    logger = getLogger("UI")
    try:
        import requests
        from datetime import datetime
        import socket

        # Get Discord webhook URL from database settings
        db = kwargs.get("Database")
        if not db:
            return {"status": "error", "message": "Database not available"}

        # Query for Discord webhook URL setting
        discord_url = db.get_global_value("MALWARE_SCAN_DISCORD_WEBHOOK_URL")

        if not discord_url or discord_url == "" or discord_url == "your_webhook_url":
            return {"status": "error", "message": "Discord webhook not configured"}

        # Build test message (Discord embed format)
        hostname = socket.gethostname()
        test_payload = {
            "embeds": [{
                "title": "âœ… Discord Webhook Test",
                "description": "This is a test message from BunkerWeb Malware Scanner",
                "color": 65280,  # Green color
                "fields": [
                    {"name": "Status", "value": "Webhook is configured correctly", "inline": False},
                    {"name": "Instance", "value": hostname, "inline": True},
                    {"name": "Test Time", "value": datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC"), "inline": True}
                ],
                "timestamp": datetime.utcnow().isoformat() + "Z"
            }]
        }

        # Send test request to Discord
        response = requests.post(discord_url, json=test_payload, timeout=5)

        if response.status_code >= 200 and response.status_code < 300:
            return {"status": "success", "message": "Discord webhook test successful"}
        else:
            return {"status": "error", "message": f"Discord returned HTTP {response.status_code}"}

    except ImportError:
        return {"status": "error", "message": "requests library not available"}
    except requests.RequestException as e:
        logger.error(f"Discord webhook test failed: {e}")
        return {"status": "error", "message": f"Request failed: {str(e)}"}
    except BaseException as e:
        logger.error(f"Discord webhook test failed: {e}")
        logger.debug(format_exc())
        return {"status": "error", "message": str(e)}


def test_teams(**kwargs):
    """Test Microsoft Teams webhook by sending test message from manager"""
    logger = getLogger("UI")
    try:
        import requests
        from datetime import datetime
        import socket

        # Get Teams webhook URL from database settings
        db = kwargs.get("Database")
        if not db:
            return {"status": "error", "message": "Database not available"}

        # Query for Teams webhook URL setting
        teams_url = db.get_global_value("MALWARE_SCAN_TEAMS_WEBHOOK_URL")

        if not teams_url or teams_url == "" or teams_url == "your_webhook_url":
            return {"status": "error", "message": "Teams webhook not configured"}

        # Build test message (Microsoft Teams MessageCard format)
        hostname = socket.gethostname()
        test_payload = {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": "Webhook Test",
            "sections": [{
                "activityTitle": "âœ… Microsoft Teams Webhook Test",
                "activitySubtitle": "BunkerWeb Malware Scanner",
                "facts": [
                    {"name": "Status", "value": "Webhook is configured correctly"},
                    {"name": "Instance", "value": hostname},
                    {"name": "Test Time", "value": datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")}
                ],
                "markdown": True
            }]
        }

        # Send test request to Teams
        response = requests.post(teams_url, json=test_payload, timeout=5)

        if response.status_code >= 200 and response.status_code < 300:
            return {"status": "success", "message": "Teams webhook test successful"}
        else:
            return {"status": "error", "message": f"Teams returned HTTP {response.status_code}"}

    except ImportError:
        return {"status": "error", "message": "requests library not available"}
    except requests.RequestException as e:
        logger.error(f"Teams webhook test failed: {e}")
        return {"status": "error", "message": f"Request failed: {str(e)}"}
    except BaseException as e:
        logger.error(f"Teams webhook test failed: {e}")
        logger.debug(format_exc())
        return {"status": "error", "message": str(e)}


def test_eicar(**kwargs):
    """Test ClamAV with EICAR test file by calling worker API endpoint"""
    logger = getLogger("UI")
    try:
        # Get first available worker instance
        instances = kwargs["bw_instances_utils"].get_instances(status="up")
        if not instances:
            return {"status": "error", "message": "No worker instances available"}

        # Call the test-eicar endpoint on first worker
        instance = instances[0]
        resp, data = instance.api("/malware-scan/test-eicar", method="POST")

        if resp and isinstance(data, dict):
            # Extract response from first worker
            for hostname, response_data in data.items():
                msg_json = response_data.get("msg", "{}")
                try:
                    result = json.loads(msg_json)
                    return result
                except json.JSONDecodeError:
                    logger.error(f"Failed to parse response from {hostname}")
                    return {"status": "error", "message": "Invalid response from worker"}

        return {"status": "error", "message": "No response from worker"}
    except BaseException as e:
        logger.error(f"EICAR test failed: {e}")
        logger.debug(format_exc())
        return {"status": "error", "message": str(e)}


def get_import_progress(**kwargs):
    """Get current import progress for live updates"""
    logger = getLogger("UI")
    result = {
        "import_status": "unknown",
        "import_progress": {
            "full": {"total": 0, "processed": 0},
            "recent": {"total": 0, "processed": 0},
        },
    }

    try:
        # Try to access Redis through Database settings
        db = kwargs.get("Database")
        if db:
            # Check if Redis is enabled globally
            use_redis = db.get_global_value("USE_REDIS", default="no")
            if use_redis == "yes":
                # Try to import and use redis library
                try:
                    import redis

                    # Get Redis connection details from database
                    redis_host = db.get_global_value("REDIS_HOST", default="127.0.0.1")
                    redis_port = int(db.get_global_value("REDIS_PORT", default="6379"))
                    redis_db_num = int(db.get_global_value("REDIS_DB", default="0"))
                    sentinel_hosts_str = db.get_global_value("REDIS_SENTINEL_HOSTS", default="")

                    # Check if using Redis Sentinel
                    if sentinel_hosts_str and sentinel_hosts_str.strip():
                        # Parse sentinel hosts
                        sentinel_hosts = []
                        for h in sentinel_hosts_str.split():
                            h = h.strip()
                            if ":" in h:
                                host, port = h.rsplit(":", 1)
                                sentinel_hosts.append((host.strip(), int(port.strip())))
                            else:
                                sentinel_hosts.append((h, 26379))

                        # Get service name
                        service_name = db.get_global_value("REDIS_SENTINEL_SERVICE_NAME", default="mymaster")

                        # Connect via Sentinel
                        sentinel = redis.Sentinel(sentinel_hosts, socket_timeout=2, decode_responses=True)
                        r = sentinel.master_for(service_name, socket_timeout=2, db=redis_db_num, decode_responses=True)
                        logger.debug(f"[get_import_progress] Connected to Redis via Sentinel: {service_name}")
                    else:
                        # Connect to Redis directly
                        r = redis.Redis(host=redis_host, port=redis_port, db=redis_db_num, decode_responses=True, socket_connect_timeout=2)
                        logger.debug(f"[get_import_progress] Connected to Redis directly: {redis_host}:{redis_port}")

                    # Query import status
                    import_status = r.get("malware-scan:hashes:import_state")
                    if import_status:
                        result["import_status"] = import_status

                    # Get import progress data
                    buckets = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"]

                    # Full database progress
                    full_import_total = r.get("malware-scan:hashes:import_total:full")
                    if full_import_total:
                        result["import_progress"]["full"]["total"] = int(full_import_total)

                    # Sum up processed counts from all 16 buckets for full database
                    full_processed = 0
                    for bucket in buckets:
                        bucket_processed = r.get(f"malware-scan:hashes:import_processed:full:bucket_{bucket}")
                        if bucket_processed:
                            full_processed += int(bucket_processed)
                    result["import_progress"]["full"]["processed"] = full_processed

                    # Recent database progress
                    recent_import_total = r.get("malware-scan:hashes:import_total:recent")
                    if recent_import_total:
                        result["import_progress"]["recent"]["total"] = int(recent_import_total)

                    # Sum up processed counts from all 16 buckets for recent database
                    recent_processed = 0
                    for bucket in buckets:
                        bucket_processed = r.get(f"malware-scan:hashes:import_processed:recent:bucket_{bucket}")
                        if bucket_processed:
                            recent_processed += int(bucket_processed)
                    result["import_progress"]["recent"]["processed"] = recent_processed

                    r.close()
                except ImportError:
                    logger.debug("[get_import_progress] redis-py not available for direct Redis query")
                except Exception as redis_err:
                    logger.warning(f"[get_import_progress] Redis connection failed: {redis_err}")
                    logger.debug(format_exc())
    except BaseException as e:
        logger.debug(f"Failed to query Redis for import progress: {e}")

    return result


def malware_scan(**kwargs):
    """Main entry point for malware-scan plugin UI page"""
    return {"data": pre_render(**kwargs)}
