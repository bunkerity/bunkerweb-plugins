from logging import getLogger
from traceback import format_exc
from os.path import dirname, join, exists, basename
from flask import Blueprint, jsonify, request, send_file
from flask_login import login_required

from app.dependencies import BW_CONFIG, DB  # type: ignore
from app.routes.utils import cors_required, get_redis_client  # type: ignore

blueprint_path = dirname(__file__)

malware_scan = Blueprint(
    "malware_scan",
    __name__,
)


@malware_scan.route("/api/plugins/malware-scan/test_discord", methods=["POST"])
@login_required
@cors_required
def test_discord():
    """Test Discord webhook from manager UI"""
    logger = getLogger("UI")

    # Get webhook URL from configuration
    config = BW_CONFIG.get_config(
        global_only=True,
        methods=False,
        filtered_settings=("MALWARE_SCAN_DISCORD_WEBHOOK_URL",)
    )
    webhook_url = config.get("MALWARE_SCAN_DISCORD_WEBHOOK_URL", "")

    if not webhook_url or webhook_url.strip() == "":
        return jsonify({"status": "error", "message": "Discord webhook URL not configured"}), 400

    # Send test message to Discord
    try:
        import requests

        payload = {
            "username": "BunkerWeb Malware Scanner",
            "avatar_url": "https://docs.bunkerweb.io/img/logo-v2.0.png",
            "embeds": [
                {
                    "title": "ðŸ§ª Test Message",
                    "description": "Discord webhook is operational! This is a test from BunkerWeb malware-scan plugin.",
                    "color": 3447003,  # Blue color
                    "fields": [
                        {
                            "name": "Status",
                            "value": "âœ… Connected",
                            "inline": True
                        },
                        {
                            "name": "Source",
                            "value": "Manager UI",
                            "inline": True
                        }
                    ],
                    "footer": {
                        "text": "BunkerWeb Malware Scanner"
                    }
                }
            ]
        }

        response = requests.post(
            webhook_url,
            json=payload,
            timeout=10,
            headers={"Content-Type": "application/json"}
        )

        if response.status_code in (200, 204):
            logger.info("Discord webhook test successful")
            return jsonify({"status": "success", "message": "Discord webhook is operational"}), 200
        else:
            error_msg = f"Discord webhook returned status {response.status_code}"
            try:
                error_detail = response.json()
                if "message" in error_detail:
                    error_msg = f"{error_msg}: {error_detail['message']}"
            except:
                pass
            logger.error(error_msg)
            return jsonify({"status": "error", "message": error_msg}), 500

    except Exception as e:
        logger.error(f"Discord webhook test failed: {e}")
        logger.debug(format_exc())
        return jsonify({"status": "error", "message": str(e)}), 500


@malware_scan.route("/api/plugins/malware-scan/test_teams", methods=["POST"])
@login_required
@cors_required
def test_teams():
    """Test Microsoft Teams webhook from manager UI"""
    logger = getLogger("UI")

    # Get webhook URL from configuration
    config = BW_CONFIG.get_config(
        global_only=True,
        methods=False,
        filtered_settings=("MALWARE_SCAN_TEAMS_WEBHOOK_URL",)
    )
    webhook_url = config.get("MALWARE_SCAN_TEAMS_WEBHOOK_URL", "")

    if not webhook_url or webhook_url.strip() == "":
        return jsonify({"status": "error", "message": "Teams webhook URL not configured"}), 400

    # Send test message to Teams
    try:
        import requests

        payload = {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": "BunkerWeb Malware Scanner Test",
            "themeColor": "0078D7",
            "title": "ðŸ§ª Test Message",
            "sections": [
                {
                    "activityTitle": "Webhook Test",
                    "activitySubtitle": "BunkerWeb malware-scan plugin",
                    "activityImage": "https://docs.bunkerweb.io/img/logo-v2.0.png",
                    "facts": [
                        {
                            "name": "Status:",
                            "value": "âœ… Connected"
                        },
                        {
                            "name": "Source:",
                            "value": "Manager UI"
                        }
                    ],
                    "text": "Microsoft Teams webhook is operational! This is a test from BunkerWeb malware-scan plugin."
                }
            ]
        }

        response = requests.post(
            webhook_url,
            json=payload,
            timeout=10,
            headers={"Content-Type": "application/json"}
        )

        if response.status_code in (200, 204):
            # Teams returns "1" in response body on success
            if response.text.strip() == "1":
                logger.info("Teams webhook test successful")
                return jsonify({"status": "success", "message": "Microsoft Teams webhook is operational"}), 200
            else:
                error_msg = f"Teams webhook returned unexpected response: {response.text}"
                logger.error(error_msg)
                return jsonify({"status": "error", "message": error_msg}), 500
        else:
            error_msg = f"Teams webhook returned status {response.status_code}"
            logger.error(error_msg)
            return jsonify({"status": "error", "message": error_msg}), 500

    except Exception as e:
        logger.error(f"Teams webhook test failed: {e}")
        logger.debug(format_exc())
        return jsonify({"status": "error", "message": str(e)}), 500


@malware_scan.route("/api/plugins/malware-scan/test_eicar", methods=["POST"])
@login_required
@cors_required
def test_eicar():
    """Test ClamAV with EICAR test file by calling worker API"""
    logger = getLogger("UI")

    try:
        from app.dependencies import BW_INSTANCES_UTILS  # type: ignore

        instances = BW_INSTANCES_UTILS.get_instances(status="up")

        if not instances:
            return jsonify({"status": "error", "message": "No active workers available"}), 500

        # Call first available worker
        instance = instances[0]

        # The worker endpoint is /malware-scan/test-eicar (POST)
        # Use the instance's apiCaller to send the request
        try:
            resp, response_data = instance.apiCaller.send_to_apis("POST", "/malware-scan/test-eicar", response=True)

            if resp and instance.hostname in response_data:
                worker_response = response_data[instance.hostname]
                if worker_response.get("status") == "success":
                    message = worker_response.get("msg", "EICAR test successful")
                    return jsonify({"status": "success", "message": message}), 200
                else:
                    error_msg = worker_response.get("msg", "Unknown error from worker")
                    return jsonify({"status": "error", "message": error_msg}), 500
            else:
                error_msg = "No response from worker" if not resp else f"Invalid response structure from {instance.hostname}"
                return jsonify({"status": "error", "message": error_msg}), 500

        except Exception as e:
            logger.error(f"EICAR test failed when calling worker: {e}")
            return jsonify({"status": "error", "message": f"Worker call failed: {str(e)}"}), 500

    except Exception as e:
        logger.error(f"EICAR test failed: {e}")
        logger.debug(format_exc())
        return jsonify({"status": "error", "message": str(e)}), 500


@malware_scan.route("/api/plugins/malware-scan/get_import_progress", methods=["GET"])
@login_required
@cors_required
def get_import_progress():
    """Get current import progress for live updates"""
    logger = getLogger("UI")
    result = {
        "import_status": "unknown",
        "import_progress": {
            "full": {"total": 0, "processed": 0},
            "recent": {"total": 0, "processed": 0},
        },
    }

    try:
        # Get Redis client using BunkerWeb helper (handles Sentinel automatically)
        r = get_redis_client()
        logger.debug(f"get_redis_client() returned: {r is not None}")

        if r is not None:
            # Test connection
            try:
                r.ping()
                logger.debug("Redis ping successful")
            except Exception as ping_err:
                logger.debug(f"Redis ping failed: {ping_err}")
                r = None

        if r is not None:
            # Query import status
            import_status = r.get("malware-scan:hashes:import_state")
            logger.debug(f"import_state query returned: {import_status}")
            if import_status:
                # Decode bytes to string if needed
                result["import_status"] = import_status.decode() if isinstance(import_status, bytes) else import_status

            # Get import progress data
            buckets = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"]

            # Full database progress
            full_import_total = r.get("malware-scan:hashes:import_total:full")
            logger.debug(f"import_total:full query returned: {full_import_total}")
            if full_import_total:
                # Decode bytes to string if needed
                total_str = full_import_total.decode() if isinstance(full_import_total, bytes) else full_import_total
                result["import_progress"]["full"]["total"] = int(total_str)

            # Sum up processed counts from all 16 buckets for full database
            full_processed = 0
            for bucket in buckets:
                bucket_processed = r.get(f"malware-scan:hashes:import_processed:full:bucket_{bucket}")
                if bucket_processed:
                    # Decode bytes to string if needed
                    count_str = bucket_processed.decode() if isinstance(bucket_processed, bytes) else bucket_processed
                    full_processed += int(count_str)
            result["import_progress"]["full"]["processed"] = full_processed

            # Recent database progress
            recent_import_total = r.get("malware-scan:hashes:import_total:recent")
            if recent_import_total:
                # Decode bytes to string if needed
                total_str = recent_import_total.decode() if isinstance(recent_import_total, bytes) else recent_import_total
                result["import_progress"]["recent"]["total"] = int(total_str)

            # Sum up processed counts from all 16 buckets for recent database
            recent_processed = 0
            for bucket in buckets:
                bucket_processed = r.get(f"malware-scan:hashes:import_processed:recent:bucket_{bucket}")
                if bucket_processed:
                    # Decode bytes to string if needed
                    count_str = bucket_processed.decode() if isinstance(bucket_processed, bytes) else bucket_processed
                    recent_processed += int(count_str)
            result["import_progress"]["recent"]["processed"] = recent_processed

            r.close()
        else:
            logger.debug("Redis client is None, cannot query progress data")
    except Exception as e:
        logger.debug(f"Failed to query Redis for import progress: {e}")
        logger.debug(format_exc())

    logger.debug(f"Returning progress result: {result}")
    return jsonify(result), 200


@malware_scan.route("/api/plugins/malware-scan/download-full-db", methods=["GET"])
@login_required
@cors_required
def download_full_db():
    """Download the full MalwareBazaar hash database ZIP file"""
    logger = getLogger("UI")

    try:
        # Get Redis client using BunkerWeb helper (handles Sentinel automatically)
        r = get_redis_client()

        if r is None:
            logger.error("Redis client unavailable for download-full-db")
            return jsonify({"status": "error", "message": "Redis unavailable"}), 500

        # Test connection
        try:
            r.ping()
        except Exception as ping_err:
            logger.error(f"Redis ping failed: {ping_err}")
            return jsonify({"status": "error", "message": "Redis connection failed"}), 500

        # Get temp directory path from Redis
        temp_dir_key = "malware_scan:scheduler:temp_dir"
        temp_dir = r.get(temp_dir_key)

        if not temp_dir:
            logger.error("Temp directory not found in Redis (downloads may not be available yet)")
            return jsonify({"status": "error", "message": "Hash database not downloaded yet. Please wait for the scheduler to run."}), 404

        # Decode bytes to string if needed
        temp_dir = temp_dir.decode() if isinstance(temp_dir, bytes) else temp_dir

        # Build full path to ZIP file
        zip_filename = "hashes_full.zip"
        zip_path = join(temp_dir, zip_filename)

        logger.info(f"Attempting to download full DB from: {zip_path}")

        # Check if file exists
        if not exists(zip_path):
            logger.error(f"Full database ZIP file not found at: {zip_path}")
            return jsonify({"status": "error", "message": f"Full database ZIP not found. File may not have been downloaded yet."}), 404

        # Send file for download
        return send_file(
            zip_path,
            mimetype='application/zip',
            as_attachment=True,
            download_name=zip_filename
        )

    except Exception as e:
        logger.error(f"Failed to download full database: {e}")
        logger.debug(format_exc())
        return jsonify({"status": "error", "message": str(e)}), 500
    finally:
        if r:
            r.close()


@malware_scan.route("/api/plugins/malware-scan/download-recent-db", methods=["GET"])
@login_required
@cors_required
def download_recent_db():
    """Download the recent MalwareBazaar hash database ZIP file"""
    logger = getLogger("UI")

    try:
        # Get Redis client using BunkerWeb helper (handles Sentinel automatically)
        r = get_redis_client()

        if r is None:
            logger.error("Redis client unavailable for download-recent-db")
            return jsonify({"status": "error", "message": "Redis unavailable"}), 500

        # Test connection
        try:
            r.ping()
        except Exception as ping_err:
            logger.error(f"Redis ping failed: {ping_err}")
            return jsonify({"status": "error", "message": "Redis connection failed"}), 500

        # Get temp directory path from Redis
        temp_dir_key = "malware_scan:scheduler:temp_dir"
        temp_dir = r.get(temp_dir_key)

        if not temp_dir:
            logger.error("Temp directory not found in Redis (downloads may not be available yet)")
            return jsonify({"status": "error", "message": "Hash database not downloaded yet. Please wait for the scheduler to run."}), 404

        # Decode bytes to string if needed
        temp_dir = temp_dir.decode() if isinstance(temp_dir, bytes) else temp_dir

        # Build full path to ZIP file
        zip_filename = "hashes_recent.zip"
        zip_path = join(temp_dir, zip_filename)

        logger.info(f"Attempting to download recent DB from: {zip_path}")

        # Check if file exists
        if not exists(zip_path):
            logger.error(f"Recent database ZIP file not found at: {zip_path}")
            return jsonify({"status": "error", "message": f"Recent database ZIP not found. File may not have been downloaded yet."}), 404

        # Send file for download
        return send_file(
            zip_path,
            mimetype='application/zip',
            as_attachment=True,
            download_name=zip_filename
        )

    except Exception as e:
        logger.error(f"Failed to download recent database: {e}")
        logger.debug(format_exc())
        return jsonify({"status": "error", "message": str(e)}), 500
    finally:
        if r:
            r.close()
