local class = require("middleclass")
local plugin = require("bunkerweb.plugin")
local utils = require("bunkerweb.utils")
local cjson = require("cjson")
local http = require("resty.http")
local sha256 = require("resty.sha256")
local str = require("resty.string")

-- Load modules (optional - plugin works without optional modules)
-- Add plugin directory to package path so require() can find the modules
package.path = package.path .. ";/etc/bunkerweb/plugins/malware-scan/?.lua"

-- Load support modules
local cache = nil
local cache_load_ok, cache_load_err = pcall(function()
	cache = require("malware_scan_cache")
end)

local file_ops = nil
local file_ops_load_ok, file_ops_load_err = pcall(function()
	file_ops = require("malware_scan_file")
end)

local clamav = nil
local clamav_load_ok, clamav_load_err = pcall(function()
	clamav = require("malware_scan_clamav")
end)

local virustotal = nil
local virustotal_load_ok, virustotal_load_err = pcall(function()
	virustotal = require("malware_scan_virustotal")
end)

local threatfox = nil
local threatfox_load_ok, threatfox_load_err = pcall(function()
	threatfox = require("malware_scan_threatfox")
end)

local sentinelone = nil
local sentinelone_load_ok, sentinelone_load_err = pcall(function()
	sentinelone = require("malware_scan_sentinelone")
end)

local webhook = nil
local webhook_load_ok, webhook_load_err = pcall(function()
	webhook = require("malware_scan_webhook")
end)

local multipart_full_scan = nil
local multipart_full_scan_load_ok, multipart_full_scan_load_err = pcall(function()
	multipart_full_scan = require("malware_scan_multipart_full_scan")
end)

local ms_utils = nil
local ms_utils_load_ok, ms_utils_load_err = pcall(function()
	ms_utils = require("malware_scan_utils")
end)

-- Initialize module dependencies
if cache_load_ok and cache then
	if clamav_load_ok and clamav then
		clamav.set_cache_module(cache)
	end
	if virustotal_load_ok and virustotal then
		virustotal.set_cache_module(cache)
	end
	if threatfox_load_ok and threatfox then
		threatfox.set_cache_module(cache)
	end
	if sentinelone_load_ok and sentinelone then
		sentinelone.set_cache_module(cache)
	end
	if multipart_full_scan_load_ok and multipart_full_scan then
		multipart_full_scan.set_cache_module(cache)
	end
end

if file_ops_load_ok and file_ops then
	if virustotal_load_ok and virustotal then
		virustotal.set_file_ops_module(file_ops)
	end
	if multipart_full_scan_load_ok and multipart_full_scan then
		multipart_full_scan.set_file_ops_module(file_ops)
	end
end

if multipart_full_scan_load_ok and multipart_full_scan then
	if clamav_load_ok and clamav then
		multipart_full_scan.set_clamav_module(clamav)
	end
	if virustotal_load_ok and virustotal then
		multipart_full_scan.set_virustotal_module(virustotal)
	end
	if threatfox_load_ok and threatfox then
		multipart_full_scan.set_threatfox_module(threatfox)
	end
	if sentinelone_load_ok and sentinelone then
		multipart_full_scan.set_sentinelone_module(sentinelone)
	end
	if webhook_load_ok and webhook then
		multipart_full_scan.set_webhook_module(webhook)
	end
end

local malware_scan = class("malware-scan", plugin)

local ngx = ngx
local NOTICE = ngx.NOTICE
local ERR = ngx.ERR
local WARN = ngx.WARN
local INFO = ngx.INFO
local socket = ngx.socket
local HTTP_INTERNAL_SERVER_ERROR = ngx.HTTP_INTERNAL_SERVER_ERROR
local HTTP_OK = ngx.HTTP_OK
local has_variable = utils.has_variable
local get_deny_status = utils.get_deny_status
local tonumber = tonumber
local tostring = tostring
local decode = cjson.decode
local encode = cjson.encode
local to_hex = str.to_hex
local http_new = http.new

-- Plugin version for User-Agent identification
local VERSION = "0.7.2"
local USER_AGENT = "bunkerweb - https://github.com/bunkerity/bunkerweb - malware-scan module v" .. VERSION

-- Version prefix for debug messages
local DEBUG_PREFIX = "[v" .. VERSION .. "] [DEBUG]"

-- Initialize plugin instance with context.
function malware_scan:initialize(ctx)
	plugin.initialize(self, "malware-scan", ctx)
end

-- Helper function to check if debug mode is enabled.
-- Returns true if MALWARE_SCAN_DEBUG=yes, false otherwise.
function malware_scan:is_debug()
	return self.variables["MALWARE_SCAN_DEBUG"] == "yes"
end

-- Log a message only if debug mode is enabled.
-- Uses INFO level for debug messages (semantically correct).
-- Includes version prefix for easier tracking across versions.
function malware_scan:log_debug(message)
	if self:is_debug() then
		self.logger:log(INFO, DEBUG_PREFIX .. " " .. message)
	end
end

-- Mask sensitive values (API keys, webhook URLs) for security.
-- Only shows full values if MALWARE_SCAN_UNMASK_KEYS is set to the specific phrase.
-- @param value The sensitive value to mask (API key, webhook URL, etc.)
-- @return Masked string or original value if unmasking is enabled
function malware_scan:mask_sensitive(value)
	if not value or value == "" then
		return ""
	end

	-- Check if unmasking is explicitly enabled
	local unmask = self.variables["MALWARE_SCAN_UNMASK_KEYS"]
	if unmask == "I_WANT_TO_LEAK_MY_SECRETS_TO_LOG" then
		return value
	end

	-- Mask API keys (show first 4 chars only)
	if value:match("^[a-zA-Z0-9_-]+$") and #value > 20 then
		return value:sub(1, 4) .. "***"
	end

	-- Mask webhook URLs (show protocol and first part only)
	if value:match("^https?://") then
		local protocol, rest = value:match("^(https?://)(.+)$")
		if protocol then
			local domain = rest:match("^([^/]+)")
			if domain then
				-- Show protocol and domain prefix only
				local domain_prefix = domain:sub(1, math.min(#domain, 10))
				return protocol .. domain_prefix .. "***"
			end
		end
		return "https://***"
	end

	-- Generic masking for other sensitive values
	if #value > 8 then
		return value:sub(1, 4) .. "***"
	end
	return "***"
end

-- Sanitize external data (scanner results, filenames) before logging to prevent log injection (CWE-117).
-- Removes control characters and truncates long strings that could break log parsers.
-- @param data The external data to sanitize (scanner signature, API response, etc.)
-- @return Sanitized string safe for logging
function malware_scan:sanitize_external_data(data)
	if not data or data == "" then
		return ""
	end

	-- Use malware_scan_utils sanitization if available
	if ms_utils_load_ok and ms_utils and ms_utils.sanitize_for_logging then
		return ms_utils.sanitize_for_logging(tostring(data))
	end

	-- Fallback sanitization if utils module not loaded
	local sanitized = tostring(data)
	sanitized = sanitized:gsub("[\r\n\t%z\1-\31]", function(c)
		return string.format("\\x%02x", string.byte(c))
	end)
	if #sanitized > 200 then
		sanitized = sanitized:sub(1, 197) .. "..."
	end
	return sanitized
end

-- Init worker phase: Runs in each worker process (workers only, not manager).
-- Used for worker-specific initialization like ClamAV connectivity checks.
-- Also handles cache cleanup with distributed locking to ensure only one worker cleans.
function malware_scan:init_worker()
	-- DIAGNOSTIC: Direct ngx.log to verify function is called
	ngx.log(ngx.NOTICE, "[INIT_WORKER] >>> FUNCTION CALLED - malware-scan v" .. VERSION .. " PID=" .. ngx.worker.pid())

	-- Log entry into init_worker for diagnostics
	self.logger:log(NOTICE, "[INIT_WORKER] Entering init_worker phase for malware-scan v" .. VERSION)

	local init_needed, err = has_variable("MALWARE_SCAN_ENABLED", "yes")
	if init_needed == nil then
		ngx.log(ngx.ERR, "[INIT_WORKER] >>> EARLY EXIT: Failed to check MALWARE_SCAN_ENABLED: " .. err)
		self.logger:log(ERR, "[INIT_WORKER] Failed to check MALWARE_SCAN_ENABLED: " .. err)
		return self:ret(false, "can't check MALWARE_SCAN_ENABLED variable : " .. err)
	end

	-- Check if initialization is needed
	if not init_needed then
		ngx.log(ngx.NOTICE, "[INIT_WORKER] >>> EARLY EXIT: MALWARE_SCAN_ENABLED is not 'yes'")
		self.logger:log(NOTICE, "[INIT_WORKER] Skipping - MALWARE_SCAN_ENABLED is not 'yes'")
		return self:ret(true, "init_worker not needed (disabled)")
	end

	if self.is_loading then
		ngx.log(ngx.NOTICE, "[INIT_WORKER] >>> EARLY EXIT: plugin is in loading phase (is_loading=" .. tostring(self.is_loading) .. ")")
		self.logger:log(NOTICE, "[INIT_WORKER] Skipping - plugin is in loading phase")
		return self:ret(true, "init_worker not needed (loading)")
	end

	ngx.log(ngx.NOTICE, "[INIT_WORKER] >>> PROCEEDING: Malware scanning enabled, about to dump configuration")
	self.logger:log(NOTICE, "[INIT_WORKER] Malware scanning enabled - proceeding with initialization")

	-- Log all configuration for diagnostics (mask sensitive values)
	ngx.log(ngx.NOTICE, "[INIT_WORKER] >>> STARTING CONFIGURATION DUMP")
	self.logger:log(NOTICE, "[INIT_WORKER] ========== Configuration Dump ==========")

	-- Helper function to mask sensitive values
	local function mask_if_sensitive(key, value)
		if not value or value == "" then
			return "(not set)"
		end
		-- Mask API keys, tokens, and webhook URLs
		if key:match("_KEY$") or key:match("_TOKEN$") or key:match("_WEBHOOK_URL$") then
			return "[MASKED]"
		end
		return value
	end

	-- Core settings
	self.logger:log(NOTICE, "[INIT_WORKER] ## Core Settings")
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_ENABLED = %s", mask_if_sensitive("ENABLED", self.variables["MALWARE_SCAN_ENABLED"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_DEBUG = %s", mask_if_sensitive("DEBUG", self.variables["MALWARE_SCAN_DEBUG"])))

	-- ClamAV settings
	self.logger:log(NOTICE, "[INIT_WORKER] ## ClamAV Settings")
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CLAMAV_ENABLED = %s", mask_if_sensitive("ENABLED", self.variables["MALWARE_SCAN_CLAMAV_ENABLED"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CLAMAV_HOST = %s", mask_if_sensitive("HOST", self.variables["MALWARE_SCAN_CLAMAV_HOST"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CLAMAV_PORT = %s", mask_if_sensitive("PORT", self.variables["MALWARE_SCAN_CLAMAV_PORT"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CLAMAV_TIMEOUT = %s", mask_if_sensitive("TIMEOUT", self.variables["MALWARE_SCAN_CLAMAV_TIMEOUT"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CLAMAV_MAX_SIZE = %s", mask_if_sensitive("SIZE", self.variables["MALWARE_SCAN_CLAMAV_MAX_SIZE"])))

	-- File size limits
	self.logger:log(NOTICE, "[INIT_WORKER] ## File Size Limits")
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_HASH_MAX_SIZE = %s", mask_if_sensitive("SIZE", self.variables["MALWARE_SCAN_HASH_MAX_SIZE"])))

	-- Behavior settings
	self.logger:log(NOTICE, "[INIT_WORKER] ## Behavior Settings")
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_BLOCK_MEMORY_UPLOADS = %s", mask_if_sensitive("BLOCK", self.variables["MALWARE_SCAN_BLOCK_MEMORY_UPLOADS"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CLEANUP_FILES = %s", mask_if_sensitive("CLEANUP", self.variables["MALWARE_SCAN_CLEANUP_FILES"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CLEANUP_ORPHANED = %s", mask_if_sensitive("CLEANUP", self.variables["MALWARE_SCAN_CLEANUP_ORPHANED"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CLEANUP_AGE = %s", mask_if_sensitive("AGE", self.variables["MALWARE_SCAN_CLEANUP_AGE"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_SKIP_OTHERS_ON_CLAMAV_DETECT = %s", mask_if_sensitive("SKIP", self.variables["MALWARE_SCAN_SKIP_OTHERS_ON_CLAMAV_DETECT"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_RESUME_SCAN_ON_FIRST_HIT = %s", mask_if_sensitive("RESUME", self.variables["MALWARE_SCAN_RESUME_SCAN_ON_FIRST_HIT"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_BLOCK_ON_FILENAME_INJECTION_ATTACK = %s", mask_if_sensitive("BLOCK", self.variables["MALWARE_SCAN_BLOCK_ON_FILENAME_INJECTION_ATTACK"])))

	-- Cache settings
	self.logger:log(NOTICE, "[INIT_WORKER] ## Cache Settings")
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_USE_SHARED_DATABASE = %s", mask_if_sensitive("USE", self.variables["MALWARE_SCAN_USE_SHARED_DATABASE"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CACHE_VIRUS_TTL = %s", mask_if_sensitive("TTL", self.variables["MALWARE_SCAN_CACHE_VIRUS_TTL"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CACHE_CLEAN_TTL = %s", mask_if_sensitive("TTL", self.variables["MALWARE_SCAN_CACHE_CLEAN_TTL"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CACHE_SHARED_TTL = %s", mask_if_sensitive("TTL", self.variables["MALWARE_SCAN_CACHE_SHARED_TTL"])))

	-- Cache cleanup on restart
	self.logger:log(NOTICE, "[INIT_WORKER] ## Cache Cleanup on Restart")
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ALL = %s", mask_if_sensitive("CLEANUP", self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ALL"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_CLAMAV = %s", mask_if_sensitive("CLEANUP", self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_CLAMAV"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_VIRUSTOTAL = %s", mask_if_sensitive("CLEANUP", self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_VIRUSTOTAL"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_THREATFOX = %s", mask_if_sensitive("CLEANUP", self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_THREATFOX"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_SENTINELONE = %s", mask_if_sensitive("CLEANUP", self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_SENTINELONE"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV4 = %s", mask_if_sensitive("CLEANUP", self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV4"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV6 = %s", mask_if_sensitive("CLEANUP", self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV6"])))

	-- API integrations
	self.logger:log(NOTICE, "[INIT_WORKER] ## API Integrations")
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_API_USE_VIRUSTOTAL = %s", mask_if_sensitive("USE", self.variables["MALWARE_SCAN_API_USE_VIRUSTOTAL"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_API_VIRUSTOTAL_KEY = %s", mask_if_sensitive("MALWARE_SCAN_API_VIRUSTOTAL_KEY", self.variables["MALWARE_SCAN_API_VIRUSTOTAL_KEY"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_API_VIRUSTOTAL_SUSPICIOUS = %s", mask_if_sensitive("SUSPICIOUS", self.variables["MALWARE_SCAN_API_VIRUSTOTAL_SUSPICIOUS"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_API_VIRUSTOTAL_MALICIOUS = %s", mask_if_sensitive("MALICIOUS", self.variables["MALWARE_SCAN_API_VIRUSTOTAL_MALICIOUS"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_API_USE_THREATFOX = %s", mask_if_sensitive("USE", self.variables["MALWARE_SCAN_API_USE_THREATFOX"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_API_THREATFOX_KEY = %s", mask_if_sensitive("MALWARE_SCAN_API_THREATFOX_KEY", self.variables["MALWARE_SCAN_API_THREATFOX_KEY"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_API_USE_SENTINELONE = %s", mask_if_sensitive("USE", self.variables["MALWARE_SCAN_API_USE_SENTINELONE"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_API_SENTINELONE_URL = %s", mask_if_sensitive("URL", self.variables["MALWARE_SCAN_API_SENTINELONE_URL"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_API_SENTINELONE_TOKEN = %s", mask_if_sensitive("MALWARE_SCAN_API_SENTINELONE_TOKEN", self.variables["MALWARE_SCAN_API_SENTINELONE_TOKEN"])))

	-- Webhook notifications
	self.logger:log(NOTICE, "[INIT_WORKER] ## Webhook Notifications")
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_TEAMS_WEBHOOK_URL = %s", mask_if_sensitive("MALWARE_SCAN_TEAMS_WEBHOOK_URL", self.variables["MALWARE_SCAN_TEAMS_WEBHOOK_URL"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_TEAMS_WEBHOOK_RATE_LIMIT = %s", mask_if_sensitive("RATE", self.variables["MALWARE_SCAN_TEAMS_WEBHOOK_RATE_LIMIT"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_DISCORD_WEBHOOK_URL = %s", mask_if_sensitive("MALWARE_SCAN_DISCORD_WEBHOOK_URL", self.variables["MALWARE_SCAN_DISCORD_WEBHOOK_URL"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_DISCORD_WEBHOOK_RATE_LIMIT = %s", mask_if_sensitive("RATE", self.variables["MALWARE_SCAN_DISCORD_WEBHOOK_RATE_LIMIT"])))

	-- Attacker tracking
	self.logger:log(NOTICE, "[INIT_WORKER] ## Attacker Tracking")
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_TRACK_ATTACKERS = %s", mask_if_sensitive("TRACK", self.variables["MALWARE_SCAN_TRACK_ATTACKERS"])))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   MALWARE_SCAN_TRACK_ATTACKER_TTL = %s", mask_if_sensitive("TTL", self.variables["MALWARE_SCAN_TRACK_ATTACKER_TTL"])))

	-- Module availability
	self.logger:log(NOTICE, "[INIT_WORKER] ## Module Availability")
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   clamav_module = %s", clamav and "loaded" or "not loaded"))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   cache_module = %s", cache and "loaded" or "not loaded"))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   file_ops_module = %s", file_ops and "loaded" or "not loaded"))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   virustotal_module = %s", virustotal and "loaded" or "not loaded"))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   threatfox_module = %s", threatfox and "loaded" or "not loaded"))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   sentinelone_module = %s", sentinelone and "loaded" or "not loaded"))
	self.logger:log(NOTICE, string.format("[INIT_WORKER]   webhook_module = %s", webhook and "loaded" or "not loaded"))

	self.logger:log(NOTICE, "[INIT_WORKER] ========== End Configuration Dump ==========")

	-- Test ClamAV connectivity if ClamAV scanning is enabled
	if clamav and self.variables["MALWARE_SCAN_CLAMAV_ENABLED"] == "yes" then
		local clamav_host = self.variables["MALWARE_SCAN_CLAMAV_HOST"]
		local clamav_port = self.variables["MALWARE_SCAN_CLAMAV_PORT"]

		self.logger:log(NOTICE, "[INIT_WORKER] Testing ClamAV connectivity to " .. clamav_host .. ":" .. clamav_port .. " (timeout: 2s)")

		-- Temporarily override timeout to 2 seconds for init test
		local original_timeout = self.variables["MALWARE_SCAN_CLAMAV_TIMEOUT"]
		self.variables["MALWARE_SCAN_CLAMAV_TIMEOUT"] = "2000"

		local ok, data = clamav.command(self, "PING")

		-- Restore original timeout
		self.variables["MALWARE_SCAN_CLAMAV_TIMEOUT"] = original_timeout

		if not ok then
			self.logger:log(ERR, "[INIT_WORKER] ClamAV connectivity test FAILED: " .. (data or "unknown error"))
			return self:ret(false, "ClamAV connectivity test failed: " .. (data or "unknown error"))
		end
		if data ~= "PONG" then
			self.logger:log(ERR, "[INIT_WORKER] ClamAV returned unexpected response: " .. (data or "nil"))
			return self:ret(false, "ClamAV returned unexpected response: " .. (data or "nil"))
		end

		self.logger:log(NOTICE, "[INIT_WORKER] âœ“ ClamAV connectivity test PASSED - Worker ready for malware scanning")
	else
		self.logger:log(NOTICE, "[INIT_WORKER] ClamAV scanning disabled or module not loaded - skipping connectivity test")
	end

	-- Cache cleanup with distributed locking (only first worker performs cleanup)
	-- Check if any cleanup flag is enabled (granular or master switch)
	local cleanup_enabled = self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ALL"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_CLAMAV"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_VIRUSTOTAL"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_THREATFOX"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_SENTINELONE"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV4"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV6"] == "yes"

	if cleanup_enabled then
		if cache then
			-- Try to acquire distributed lock
			local lock_acquired = cache.try_acquire_cleanup_lock(self)
			if lock_acquired then
				self.logger:log(NOTICE, "[CACHE_CLEANUP] Lock acquired - this worker will perform cleanup")
				local cleanup_ok, cleanup_stats = cache.cleanup_all_caches(self)
				if not cleanup_ok then
					self.logger:log(WARN, "[CACHE_CLEANUP] Cache cleanup encountered errors")
				else
					self.logger:log(NOTICE, "[CACHE_CLEANUP] Cache cleanup completed successfully")
				end
				-- Release lock
				cache.release_cleanup_lock(self)
			else
				self.logger:log(NOTICE, "[CACHE_CLEANUP] Another worker is handling cleanup - skipping")
			end
		else
			self.logger:log(WARN, "[CACHE_CLEANUP] Cache cleanup requested but cache module not loaded")
		end
	end

	-- Cleanup orphaned files (workers only - they handle uploads)
	if self.variables["MALWARE_SCAN_CLEANUP_ORPHANED"] == "yes" then
		local cleanup_age = tonumber(self.variables["MALWARE_SCAN_CLEANUP_AGE"]) or 3600
		local cleanup_ok, cleanup_err = self:cleanup_orphaned_files(cleanup_age)
		if not cleanup_ok then
			self.logger:log(
				WARN,
				"failed to cleanup orphaned files: " .. cleanup_err
			)
		end
	end
	
	return self:ret(true, "success")
end

-- Access phase handler - scan uploaded files for malware.
-- Checks for file uploads, scans with ClamAV and/or VirusTotal, and blocks infected files.
function malware_scan:access()
	self:log_debug("=== MALWARE-SCAN ACCESS PHASE CALLED ===")
	self:log_debug("Request: " .. tostring(self.ctx.bw.uri) .. " Method: " .. tostring(self.ctx.bw.request_method))

	-- Check if any scanning service is enabled
	local clamav_enabled = self.variables["MALWARE_SCAN_ENABLED"] == "yes"
	local virustotal_enabled = self.variables["MALWARE_SCAN_API_USE_VIRUSTOTAL"] == "yes"
	local threatfox_enabled = self.variables["MALWARE_SCAN_API_USE_THREATFOX"] == "yes"
	local sentinelone_enabled = self.variables["MALWARE_SCAN_API_USE_SENTINELONE"] == "yes"

	-- Table to collect all detections for single webhook notification
	local detections = {}

	-- Check if we should resume scanning after first detection (DOS risk when enabled)
	local resume_on_hit = self.variables["MALWARE_SCAN_RESUME_SCAN_ON_FIRST_HIT"] == "yes"
	if resume_on_hit then
		self.logger:log(ERR, "[RESUME_MODE] Resume scan on first hit enabled - will collect all scanner results before blocking")
	end

	-- Check if webhooks are configured
	local teams_url = self.variables["MALWARE_SCAN_TEAMS_WEBHOOK_URL"]
	local discord_url = self.variables["MALWARE_SCAN_DISCORD_WEBHOOK_URL"]
	local webhook_enabled = webhook_load_ok and webhook and
	                        ((teams_url and teams_url ~= "" and teams_url ~= "your_webhook_url") or
	                         (discord_url and discord_url ~= "" and discord_url ~= "your_webhook_url"))
	self:log_debug("[WEBHOOK_DEBUG] webhook_module_loaded=" .. tostring(webhook_load_ok) .. ", webhook_enabled=" .. tostring(webhook_enabled) .. ", teams_url=" .. self:mask_sensitive(teams_url or "") .. ", discord_url=" .. self:mask_sensitive(discord_url or ""))

	if not clamav_enabled and not virustotal_enabled and not threatfox_enabled and not sentinelone_enabled then
		self.logger:log(ERR, "MALWARE SCANNING NOT ENABLED - all scanners disabled")
		return self:ret(true, "malware scanning not enabled")
	end

	-- Build scanner list message
	local scanners = {}
	if clamav_enabled then table.insert(scanners, "ClamAV") end
	if virustotal_enabled then table.insert(scanners, "VirusTotal") end
	if threatfox_enabled then table.insert(scanners, "ThreatFox") end
	if sentinelone_enabled then table.insert(scanners, "SentinelOne") end

	if #scanners > 1 then
		self.logger:log(ERR, "Multi-layer scanning enabled (" .. table.concat(scanners, " + ") .. ")")
	else
		self.logger:log(ERR, scanners[1] .. "-only scanning enabled")
	end

	self:log_debug("Plugin ENABLED, checking for file upload")
	self:log_debug("Content-Type: " .. tostring(self.ctx.bw.http_content_type))

	if
		not self.ctx.bw.http_content_type
		or (
			not self.ctx.bw.http_content_type:match("boundary")
			or not self.ctx.bw.http_content_type:match("multipart/form%-data")
		)
	then
		return self:ret(true, "no file upload detected")
	end

	self.logger:log(ERR, "file upload detected, scanning for malware")

	ngx.req.read_body()

	local body_file = ngx.req.get_body_file()

	self:log_debug("body_file = " .. tostring(body_file))

	if not body_file then
		self.logger:log(
			ERR,
			"upload body in memory, not in file - increase client_body_buffer_size " ..
			"or decrease it to force file buffering for virus scanning"
		)

		if self.variables["MALWARE_SCAN_BLOCK_MEMORY_UPLOADS"] == "yes" then
			self.logger:log(ERR, "BLOCKING UPLOAD - cannot scan files in memory (need file buffering)")
			return self:ret(
				true,
				"upload in memory blocked - cannot scan (increase client_body_buffer_size)",
				get_deny_status(),
				nil,
				{
					id = "unscannable_memory",
					reason = "body in memory, not file"
				}
			)
		else
			return self:ret(true, "upload in memory, skipping scan (WARNING)")
		end
	end

	-- Calculate SHA256 checksum (used for webhooks, logging, and hash-based scanners)
	local checksum, checksum_ok
	local file_size = file_ops and file_ops.get_file_size(self, body_file) or nil
	local hash_max_size = tonumber(self.variables["MALWARE_SCAN_HASH_MAX_SIZE"]) or 67108864  -- default 64MB

	if file_size and file_size > hash_max_size then
		self.logger:log(ERR, "[SIZE_LIMIT] File size " .. file_size .. " bytes exceeds hash scan limit " .. hash_max_size .. " bytes - skipping SHA256 calculation")
		checksum_ok = false
		checksum = nil
	else
		-- Always calculate checksum for webhooks and logging, even in ClamAV-only mode
		if file_ops then
			checksum_ok, checksum = file_ops.calculate_sha256(self, body_file)
		else
			checksum_ok, checksum = false, nil
		end
		if checksum_ok and checksum ~= "empty_file" then
			self.logger:log(ERR, "file SHA256: " .. checksum)
		end
	end

	-- Check ClamAV cache first (works even in ClamAV-only mode)
	local clamav_cache_hit = false
	if clamav_enabled and checksum_ok and checksum and checksum ~= "empty_file" then
		local clamav_cache_ok, clamav_cached, cached_size
		if cache then
			clamav_cache_ok, clamav_cached, cached_size = cache.is_in_clamav_cache(self, checksum, file_size)
		else
			clamav_cache_ok, clamav_cached, cached_size = true, nil, nil
		end

		if clamav_cache_ok and clamav_cached and clamav_cached ~= "clean" then
			-- Cached result is MALICIOUS
			clamav_cache_hit = true
			clamav_enabled = false  -- Disable ClamAV scan since we have cached result
			self.logger:log(ERR, "[CACHE_HIT] ClamAV cache shows malicious - skipping ClamAV scan")
			self.logger:log(ERR, "MALWARE DETECTED BY CLAMAV (cached)")
			self.logger:log(ERR, "ClamAV signature: " .. self:sanitize_external_data(clamav_cached) .. " (SHA256: " .. checksum .. ")")
			detections["ClamAV (cached)"] = clamav_cached

			-- Check if we should block immediately or continue scanning
			if not resume_on_hit then
				-- Default behavior: block immediately

				-- Send webhook notification
				if checksum and next(detections) ~= nil then
					if webhook then
						local ok, err = pcall(webhook.send_notification, self, checksum, detections)
						if not ok then
							self.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
						end
					else
						self.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
					end
				end

				-- Cleanup file
				local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
				if cleanup_enabled ~= "no" then
					local cleanup_ok, cleanup_err
					if file_ops then
						cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
					else
						cleanup_ok, cleanup_err = true, nil
					end
					if not cleanup_ok then
						self.logger:log(ERR, "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
					end
				end

				return self:ret(
					true,
					"malware detected by ClamAV cache (SHA256: " .. checksum .. "): " .. clamav_cached,
					get_deny_status(),
					nil,
					{
						id = "malware_detected_clamav_cache",
						file = body_file,
						checksum = checksum,
						detection = clamav_cached,
						scanner = "ClamAV (cached)"
					}
				)
			else
				-- Resume mode: continue to other scanners for comprehensive intelligence
				self.logger:log(ERR, "[RESUME_MODE] Malware detected by ClamAV cache, continuing to other scanners")
			end
		elseif clamav_cache_ok and clamav_cached and clamav_cached == "clean" then
			-- Cached result is CLEAN - skip ClamAV scan, allow file
			clamav_cache_hit = true
			clamav_enabled = false  -- Disable ClamAV scan for this request
			self.logger:log(ERR, "[CACHE_HIT] ClamAV cache shows clean - skipping ClamAV scan")
			self:log_debug("[CACHE_HIT] File is known clean from cache, allowing upload without scan")
		end
	end

	-- OPTIMIZATION: Check hash-based caches BEFORE ClamAV to avoid wasting resources
	-- If we already know the file is malicious from cache, skip ClamAV scan entirely
	local clamav_can_skip = false
	if virustotal_enabled or threatfox_enabled or sentinelone_enabled then
		if file_size and file_size > hash_max_size then
			self.logger:log(ERR, "[SIZE_LIMIT] Skipping hash-based scanners for oversized file")
		elseif checksum_ok and checksum and checksum ~= "empty_file" then
			self.logger:log(ERR, "[CACHE_CHECK] Checking hash-based caches before ClamAV scan")

			-- Check ThreatFox cache
			if threatfox_enabled then
				local tf_cache_ok, tf_cached, tf_cached_size
				if cache then
					tf_cache_ok, tf_cached, tf_cached_size = cache.is_in_threatfox_cache(self, checksum, file_size)
				else
					tf_cache_ok, tf_cached, tf_cached_size = true, nil, nil
				end
				if tf_cache_ok and tf_cached and tf_cached ~= "clean" then
					self.logger:log(ERR, "[CACHE_HIT] ThreatFox cache shows malicious")
					self.logger:log(ERR, "MALWARE DETECTED BY THREATFOX (cached)")
					self.logger:log(ERR, "ThreatFox detection: " .. self:sanitize_external_data(tf_cached) .. " (SHA256: " .. checksum .. ")")
					detections["ThreatFox (cached)"] = tf_cached
					clamav_can_skip = true  -- Skip ClamAV since we know it's malicious

					-- Check if we should block immediately or continue scanning
					if not resume_on_hit then
						-- Default behavior: block immediately

						-- Send webhook notification with all detections
						if checksum and next(detections) ~= nil then
							if webhook then
								local ok, err = pcall(webhook.send_notification, self, checksum, detections)
								if not ok then
									self.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
								end
							else
								self.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
							end
						end

						local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
						if cleanup_enabled ~= "no" then
							local cleanup_ok, cleanup_err
							if file_ops then
								cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
							else
								cleanup_ok, cleanup_err = true, nil
							end
							if not cleanup_ok then
								self.logger:log(ERR, "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
							end
						end

						return self:ret(
							true,
							"malware detected by ThreatFox cache (SHA256: " .. checksum .. "): " .. tf_cached,
							get_deny_status(),
							nil,
							{
								id = "malware_detected_threatfox_cache",
								file = body_file,
								checksum = checksum,
								detection = tf_cached,
								scanner = "ThreatFox (cached)"
							}
						)
					else
						-- Resume mode: continue to other scanners
						self.logger:log(ERR, "[RESUME_MODE] Malware detected by ThreatFox cache, continuing to other scanners")
					end
				end
			end

			-- Check VirusTotal cache
			if virustotal_enabled then
				local vt_cache_ok, vt_cached, vt_cached_size
				if cache then
					vt_cache_ok, vt_cached, vt_cached_size = cache.is_in_vt_cache(self, checksum, file_size)
				else
					vt_cache_ok, vt_cached, vt_cached_size = true, nil, nil
				end
				if vt_cache_ok and vt_cached and vt_cached ~= "clean" then
					self.logger:log(ERR, "[CACHE_HIT] VirusTotal cache shows malicious")
					self.logger:log(ERR, "MALWARE DETECTED BY VIRUSTOTAL (cached)")
					self.logger:log(ERR, "VirusTotal detection: " .. self:sanitize_external_data(vt_cached) .. " (SHA256: " .. checksum .. ")")
					detections["VirusTotal (cached)"] = vt_cached
					clamav_can_skip = true  -- Skip ClamAV since we know it's malicious

					-- Check if we should block immediately or continue scanning
					if not resume_on_hit then
						-- Default behavior: block immediately

						-- Send webhook notification with all detections
						if checksum and next(detections) ~= nil then
							if webhook then
								local ok, err = pcall(webhook.send_notification, self, checksum, detections)
								if not ok then
									self.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
								end
							else
								self.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
							end
						end

						local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
						if cleanup_enabled ~= "no" then
							local cleanup_ok, cleanup_err
							if file_ops then
								cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
							else
								cleanup_ok, cleanup_err = true, nil
							end
							if not cleanup_ok then
								self.logger:log(ERR, "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
							end
						end

						return self:ret(
							true,
							"malware detected by VirusTotal cache (SHA256: " .. checksum .. "): " .. vt_cached,
							get_deny_status(),
							nil,
							{
								id = "malware_detected_virustotal_cache",
								file = body_file,
								checksum = checksum,
								detection = vt_cached,
								scanner = "VirusTotal (cached)"
							}
						)
					else
						-- Resume mode: continue to other scanners
						self.logger:log(ERR, "[RESUME_MODE] Malware detected by VirusTotal cache, continuing to other scanners")
					end
				end
			end

			-- Check SentinelOne cache
			if sentinelone_enabled then
				local s1_cache_ok, s1_cached, s1_cached_size
				if cache then
					s1_cache_ok, s1_cached, s1_cached_size = cache.is_in_sentinelone_cache(self, checksum, file_size)
				else
					s1_cache_ok, s1_cached, s1_cached_size = true, nil, nil
				end
				if s1_cache_ok and s1_cached and s1_cached ~= "clean" then
					self.logger:log(ERR, "[CACHE_HIT] SentinelOne cache shows malicious")
					self.logger:log(ERR, "MALWARE DETECTED BY SENTINELONE (cached)")
					self.logger:log(ERR, "SentinelOne detection: " .. self:sanitize_external_data(s1_cached) .. " (SHA256: " .. checksum .. ")")
					detections["SentinelOne (cached)"] = s1_cached
					clamav_can_skip = true  -- Skip ClamAV since we know it's malicious

					-- Check if we should block immediately or continue scanning
					if not resume_on_hit then
						-- Default behavior: block immediately

						-- Send webhook notification with all detections
						if checksum and next(detections) ~= nil then
							if webhook then
								local ok, err = pcall(webhook.send_notification, self, checksum, detections)
								if not ok then
									self.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
								end
							else
								self.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
							end
						end

						local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
						if cleanup_enabled ~= "no" then
							local cleanup_ok, cleanup_err
							if file_ops then
								cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
							else
								cleanup_ok, cleanup_err = true, nil
							end
							if not cleanup_ok then
								self.logger:log(ERR, "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
							end
						end

						return self:ret(
							true,
							"malware detected by SentinelOne cache (SHA256: " .. checksum .. "): " .. s1_cached,
							get_deny_status(),
							nil,
							{
								id = "malware_detected_sentinelone_cache",
								file = body_file,
								checksum = checksum,
								detection = s1_cached,
								scanner = "SentinelOne (cached)"
							}
						)
					else
						-- Resume mode: continue to other scanners
						self.logger:log(ERR, "[RESUME_MODE] Malware detected by SentinelOne cache, continuing to other scanners")
					end
				end
			end

			self.logger:log(ERR, "[CACHE_MISS] No malicious results in caches - continuing with ClamAV scan")
		end
	end  -- end of hash-based scanners check

	-- Check if we should skip full multipart body scan
	-- For multipart uploads, the body SHA256 changes on every upload due to random HTTP boundaries,
	-- making caching ineffective and wasting ClamAV resources. Individual file extraction always occurs.
	local skip_full_body_scan = false
	local is_multipart = self.ctx.bw.http_content_type and self.ctx.bw.http_content_type:match("multipart/form%-data")
	local scan_full_body = self.variables["MALWARE_SCAN_SCAN_FULL_MULTIPART_BODY"]

	-- Save original scanner enabled states before potentially disabling for body scan
	local clamav_enabled_for_files = clamav_enabled
	local virustotal_enabled_for_files = virustotal_enabled
	local threatfox_enabled_for_files = threatfox_enabled
	local sentinelone_enabled_for_files = sentinelone_enabled

	if is_multipart and (scan_full_body == nil or scan_full_body == "" or scan_full_body == "no") then
		skip_full_body_scan = true
		self.logger:log(ERR, "[MULTIPART] Skipping full body scan (random boundaries prevent caching) - will extract and scan individual files")
		-- Skip both ClamAV and external API scanners for the body
		-- Individual files will be scanned in multipart_full_scan module
		clamav_enabled = false
		virustotal_enabled = false
		threatfox_enabled = false
		sentinelone_enabled = false
	end

	-- Check file size for ClamAV scan limit
	local clamav_skipped_reason = nil
	local clamav_actually_scanned = false
	if clamav_enabled then
		local file_size = file_ops and file_ops.get_file_size(self, body_file) or nil
		if file_size then
			local max_size = tonumber(self.variables["MALWARE_SCAN_CLAMAV_MAX_SIZE"]) or 26214400
			if file_size > max_size then
				self.logger:log(
					ERR,
					"file too large for ClamAV INSTREAM scan: " .. file_size .. " bytes (max: " .. max_size .. " bytes), skipping ClamAV scan"
				)
				clamav_skipped_reason = "file too large (" .. file_size .. " bytes)"
				clamav_enabled = false  -- Skip ClamAV scan, continue with hash-based scanners
			end
		end
	end

	-- Scan with ClamAV if enabled and file size is acceptable
	local detected = "clean"
	if clamav_enabled then
		clamav_actually_scanned = true
		self:log_debug("Calling scan_file() with: " .. body_file)

		local ok
		if clamav then
			ok, detected = clamav.scan_file_instream(self, body_file)
		else
			self.logger:log(ERR, "ClamAV module not loaded")
			ok, detected = false, "ClamAV module not loaded"
		end

		self:log_debug("scan_file returned - ok: " .. tostring(ok) .. ", detected: " .. tostring(detected))

		if not ok then
			-- Check if the error is due to file size limit
			if detected and detected:match("size limit") then
				self.logger:log(ERR, "ClamAV scan failed due to size limit: " .. detected)
				clamav_skipped_reason = "size limit exceeded"
				clamav_actually_scanned = false
			else
				self.logger:log(ERR, "ClamAV scan failed: " .. detected)
			end
			-- Don't fail the request, continue to hash-based scanners if enabled
			detected = "clean"
		elseif detected and detected ~= "clean" then
			-- ClamAV detected malware
			self.logger:log(ERR, "MALWARE DETECTED BY CLAMAV")
			self.logger:log(ERR, "ClamAV signature: " .. self:sanitize_external_data(detected) .. " in file: " .. self:sanitize_external_data(body_file))

			-- Cache the ClamAV detection result
			if checksum_ok and checksum and checksum ~= "empty_file" and cache then
				cache.add_to_clamav_cache(self, checksum, detected, file_size)
			end

			-- Check if we should skip cloud scanners and block immediately
			local skip_others = self.variables["MALWARE_SCAN_SKIP_OTHERS_ON_CLAMAV_DETECT"]
			local any_cloud_enabled = virustotal_enabled or threatfox_enabled or sentinelone_enabled
			if (skip_others == "yes" or not any_cloud_enabled) and not resume_on_hit then
				-- Block immediately (default behavior)
				self.logger:log(ERR, "BLOCKING REQUEST - skipping cloud scanner checks (faster response)")
				if detected and detected ~= "clean" then
					detections["ClamAV"] = detected
				end


				-- Send webhook notification with all detections
				if checksum and next(detections) ~= nil then
					if webhook then
						local ok, err = pcall(webhook.send_notification, self, checksum, detections)
						if not ok then
							self.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
						end
					else
						self.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
					end
				end

				local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
				if cleanup_enabled ~= "no" then
					local cleanup_ok, cleanup_err
			if file_ops then
				cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
			else
				cleanup_ok, cleanup_err = true, nil
			end
					if not cleanup_ok then
						self.logger:log(
							ERR,
							"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
						)
					end
				end

				local deny_status = get_deny_status()
				self:log_debug("Returning block status: " .. tostring(deny_status))

				return self:ret(
					true,
					"malware detected by ClamAV in file " .. body_file .. ": " .. detected,
					deny_status,
					nil,
					{
						id = "malware_detected_clamav",
						file = body_file,
						signature = detected,
						scanner = "ClamAV"
					}
				)
			else
				-- Continue to cloud scanners for additional analysis
				if resume_on_hit then
					self.logger:log(ERR, "[RESUME_MODE] ClamAV detected malware, continuing to all remaining scanners")
				else
					self.logger:log(ERR, "ClamAV detected malware, continuing to cloud scanners for additional analysis")
				end
				-- Add ClamAV detection to detections table
				if detected and detected ~= "clean" then
					detections["ClamAV"] = detected
				end
				-- Keep detected value, will be used in final decision
			end
		else
			-- ClamAV reported clean - cache this result too
			self.logger:log(ERR, "ClamAV scan: file is clean")
			if checksum_ok and checksum and checksum ~= "empty_file" and cache then
				cache.add_to_clamav_cache(self, checksum, "clean", file_size)
			end
		end
	else
		self.logger:log(ERR, "ClamAV scanning disabled, skipping to VirusTotal")
	end

	-- Check hash-based scanners if enabled (calculate SHA256 for hash-based checks if not already done)
	local vt_detected = "clean"
	if virustotal_enabled or threatfox_enabled or sentinelone_enabled then
		-- Reuse checksum from early cache check if available, otherwise calculate now
		if not checksum_ok or not checksum then
			-- Check file size before calculating SHA256
			local file_size = file_ops and file_ops.get_file_size(self, body_file) or nil
			local hash_max_size = tonumber(self.variables["MALWARE_SCAN_HASH_MAX_SIZE"]) or 67108864  -- default 64MB

			if file_size and file_size > hash_max_size then
				self.logger:log(ERR, "[SIZE_LIMIT] File size " .. file_size .. " bytes exceeds hash scan limit " .. hash_max_size .. " bytes - skipping hash-based scanners")
				checksum_ok = false
				checksum = nil
			else
				self.logger:log(ERR, "Hash-based scanning enabled, calculating SHA256 checksum")
				if file_ops then
				checksum_ok, checksum = file_ops.calculate_sha256(self, body_file)
			else
				checksum_ok, checksum = false, nil
			end
			end
		else
			self.logger:log(ERR, "Hash-based scanning enabled, reusing previously calculated SHA256")
		end
		if checksum_ok then
			self.logger:log(ERR, "file SHA256: " .. checksum)

			-- Check if file is empty (0 bytes)
			if checksum == "empty_file" then
				self.logger:log(ERR, "file is 0 bytes, skipping hash-based checks")
				vt_detected = "clean"
			else
				-- Check ThreatFox first (faster, free API, preserves VT quota)
				if threatfox_enabled then
					self.logger:log(ERR, "checking file against ThreatFox API")
					local tf_ok, tf_result
					if threatfox then
						tf_ok, tf_result = threatfox.check_threatfox(self, checksum, file_size)
					else
						tf_ok, tf_result = true, "clean"
					end
					if tf_ok then
						local threatfox_detected = tf_result
						if threatfox_detected ~= "clean" then
							self.logger:log(ERR, "MALWARE DETECTED BY THREATFOX")
							self.logger:log(ERR, "ThreatFox detection: " .. self:sanitize_external_data(threatfox_detected) .. " (SHA256: " .. checksum .. ")")
							detections["ThreatFox"] = threatfox_detected

							-- Share file with threat intelligence platforms if enabled
							local share_ok, share_err = self:share_detected_file(body_file, checksum, "ThreatFox")
							if not share_ok then
								self.logger:log(ERR, "[SHARE] Failed to share file: " .. share_err)
							end

							-- Check if we should block immediately or continue scanning
							if not resume_on_hit then
								-- Default behavior: block immediately
								self.logger:log(ERR, "BLOCKING REQUEST")

								-- Send webhook notification with all detections
								if checksum and next(detections) ~= nil then
									if webhook then
										local ok, err = pcall(webhook.send_notification, self, checksum, detections)
										if not ok then
											self.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
										end
									else
										self.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
									end
								end

								local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
								if cleanup_enabled ~= "no" then
									local cleanup_ok, cleanup_err
									if file_ops then
										cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
									else
										cleanup_ok, cleanup_err = true, nil
									end
									if not cleanup_ok then
										self.logger:log(
											ERR,
											"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
										)
									end
								end

								return self:ret(
									true,
									"malware detected by ThreatFox (SHA256: " .. checksum .. "): " .. threatfox_detected,
									get_deny_status(),
									nil,
									{
										id = "malware_detected_threatfox",
										file = body_file,
										checksum = checksum,
										detection = threatfox_detected,
										scanner = "ThreatFox"
									}
								)
							else
								-- Resume mode: continue to remaining scanners
								self.logger:log(ERR, "[RESUME_MODE] Malware detected by ThreatFox, continuing to remaining scanners")
							end
						else
							self.logger:log(ERR, "ThreatFox scan: file is clean")
						end
					else
						self.logger:log(ERR, "ThreatFox check failed: " .. tf_result)
					end
				end

				-- Check VirusTotal if enabled (after ThreatFox to preserve API quota)
				if virustotal_enabled then
					self.logger:log(ERR, "checking file against VirusTotal API")
				local vt_ok, vt_result, vt_found
				if virustotal then
					vt_ok, vt_result, vt_found = virustotal.check_virustotal(self, body_file, checksum)
				else
					vt_ok, vt_result, vt_found = true, "clean", false
				end
				if vt_ok then
					vt_detected = vt_result

					-- Check if we should upload unknown malware to VT
					if not vt_found and detected and detected ~= "clean" then
						-- ClamAV detected malware, but VT doesn't have the file
						if self.variables["MALWARE_SCAN_API_VIRUSTOTAL_UPLOAD_UNKNOWN"] == "yes" then
							self.logger:log(ERR, "ClamAV detected malware but VT doesn't have file, uploading to VirusTotal")
							local upload_ok, analysis_id, file_size = self:virustotal_upload_file(body_file)
							if upload_ok then
								self.logger:log(ERR, "file uploaded successfully (" .. file_size .. " bytes), analysis ID: " .. tostring(analysis_id))

								-- Check if we should auto-vote
								if self.variables["MALWARE_SCAN_API_VIRUSTOTAL_AUTO_VOTE"] == "yes" then
									self.logger:log(ERR, "auto-voting file as malicious on VirusTotal")
									local vote_ok, vote_err = self:virustotal_vote(checksum, "malicious")
									if vote_ok then
										self.logger:log(ERR, "malicious vote submitted successfully")
									else
										self.logger:log(ERR, "failed to submit vote: " .. vote_err)
									end
								end
							else
								self.logger:log(ERR, "failed to upload file to VirusTotal: " .. analysis_id)
							end
						else
							self.logger:log(ERR, "ClamAV detected malware but VT doesn't have file (upload disabled)")
						end
					end

					if vt_detected ~= "clean" then
						self.logger:log(ERR, "MALWARE DETECTED BY VIRUSTOTAL")
						self.logger:log(ERR, "VirusTotal detection: " .. self:sanitize_external_data(vt_detected) .. " (SHA256: " .. checksum .. ")")
						detections["VirusTotal"] = vt_detected

						-- Check if we should block immediately or continue scanning
						if not resume_on_hit then
							-- Default behavior: block immediately
							self.logger:log(ERR, "BLOCKING REQUEST")

							-- Send webhook notification with all detections
							if checksum and next(detections) ~= nil then
								if webhook then
									local ok, err = pcall(webhook.send_notification, self, checksum, detections)
									if not ok then
										self.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
									end
								else
									self.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
								end
							end

							local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
							if cleanup_enabled ~= "no" then
								local cleanup_ok, cleanup_err
								if file_ops then
									cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
								else
									cleanup_ok, cleanup_err = true, nil
								end
								if not cleanup_ok then
									self.logger:log(
										ERR,
										"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
									)
								end
							end

							return self:ret(
								true,
								"malware detected by VirusTotal (SHA256: " .. checksum .. "): " .. vt_detected,
								get_deny_status(),
								nil,
								{
									id = "malware_detected_virustotal",
									file = body_file,
									checksum = checksum,
									detection = vt_detected,
									scanner = "VirusTotal"
								}
							)
						else
							-- Resume mode: continue to remaining scanners
							self.logger:log(ERR, "[RESUME_MODE] Malware detected by VirusTotal, continuing to remaining scanners")
						end
					else
						self.logger:log(ERR, "VirusTotal scan: file is clean")
					end
				else
					self.logger:log(ERR, "VirusTotal check failed: " .. vt_result)
				end
				end

				-- Check SentinelOne if enabled (uses same checksum)
				if sentinelone_enabled then
					self.logger:log(ERR, "checking file against SentinelOne API")
					local s1_ok, s1_result
					if sentinelone then
						s1_ok, s1_result = sentinelone.check_sentinelone(self, checksum, file_size)
					else
						s1_ok, s1_result = true, "clean"
					end
					if s1_ok then
						local sentinelone_detected = s1_result
						if sentinelone_detected ~= "clean" then
							self.logger:log(ERR, "MALWARE DETECTED BY SENTINELONE")
							self.logger:log(ERR, "SentinelOne detection: " .. self:sanitize_external_data(sentinelone_detected) .. " (SHA256: " .. checksum .. ")")
							detections["SentinelOne"] = sentinelone_detected

							-- Share file with threat intelligence platforms if enabled
							local share_ok, share_err = self:share_detected_file(body_file, checksum, "SentinelOne")
							if not share_ok then
								self.logger:log(ERR, "[SHARE] Failed to share file: " .. share_err)
							end

							-- Check if we should block immediately or continue scanning
							if not resume_on_hit then
								-- Default behavior: block immediately
								self.logger:log(ERR, "BLOCKING REQUEST")

								-- Send webhook notification with all detections
								if checksum and next(detections) ~= nil then
									if webhook then
										local ok, err = pcall(webhook.send_notification, self, checksum, detections)
										if not ok then
											self.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
										end
									else
										self.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
									end
								end

								local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
								if cleanup_enabled ~= "no" then
									local cleanup_ok, cleanup_err
									if file_ops then
										cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
									else
										cleanup_ok, cleanup_err = true, nil
									end
									if not cleanup_ok then
										self.logger:log(
											ERR,
											"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
										)
									end
								end

								return self:ret(
									true,
									"malware detected by SentinelOne (SHA256: " .. checksum .. "): " .. sentinelone_detected,
									get_deny_status(),
									nil,
									{
										id = "malware_detected_sentinelone",
										file = body_file,
										checksum = checksum,
										detection = sentinelone_detected,
										scanner = "SentinelOne"
									}
								)
							else
								-- Resume mode: continue (all scanners complete)
								self.logger:log(ERR, "[RESUME_MODE] Malware detected by SentinelOne")
							end
						else
							self.logger:log(ERR, "SentinelOne scan: file is clean")
						end
					else
						self.logger:log(ERR, "SentinelOne check failed: " .. s1_result)
					end
				end
			end
		else
			self.logger:log(ERR, "failed to calculate SHA256: " .. checksum)
		end
	end

	-- Clean up temp file after all scans complete (unless resume mode needs it for multipart parsing)

	-- Send webhook notification with all detections
	if checksum and next(detections) ~= nil then
		webhook.send_notification(self, checksum, detections)
	end

	-- Skip cleanup if resume mode is enabled - body file still needed for per-file scanning
	local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
	if cleanup_enabled ~= "no" and not resume_on_hit then
		local cleanup_ok, cleanup_err = file_ops and file_ops.cleanup_file(self, body_file)
		if not cleanup_ok then
			self.logger:log(
				ERR,
				"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
			)
		end
	elseif resume_on_hit then
		self:log_debug("[RESUME_MODE] Preserving body file for multipart per-file scanning")
	end

	-- If resume mode is enabled and any detections exist, block now with all collected intelligence
	if resume_on_hit and next(detections) ~= nil then
		local scanner_list = {}
		for scanner, detection in pairs(detections) do
			table.insert(scanner_list, scanner)
		end
		self.logger:log(ERR, "[RESUME_MODE] All scanners complete - MALWARE DETECTED BY: " .. table.concat(scanner_list, ", "))
		self.logger:log(ERR, "[RESUME_MODE] Blocking request with comprehensive detection data")

		-- Send final webhook notification with all detections
		if checksum and next(detections) ~= nil then
			if webhook then
				local ok, err = pcall(webhook.send_notification, self, checksum, detections)
				if not ok then
					self.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
				end
			else
				self.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
			end
		end

		-- Final cleanup
		local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
		if cleanup_enabled ~= "no" then
			local cleanup_ok, cleanup_err
			if file_ops then
				cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
			else
				cleanup_ok, cleanup_err = true, nil
			end
			if not cleanup_ok then
				self.logger:log(
					ERR,
					"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
				)
			end
		end

		return self:ret(
			true,
			"malware detected (resume mode - collected " .. #scanner_list .. " detections)",
			get_deny_status(),
			nil,
			{
				id = "malware_detected_resume_mode",
				file = body_file,
				checksum = checksum,
				detections = detections,
				scanner_count = #scanner_list
			}
		)
	end

	-- If we reach here, check if ClamAV detected but we continued to VT
	if detected and detected ~= "clean" and vt_detected and vt_detected ~= "clean" then
		-- Both ClamAV and VirusTotal detected malware
		self.logger:log(ERR, "MALWARE DETECTED BY BOTH CLAMAV AND VIRUSTOTAL - BLOCKING REQUEST")
		self.logger:log(ERR, "ClamAV: " .. self:sanitize_external_data(detected) .. ", VirusTotal: " .. self:sanitize_external_data(vt_detected))
		if detected and detected ~= "clean" then
			detections["ClamAV"] = detected
		end
		if vt_detected and vt_detected ~= "clean" then
			detections["VirusTotal"] = vt_detected
		end


		-- Send webhook notification with all detections
		if checksum and next(detections) ~= nil then
			if webhook then
				local ok, err = pcall(webhook.send_notification, self, checksum, detections)
				if not ok then
					self.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
				end
			else
				self.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
			end
		end

		local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
		if cleanup_enabled ~= "no" then
			local cleanup_ok, cleanup_err
			if file_ops then
				cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
			else
				cleanup_ok, cleanup_err = true, nil
			end
			if not cleanup_ok then
				self.logger:log(
					ERR,
					"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
				)
			end
		end

		return self:ret(
			true,
			"malware detected by ClamAV (" .. detected .. ") and VirusTotal (" .. vt_detected .. ")",
			get_deny_status(),
			nil,
			{
				id = "malware_detected_both",
				file = body_file,
				clamav_signature = detected,
				virustotal_detection = vt_detected,
				scanner = "ClamAV+VirusTotal"
			}
		)
	elseif detected and detected ~= "clean" then
		-- ClamAV detected but VirusTotal said clean (rare case)
		self.logger:log(ERR, "MALWARE DETECTED BY CLAMAV ONLY - BLOCKING REQUEST")
		self.logger:log(ERR, "ClamAV: " .. self:sanitize_external_data(detected) .. ", VirusTotal: clean")
		if detected and detected ~= "clean" then
			detections["ClamAV"] = detected
		end


		-- Send webhook notification with all detections
		if checksum and next(detections) ~= nil then
			if webhook then
				local ok, err = pcall(webhook.send_notification, self, checksum, detections)
				if not ok then
					self.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
				end
			else
				self.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
			end
		end

		local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
		if cleanup_enabled ~= "no" then
			local cleanup_ok, cleanup_err
			if file_ops then
				cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
			else
				cleanup_ok, cleanup_err = true, nil
			end
			if not cleanup_ok then
				self.logger:log(
					ERR,
					"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
				)
			end
		end

		return self:ret(
			true,
			"malware detected by ClamAV (" .. detected .. "), VirusTotal reported clean",
			get_deny_status(),
			nil,
			{
				id = "malware_detected_clamav_only",
				file = body_file,
				signature = detected,
				scanner = "ClamAV"
			}
		)
	end

	-- ============================================================================
	-- MULTIPART FULL SCAN: PER-FILE SCANNING
	-- ============================================================================
	-- If we reach here, whole-body scan is complete (either clean or resume mode).
	-- When resume mode is enabled OR full body scan was skipped, parse multipart upload and scan each file individually.

	if (resume_on_hit or skip_full_body_scan) and multipart_full_scan_load_ok and multipart_full_scan then
		-- Build enabled scanners table for multipart full scan module
		-- Use saved states (before body scan disable) for individual file scanning
		local enabled_scanners = {
			clamav = skip_full_body_scan and clamav_enabled_for_files or (clamav_enabled or clamav_actually_scanned),
			virustotal = skip_full_body_scan and virustotal_enabled_for_files or virustotal_enabled,
			threatfox = skip_full_body_scan and threatfox_enabled_for_files or threatfox_enabled,
			sentinelone = skip_full_body_scan and sentinelone_enabled_for_files or sentinelone_enabled
		}

		-- Call multipart full scan module (parses multipart and scans each file)
		local success, message, status, data = multipart_full_scan.scan_multipart_files(
			self,
			body_file,
			checksum,
			detections,
			enabled_scanners
		)

		-- If per-file scanning found malware, block immediately
		if not success then
			-- Cleanup body file before blocking
			local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
			if cleanup_enabled ~= "no" and file_ops then
				local cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
				if not cleanup_ok then
					self.logger:log(ERR, "failed to cleanup temp file after multipart scan: " .. cleanup_err)
				end
			end
			return self:ret(true, message, status, nil, data)
		end
	elseif (resume_on_hit or skip_full_body_scan) and not multipart_full_scan_load_ok then
		self.logger:log(ERR, "[MULTIPART_FULL_SCAN] Resume mode or multipart extraction enabled but multipart_full_scan module failed to load: " .. tostring(multipart_full_scan_load_err))
	end
	-- ============================================================================

	-- Build success message based on what was scanned
	local scan_message
	local active_scanners = {}
	if clamav_actually_scanned then table.insert(active_scanners, "ClamAV") end
	if virustotal_enabled then table.insert(active_scanners, "VirusTotal") end
	if threatfox_enabled then table.insert(active_scanners, "ThreatFox") end
	if sentinelone_enabled then table.insert(active_scanners, "SentinelOne") end

	if #active_scanners > 0 then
		local scanners_str = table.concat(active_scanners, " + ")
		scan_message = "file scanned by " .. scanners_str .. ", no malware detected"
		if clamav_skipped_reason then
			scan_message = scan_message .. " (ClamAV skipped: " .. clamav_skipped_reason .. ")"
		end
		self.logger:log(ERR, "SCAN COMPLETE - file is clean (" .. scanners_str .. ")")
		if clamav_skipped_reason then
			self.logger:log(ERR, "Note: ClamAV scan was skipped - " .. clamav_skipped_reason)
		end
	else
		scan_message = "no scanning performed"
	end

	-- Cleanup body file if resume mode was enabled (file preserved for multipart scanning)
	if resume_on_hit then
		local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
		if cleanup_enabled ~= "no" and file_ops then
			local cleanup_ok, cleanup_err = file_ops.cleanup_file(self, body_file)
			if not cleanup_ok then
				self.logger:log(ERR, "failed to cleanup temp file after successful scan: " .. cleanup_err)
			else
				self:log_debug("[RESUME_MODE] Cleaned up body file after multipart scanning")
			end
		end
	end

	return self:ret(true, scan_message)
end

-- Send command to ClamAV and receive response.
-- Returns success boolean and response data or error message.
function malware_scan:api()
	-- ClamAV connectivity test
	if self.ctx.bw.uri == "/malware-scan/ping" and self.ctx.bw.request_method == "POST" then
		local check, err = has_variable("MALWARE_SCAN_ENABLED", "yes")
		if check == nil then
			return self:ret(true, "error while checking variable MALWARE_SCAN_ENABLED (" .. err .. ")")
		end
		if not check then
			return self:ret(true, "Malware scan plugin not enabled")
		end

		local ok, data = self:command("PING")
		if not ok then
			return self:ret(true, "connectivity with ClamAV failed : " .. data, HTTP_INTERNAL_SERVER_ERROR)
		end
		if data ~= "PONG" then
			return self:ret(true, "wrong data received from ClamAV : " .. data, HTTP_INTERNAL_SERVER_ERROR)
		end
		return self:ret(true, "connectivity with ClamAV is successful", HTTP_OK)
	end

	-- ClamAV EICAR test
	if self.ctx.bw.uri == "/malware-scan/test-eicar" and self.ctx.bw.request_method == "POST" then
		local check, err = has_variable("MALWARE_SCAN_ENABLED", "yes")
		if check == nil then
			return self:ret(true, "error while checking variable MALWARE_SCAN_ENABLED (" .. err .. ")")
		end
		if not check then
			return self:ret(true, "Malware scan plugin not enabled")
		end

		-- EICAR test virus string
		local eicar = "X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"

		self.logger:log(ERR, "Testing ClamAV with EICAR test file")
		local ok, detected = self:scan_content_instream(eicar)

		if not ok then
			return self:ret(
				true,
				"ClamAV scan failed: " .. detected,
				HTTP_INTERNAL_SERVER_ERROR
			)
		end

		if detected == "clean" then
			return self:ret(
				true,
				"WARNING: ClamAV did not detect EICAR test file (expected: Eicar-Signature, got: clean)",
				HTTP_INTERNAL_SERVER_ERROR
			)
		end

		-- Successfully detected EICAR
		return self:ret(
			true,
			"ClamAV successfully detected EICAR test file: " .. detected,
			HTTP_OK
		)
	end

	-- VirusTotal connectivity test
	if self.ctx.bw.uri == "/malware-scan/virustotal-ping" and self.ctx.bw.request_method == "POST" then
		local check, err = has_variable("MALWARE_SCAN_ENABLED", "yes")
		if check == nil then
			return self:ret(true, "error while checking variable MALWARE_SCAN_ENABLED (" .. err .. ")")
		end
		if not check then
			return self:ret(true, "Malware scan plugin not enabled")
		end

		if self.variables["MALWARE_SCAN_API_USE_VIRUSTOTAL"] ~= "yes" then
			return self:ret(true, "VirusTotal integration not enabled", HTTP_INTERNAL_SERVER_ERROR)
		end

		if not self.variables["MALWARE_SCAN_API_VIRUSTOTAL_KEY"]
			or self.variables["MALWARE_SCAN_API_VIRUSTOTAL_KEY"] == "" then
			return self:ret(true, "VirusTotal API key not configured", HTTP_INTERNAL_SERVER_ERROR)
		end

		-- Test with EICAR test file SHA256 checksum
		local ok, found, response = self:virustotal_request(
			"/files/275a021bbfb6489e54d471899f7db9d1663fc695ec2fe2a2c4538aabf651fd0f"
		)
		if not ok then
			return self:ret(
				true,
				"error while connecting to VirusTotal API: " .. found,
				HTTP_INTERNAL_SERVER_ERROR
			)
		end
		if not found then
			return self:ret(
				true,
				"error while testing VirusTotal: EICAR test file not found on VirusTotal",
				HTTP_INTERNAL_SERVER_ERROR
			)
		end
		return self:ret(
			true,
			"connectivity with VirusTotal is successful, response: " .. encode(response),
			HTTP_OK
		)
	end

	return self:ret(false, "success")
end

return malware_scan
