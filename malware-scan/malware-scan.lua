local class = require("middleclass")
local plugin = require("bunkerweb.plugin")
local utils = require("bunkerweb.utils")
local cjson = require("cjson")
local http = require("resty.http")
local sha256 = require("resty.sha256")
local str = require("resty.string")
local webhook = require("malware-scan_webhook")

local malware_scan = class("malware-scan", plugin)

local ngx = ngx
local NOTICE = ngx.NOTICE
local ERR = ngx.ERR
local WARN = ngx.WARN
local socket = ngx.socket
local HTTP_INTERNAL_SERVER_ERROR = ngx.HTTP_INTERNAL_SERVER_ERROR
local HTTP_OK = ngx.HTTP_OK
local has_variable = utils.has_variable
local get_deny_status = utils.get_deny_status
local tonumber = tonumber
local tostring = tostring
local decode = cjson.decode
local encode = cjson.encode
local to_hex = str.to_hex
local http_new = http.new

-- Plugin version for User-Agent identification
local VERSION = "0.2.0"
local USER_AGENT = "bunkerweb - https://github.com/bunkerity/bunkerweb - malware-scan module v" .. VERSION

-- Initialize plugin instance with context.
function malware_scan:initialize(ctx)
	plugin.initialize(self, "malware-scan", ctx)
end

-- Helper function to check if debug mode is enabled.
-- Returns true if MALWARE_SCAN_DEBUG=yes, false otherwise.
function malware_scan:is_debug()
	return self.variables["MALWARE_SCAN_DEBUG"] == "yes"
end

-- Log a message only if debug mode is enabled.
-- Uses ERR level to ensure debug logs appear in output.
function malware_scan:log_debug(message)
	if self:is_debug() then
		self.logger:log(ERR, "[DEBUG] " .. message)
	end
end

-- Check if a file should be excluded from scanning based on its extension.
-- Returns true if file should be skipped, false if it should be scanned.
function malware_scan:is_file_excluded(file_path)
	-- Get excluded extensions setting
	local excluded_exts = self.variables["MALWARE_SCAN_EXCLUDED_EXTENSIONS"]
	if not excluded_exts or excluded_exts == "" then
		return false  -- No exclusions, scan everything
	end

	-- Extract file extension from path
	local ext = file_path:match("%.([^%.]+)$")
	if not ext then
		return false  -- No extension, scan it
	end

	-- Normalize to lowercase
	ext = ext:lower()

	-- Split excluded extensions and check if this one matches
	for excluded_ext in excluded_exts:gmatch("[^,]+") do
		excluded_ext = excluded_ext:gsub("^%s*(.-)%s*$", "%1")  -- trim whitespace
		if ext == excluded_ext:lower() then
			return true  -- File is excluded
		end
	end

	return false  -- Not excluded, should scan
end

-- Get file size in bytes.
-- Returns file size or nil if unable to determine.
function malware_scan:get_file_size(file_path)
	local file, err = io.open(file_path, "rb")
	if not file then
		self.logger:log(ERR, "failed to open file for size check: " .. (err or "unknown"))
		return nil
	end

	local size = file:seek("end")
	file:close()

	return size
end

-- Extract original filename from multipart upload file.
-- Reads the first few KB of the file to find the Content-Disposition header.
-- Returns filename or nil if not found.
function malware_scan:extract_filename_from_upload(file_path)
	local file, err = io.open(file_path, "rb")
	if not file then
		self:log_debug("Could not open file to extract filename: " .. tostring(err))
		return nil
	end

	-- Read first 4KB (should contain headers)
	local header_data = file:read(4096)
	file:close()

	if not header_data then
		return nil
	end

	-- Look for Content-Disposition header with filename
	-- Format: Content-Disposition: form-data; name="file"; filename="example.jpg"
	local filename = header_data:match('filename="([^"]+)"')
	if not filename then
		-- Try alternative format without quotes
		filename = header_data:match("filename=([^%s;]+)")
	end

	return filename
end

-- Initialize worker and test ClamAV connectivity.
-- Optionally clean up orphaned temporary files.
function malware_scan:init_worker()
	local init_needed, err = has_variable("MALWARE_SCAN_ENABLED", "yes")
	if init_needed == nil then
		return self:ret(false, "can't check MALWARE_SCAN_ENABLED variable : " .. err)
	end
	if not init_needed or self.is_loading then
		return self:ret(true, "init_worker not needed")
	end
	
	local ok, data = self:command("PING")
	if not ok then
		return self:ret(false, "connectivity with ClamAV failed : " .. data)
	end
	if data ~= "PONG" then
		return self:ret(false, "wrong data received from ClamAV : " .. data)
	end
	
	self.logger:log(
		NOTICE,
		"connectivity with "
			.. self.variables["MALWARE_SCAN_CLAMAV_HOST"]
			.. ":"
			.. self.variables["MALWARE_SCAN_CLAMAV_PORT"]
			.. " is successful"
	)
	
	if self.variables["MALWARE_SCAN_CLEANUP_ORPHANED"] == "yes" then
		local cleanup_age = tonumber(self.variables["MALWARE_SCAN_CLEANUP_AGE"]) or 3600
		local cleanup_ok, cleanup_err = self:cleanup_orphaned_files(cleanup_age)
		if not cleanup_ok then
			self.logger:log(
				WARN,
				"failed to cleanup orphaned files: " .. cleanup_err
			)
		end
	end
	
	return self:ret(true, "success")
end

-- Access phase handler - scan uploaded files for malware.
-- Checks for file uploads, scans with ClamAV and/or VirusTotal, and blocks infected files.
function malware_scan:access()
	self:log_debug("=== MALWARE-SCAN ACCESS PHASE CALLED ===")
	self:log_debug("Request: " .. tostring(self.ctx.bw.uri) .. " Method: " .. tostring(self.ctx.bw.request_method))

	-- Check if any scanning service is enabled
	local clamav_enabled = self.variables["MALWARE_SCAN_ENABLED"] == "yes"
	local virustotal_enabled = self.variables["MALWARE_SCAN_USE_VIRUSTOTAL"] == "yes"
	local threatfox_enabled = self.variables["MALWARE_SCAN_USE_THREATFOX"] == "yes"
	local sentinelone_enabled = self.variables["MALWARE_SCAN_USE_SENTINELONE"] == "yes"

	if not clamav_enabled and not virustotal_enabled and not threatfox_enabled and not sentinelone_enabled then
		self.logger:log(ERR, "MALWARE SCANNING NOT ENABLED - all scanners disabled")
		return self:ret(true, "malware scanning not enabled")
	end

	-- Build scanner list message
	local scanners = {}
	if clamav_enabled then table.insert(scanners, "ClamAV") end
	if virustotal_enabled then table.insert(scanners, "VirusTotal") end
	if threatfox_enabled then table.insert(scanners, "ThreatFox") end
	if sentinelone_enabled then table.insert(scanners, "SentinelOne") end

	if #scanners > 1 then
		self.logger:log(ERR, "Multi-layer scanning enabled (" .. table.concat(scanners, " + ") .. ")")
	else
		self.logger:log(ERR, scanners[1] .. "-only scanning enabled")
	end

	self:log_debug("Plugin ENABLED, checking for file upload")
	self:log_debug("Content-Type: " .. tostring(self.ctx.bw.http_content_type))

	if
		not self.ctx.bw.http_content_type
		or (
			not self.ctx.bw.http_content_type:match("boundary")
			or not self.ctx.bw.http_content_type:match("multipart/form%-data")
		)
	then
		return self:ret(true, "no file upload detected")
	end

	self.logger:log(ERR, "file upload detected, scanning for malware")

	ngx.req.read_body()

	local body_file = ngx.req.get_body_file()

	self:log_debug("body_file = " .. tostring(body_file))

	if not body_file then
		self.logger:log(
			ERR,
			"upload body in memory, not in file - increase client_body_buffer_size " ..
			"or decrease it to force file buffering for virus scanning"
		)

		if self.variables["MALWARE_SCAN_BLOCK_MEMORY_UPLOADS"] == "yes" then
			self.logger:log(ERR, "BLOCKING UPLOAD - cannot scan files in memory (need file buffering)")
			return self:ret(
				true,
				"upload in memory blocked - cannot scan (increase client_body_buffer_size)",
				get_deny_status(),
				nil,
				{
					id = "unscannable_memory",
					reason = "body in memory, not file"
				}
			)
		else
			return self:ret(true, "upload in memory, skipping scan (WARNING)")
		end
	end

	-- Check if file extension is excluded from scanning
	-- Try to get original filename from the temp file or request
	-- The body_file is just a temp path, so we'll read the first part of the file
	-- to extract the Content-Disposition header with the original filename
	local original_filename = self:extract_filename_from_upload(body_file)
	if original_filename then
		self:log_debug("Original filename: " .. original_filename)
		if self:is_file_excluded(original_filename) then
			local ext = original_filename:match("%.([^%.]+)$")
			self.logger:log(ERR, "skipping scan for excluded file type: " .. (ext or "unknown") .. " (" .. original_filename .. ")")
			return self:ret(true, "file type excluded from scanning")
		end
	end

	-- OPTIMIZATION: Check hash-based caches BEFORE ClamAV to avoid wasting resources
	-- If we already know the file is malicious from cache, skip ClamAV scan entirely
	local checksum, checksum_ok
	local clamav_can_skip = false
	if virustotal_enabled or threatfox_enabled or sentinelone_enabled then
		-- Check file size before calculating SHA256 to avoid performance issues with large files
		local file_size = self:get_file_size(body_file)
		local hash_max_size = tonumber(self.variables["MALWARE_SCAN_HASH_MAX_SIZE"]) or 67108864  -- default 64MB

		if file_size and file_size > hash_max_size then
			self.logger:log(ERR, "[SIZE_LIMIT] File size " .. file_size .. " bytes exceeds hash scan limit " .. hash_max_size .. " bytes - skipping SHA256 calculation and hash-based scanners")
			-- Don't calculate hash or check caches for large files
			-- ClamAV will still scan if enabled and within ClamAV limits
			checksum_ok = false
			checksum = nil
		else
			self.logger:log(ERR, "[CACHE_CHECK] Checking hash-based caches before ClamAV scan")
			checksum_ok, checksum = self:calculate_sha256(body_file)
			if checksum_ok and checksum ~= "empty_file" then
				self.logger:log(ERR, "file SHA256: " .. checksum)

				-- Check ThreatFox cache
				if threatfox_enabled then
					local tf_cache_ok, tf_cached = self:is_in_threatfox_cache(checksum)
					if tf_cache_ok and tf_cached and tf_cached ~= "clean" then
						self.logger:log(ERR, "[CACHE_HIT] ThreatFox cache shows malicious - skipping ClamAV scan")
						self.logger:log(ERR, "MALWARE DETECTED BY THREATFOX (cached)")
						self.logger:log(ERR, "ThreatFox detection: " .. tf_cached .. " (SHA256: " .. checksum .. ")")

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
						-- Send Teams webhook notification
						webhook.send_notification(self, checksum, {["ThreatFox (cached)"] = tf_cached})

=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
						local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
						if cleanup_enabled ~= "no" then
							local cleanup_ok, cleanup_err = self:cleanup_file(body_file)
							if not cleanup_ok then
								self.logger:log(ERR, "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
							end
						end

						return self:ret(
							true,
							"malware detected by ThreatFox cache (SHA256: " .. checksum .. "): " .. tf_cached,
							get_deny_status(),
							nil,
							{
								id = "malware_detected_threatfox_cache",
								file = body_file,
								checksum = checksum,
								detection = tf_cached,
								scanner = "ThreatFox (cached)"
							}
						)
					end
				end

				-- Check VirusTotal cache
				if virustotal_enabled then
					local vt_cache_ok, vt_cached = self:is_in_vt_cache(checksum)
					if vt_cache_ok and vt_cached and vt_cached ~= "clean" then
						self.logger:log(ERR, "[CACHE_HIT] VirusTotal cache shows malicious - skipping ClamAV scan")
						self.logger:log(ERR, "MALWARE DETECTED BY VIRUSTOTAL (cached)")
						self.logger:log(ERR, "VirusTotal detection: " .. vt_cached .. " (SHA256: " .. checksum .. ")")

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
						-- Send Teams webhook notification
						webhook.send_notification(self, checksum, {["VirusTotal (cached)"] = vt_cached})

=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
						local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
						if cleanup_enabled ~= "no" then
							local cleanup_ok, cleanup_err = self:cleanup_file(body_file)
							if not cleanup_ok then
								self.logger:log(ERR, "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
							end
						end

						return self:ret(
							true,
							"malware detected by VirusTotal cache (SHA256: " .. checksum .. "): " .. vt_cached,
							get_deny_status(),
							nil,
							{
								id = "malware_detected_virustotal_cache",
								file = body_file,
								checksum = checksum,
								detection = vt_cached,
								scanner = "VirusTotal (cached)"
							}
						)
					end
				end

				-- Check SentinelOne cache
				if sentinelone_enabled then
					local s1_cache_ok, s1_cached = self:is_in_sentinelone_cache(checksum)
					if s1_cache_ok and s1_cached and s1_cached ~= "clean" then
						self.logger:log(ERR, "[CACHE_HIT] SentinelOne cache shows malicious - skipping ClamAV scan")
						self.logger:log(ERR, "MALWARE DETECTED BY SENTINELONE (cached)")
						self.logger:log(ERR, "SentinelOne detection: " .. s1_cached .. " (SHA256: " .. checksum .. ")")

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
						-- Send Teams webhook notification
						webhook.send_notification(self, checksum, {["SentinelOne (cached)"] = s1_cached})

=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
						local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
						if cleanup_enabled ~= "no" then
							local cleanup_ok, cleanup_err = self:cleanup_file(body_file)
							if not cleanup_ok then
								self.logger:log(ERR, "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
							end
						end

						return self:ret(
							true,
							"malware detected by SentinelOne cache (SHA256: " .. checksum .. "): " .. s1_cached,
							get_deny_status(),
							nil,
							{
								id = "malware_detected_sentinelone_cache",
								file = body_file,
								checksum = checksum,
								detection = s1_cached,
								scanner = "SentinelOne (cached)"
							}
						)
					end
				end

				self.logger:log(ERR, "[CACHE_MISS] No malicious results in caches - continuing with ClamAV scan")
			end
		end  -- end of file size check for hash scanning
	end

	-- Check file size for ClamAV scan limit
	local clamav_skipped_reason = nil
	local clamav_actually_scanned = false
	if clamav_enabled then
		local file_size = self:get_file_size(body_file)
		if file_size then
			local max_size = tonumber(self.variables["MALWARE_SCAN_CLAMAV_MAX_SIZE"]) or 26214400
			if file_size > max_size then
				self.logger:log(
					ERR,
					"file too large for ClamAV INSTREAM scan: " .. file_size .. " bytes (max: " .. max_size .. " bytes), skipping ClamAV scan"
				)
				clamav_skipped_reason = "file too large (" .. file_size .. " bytes)"
				clamav_enabled = false  -- Skip ClamAV scan, continue with hash-based scanners
			end
		end
	end

	-- Scan with ClamAV if enabled and file size is acceptable
	local detected = "clean"
	if clamav_enabled then
		clamav_actually_scanned = true
		self:log_debug("Calling scan_file() with: " .. body_file)

		local ok
		ok, detected = self:scan_file(body_file)

		self:log_debug("scan_file returned - ok: " .. tostring(ok) .. ", detected: " .. tostring(detected))

		if not ok then
			-- Check if the error is due to file size limit
			if detected and detected:match("size limit") then
				self.logger:log(ERR, "ClamAV scan failed due to size limit: " .. detected)
				clamav_skipped_reason = "size limit exceeded"
				clamav_actually_scanned = false
			else
				self.logger:log(ERR, "ClamAV scan failed: " .. detected)
			end
			-- Don't fail the request, continue to hash-based scanners if enabled
			detected = "clean"
		elseif detected and detected ~= "clean" then
			-- ClamAV detected malware
			self.logger:log(ERR, "MALWARE DETECTED BY CLAMAV")
			self.logger:log(ERR, "ClamAV signature: " .. detected .. " in file: " .. body_file)

			-- Check if we should skip cloud scanners and block immediately
			local skip_others = self.variables["MALWARE_SCAN_SKIP_OTHERS_ON_CLAMAV_DETECT"]
			local any_cloud_enabled = virustotal_enabled or threatfox_enabled or sentinelone_enabled
			if skip_others == "yes" or not any_cloud_enabled then
				-- Block immediately (default behavior)
				self.logger:log(ERR, "BLOCKING REQUEST - skipping cloud scanner checks (faster response)")

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
				-- Send Teams webhook notification
				webhook.send_notification(self, checksum, {["ClamAV"] = detected})

=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
				local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
				if cleanup_enabled ~= "no" then
					local cleanup_ok, cleanup_err = self:cleanup_file(body_file)
					if not cleanup_ok then
						self.logger:log(
							ERR,
							"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
						)
					end
				end

				local deny_status = get_deny_status()
				self:log_debug("Returning block status: " .. tostring(deny_status))

				return self:ret(
					true,
					"malware detected by ClamAV in file " .. body_file .. ": " .. detected,
					deny_status,
					nil,
					{
						id = "malware_detected_clamav",
						file = body_file,
						signature = detected,
						scanner = "ClamAV"
					}
				)
			else
				-- Continue to VirusTotal for additional analysis
				self.logger:log(ERR, "ClamAV detected malware, continuing to VirusTotal for additional analysis")
				-- Keep detected value, will be used in final decision
			end
		else
			self.logger:log(ERR, "ClamAV scan: file is clean")
		end
	else
		self.logger:log(ERR, "ClamAV scanning disabled, skipping to VirusTotal")
	end

	-- Check hash-based scanners if enabled (calculate SHA256 for hash-based checks if not already done)
	local vt_detected = "clean"
	if virustotal_enabled or threatfox_enabled or sentinelone_enabled then
		-- Reuse checksum from early cache check if available, otherwise calculate now
		if not checksum_ok or not checksum then
			-- Check file size before calculating SHA256
			local file_size = self:get_file_size(body_file)
			local hash_max_size = tonumber(self.variables["MALWARE_SCAN_HASH_MAX_SIZE"]) or 67108864  -- default 64MB

			if file_size and file_size > hash_max_size then
				self.logger:log(ERR, "[SIZE_LIMIT] File size " .. file_size .. " bytes exceeds hash scan limit " .. hash_max_size .. " bytes - skipping hash-based scanners")
				checksum_ok = false
				checksum = nil
			else
				self.logger:log(ERR, "Hash-based scanning enabled, calculating SHA256 checksum")
				checksum_ok, checksum = self:calculate_sha256(body_file)
			end
		else
			self.logger:log(ERR, "Hash-based scanning enabled, reusing previously calculated SHA256")
		end
		if checksum_ok then
			self.logger:log(ERR, "file SHA256: " .. checksum)

			-- Check if file is empty (0 bytes)
			if checksum == "empty_file" then
				self.logger:log(ERR, "file is 0 bytes, skipping hash-based checks")
				vt_detected = "clean"
			else
				-- Check ThreatFox first (faster, free API, preserves VT quota)
				if threatfox_enabled then
					self.logger:log(ERR, "checking file against ThreatFox API")
					local tf_ok, tf_result = self:check_threatfox(checksum)
					if tf_ok then
						local threatfox_detected = tf_result
						if threatfox_detected ~= "clean" then
							self.logger:log(ERR, "MALWARE DETECTED BY THREATFOX - BLOCKING REQUEST")
							self.logger:log(ERR, "ThreatFox detection: " .. threatfox_detected .. " (SHA256: " .. checksum .. ")")

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
							-- Send Teams webhook notification
							webhook.send_notification(self, checksum, {["ThreatFox"] = threatfox_detected})

=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
							-- Share file with threat intelligence platforms if enabled
							local share_ok, share_err = self:share_detected_file(body_file, checksum, "ThreatFox")
							if not share_ok then
								self.logger:log(ERR, "[SHARE] Failed to share file: " .. share_err)
							end

							local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
							if cleanup_enabled ~= "no" then
								local cleanup_ok, cleanup_err = self:cleanup_file(body_file)
								if not cleanup_ok then
									self.logger:log(
										ERR,
										"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
									)
								end
							end

							return self:ret(
								true,
								"malware detected by ThreatFox (SHA256: " .. checksum .. "): " .. threatfox_detected,
								get_deny_status(),
								nil,
								{
									id = "malware_detected_threatfox",
									file = body_file,
									checksum = checksum,
									detection = threatfox_detected,
									scanner = "ThreatFox"
								}
							)
						else
							self.logger:log(ERR, "ThreatFox scan: file is clean")
						end
					else
						self.logger:log(ERR, "ThreatFox check failed: " .. tf_result)
					end
				end

				-- Check VirusTotal if enabled (after ThreatFox to preserve API quota)
				if virustotal_enabled then
					self.logger:log(ERR, "checking file against VirusTotal API")
				local vt_ok, vt_result, vt_found = self:check_virustotal(body_file, checksum)
				if vt_ok then
					vt_detected = vt_result

					-- Check if we should upload unknown malware to VT
					if not vt_found and detected and detected ~= "clean" then
						-- ClamAV detected malware, but VT doesn't have the file
						if self.variables["MALWARE_SCAN_VT_UPLOAD_UNKNOWN"] == "yes" then
							self.logger:log(ERR, "ClamAV detected malware but VT doesn't have file, uploading to VirusTotal")
							local upload_ok, analysis_id, file_size = self:virustotal_upload_file(body_file)
							if upload_ok then
								self.logger:log(ERR, "file uploaded successfully (" .. file_size .. " bytes), analysis ID: " .. tostring(analysis_id))

								-- Check if we should auto-vote
								if self.variables["MALWARE_SCAN_VT_AUTO_VOTE"] == "yes" then
									self.logger:log(ERR, "auto-voting file as malicious on VirusTotal")
									local vote_ok, vote_err = self:virustotal_vote(checksum, "malicious")
									if vote_ok then
										self.logger:log(ERR, "malicious vote submitted successfully")
									else
										self.logger:log(ERR, "failed to submit vote: " .. vote_err)
									end
								end
							else
								self.logger:log(ERR, "failed to upload file to VirusTotal: " .. analysis_id)
							end
						else
							self.logger:log(ERR, "ClamAV detected malware but VT doesn't have file (upload disabled)")
						end
					end

					if vt_detected ~= "clean" then
						self.logger:log(ERR, "MALWARE DETECTED BY VIRUSTOTAL - BLOCKING REQUEST")
						self.logger:log(ERR, "VirusTotal detection: " .. vt_detected .. " (SHA256: " .. checksum .. ")")
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD

						-- Send Teams webhook notification
						webhook.send_notification(self, checksum, {["VirusTotal"] = vt_detected})

=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
						local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
						if cleanup_enabled ~= "no" then
							local cleanup_ok, cleanup_err = self:cleanup_file(body_file)
							if not cleanup_ok then
								self.logger:log(
									ERR,
									"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
								)
							end
						end

						return self:ret(
							true,
							"malware detected by VirusTotal (SHA256: " .. checksum .. "): " .. vt_detected,
							get_deny_status(),
							nil,
							{
								id = "malware_detected_virustotal",
								file = body_file,
								checksum = checksum,
								detection = vt_detected,
								scanner = "VirusTotal"
							}
						)
					else
						self.logger:log(ERR, "VirusTotal scan: file is clean")
					end
				else
					self.logger:log(ERR, "VirusTotal check failed: " .. vt_result)
				end
				end

				-- Check SentinelOne if enabled (uses same checksum)
				if sentinelone_enabled then
					self.logger:log(ERR, "checking file against SentinelOne API")
					local s1_ok, s1_result = self:check_sentinelone(checksum)
					if s1_ok then
						local sentinelone_detected = s1_result
						if sentinelone_detected ~= "clean" then
							self.logger:log(ERR, "MALWARE DETECTED BY SENTINELONE - BLOCKING REQUEST")
							self.logger:log(ERR, "SentinelOne detection: " .. sentinelone_detected .. " (SHA256: " .. checksum .. ")")

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
							-- Send Teams webhook notification
							webhook.send_notification(self, checksum, {["SentinelOne"] = sentinelone_detected})

=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
							-- Share file with threat intelligence platforms if enabled
							local share_ok, share_err = self:share_detected_file(body_file, checksum, "SentinelOne")
							if not share_ok then
								self.logger:log(ERR, "[SHARE] Failed to share file: " .. share_err)
							end

							local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
							if cleanup_enabled ~= "no" then
								local cleanup_ok, cleanup_err = self:cleanup_file(body_file)
								if not cleanup_ok then
									self.logger:log(
										ERR,
										"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
									)
								end
							end

							return self:ret(
								true,
								"malware detected by SentinelOne (SHA256: " .. checksum .. "): " .. sentinelone_detected,
								get_deny_status(),
								nil,
								{
									id = "malware_detected_sentinelone",
									file = body_file,
									checksum = checksum,
									detection = sentinelone_detected,
									scanner = "SentinelOne"
								}
							)
						else
							self.logger:log(ERR, "SentinelOne scan: file is clean")
						end
					else
						self.logger:log(ERR, "SentinelOne check failed: " .. s1_result)
					end
				end
			end
		else
			self.logger:log(ERR, "failed to calculate SHA256: " .. checksum)
		end
	end

	-- Clean up temp file after all scans complete
	local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
	if cleanup_enabled ~= "no" then
		local cleanup_ok, cleanup_err = self:cleanup_file(body_file)
		if not cleanup_ok then
			self.logger:log(
				ERR,
				"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
			)
		end
	end

	-- If we reach here, check if ClamAV detected but we continued to VT
	if detected and detected ~= "clean" and vt_detected and vt_detected ~= "clean" then
		-- Both ClamAV and VirusTotal detected malware
		self.logger:log(ERR, "MALWARE DETECTED BY BOTH CLAMAV AND VIRUSTOTAL - BLOCKING REQUEST")
		self.logger:log(ERR, "ClamAV: " .. detected .. ", VirusTotal: " .. vt_detected)

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
		-- Send Teams webhook notification
		webhook.send_notification(self, checksum, {["ClamAV"] = detected, ["VirusTotal"] = vt_detected})

=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
		local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
		if cleanup_enabled ~= "no" then
			local cleanup_ok, cleanup_err = self:cleanup_file(body_file)
			if not cleanup_ok then
				self.logger:log(
					ERR,
					"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
				)
			end
		end

		return self:ret(
			true,
			"malware detected by ClamAV (" .. detected .. ") and VirusTotal (" .. vt_detected .. ")",
			get_deny_status(),
			nil,
			{
				id = "malware_detected_both",
				file = body_file,
				clamav_signature = detected,
				virustotal_detection = vt_detected,
				scanner = "ClamAV+VirusTotal"
			}
		)
	elseif detected and detected ~= "clean" then
		-- ClamAV detected but VirusTotal said clean (rare case)
		self.logger:log(ERR, "MALWARE DETECTED BY CLAMAV ONLY - BLOCKING REQUEST")
		self.logger:log(ERR, "ClamAV: " .. detected .. ", VirusTotal: clean")

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
		-- Send Teams webhook notification
		webhook.send_notification(self, checksum, {["ClamAV"] = detected})

=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
=======
>>>>>>> parent of 36bf82d (add MS Teams webhook)
		local cleanup_enabled = self.variables["MALWARE_SCAN_CLEANUP_FILES"]
		if cleanup_enabled ~= "no" then
			local cleanup_ok, cleanup_err = self:cleanup_file(body_file)
			if not cleanup_ok then
				self.logger:log(
					ERR,
					"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
				)
			end
		end

		return self:ret(
			true,
			"malware detected by ClamAV (" .. detected .. "), VirusTotal reported clean",
			get_deny_status(),
			nil,
			{
				id = "malware_detected_clamav_only",
				file = body_file,
				signature = detected,
				scanner = "ClamAV"
			}
		)
	end

	-- Build success message based on what was scanned
	local scan_message
	local active_scanners = {}
	if clamav_actually_scanned then table.insert(active_scanners, "ClamAV") end
	if virustotal_enabled then table.insert(active_scanners, "VirusTotal") end
	if threatfox_enabled then table.insert(active_scanners, "ThreatFox") end
	if sentinelone_enabled then table.insert(active_scanners, "SentinelOne") end

	if #active_scanners > 0 then
		local scanners_str = table.concat(active_scanners, " + ")
		scan_message = "file scanned by " .. scanners_str .. ", no malware detected"
		if clamav_skipped_reason then
			scan_message = scan_message .. " (ClamAV skipped: " .. clamav_skipped_reason .. ")"
		end
		self.logger:log(ERR, "SCAN COMPLETE - file is clean (" .. scanners_str .. ")")
		if clamav_skipped_reason then
			self.logger:log(ERR, "Note: ClamAV scan was skipped - " .. clamav_skipped_reason)
		end
	else
		scan_message = "no scanning performed"
	end

	return self:ret(true, scan_message)
end

-- Send command to ClamAV and receive response.
-- Returns success boolean and response data or error message.
function malware_scan:command(cmd)
	local clamav_socket, err = self:socket()
	if not clamav_socket then
		return false, err
	end
	
	local bytes
	bytes, err = clamav_socket:send("n" .. cmd .. "\n")
	if not bytes then
		clamav_socket:close()
		return false, err
	end
	
	local data
	data, err = clamav_socket:receive("*l")
	if not data then
		clamav_socket:close()
		return false, err
	end
	
	clamav_socket:close()
	return true, data
end

-- Create TCP socket connection to ClamAV.
-- Returns socket object or false and error message.
function malware_scan:socket()
	local tcp_socket = socket.tcp()
	tcp_socket:settimeout(tonumber(self.variables["MALWARE_SCAN_CLAMAV_TIMEOUT"]))
	local ok, err = tcp_socket:connect(
		self.variables["MALWARE_SCAN_CLAMAV_HOST"], 
		tonumber(self.variables["MALWARE_SCAN_CLAMAV_PORT"])
	)
	if not ok then
		return false, err
	end
	return tcp_socket
end

-- Scan a file using ClamAV's INSTREAM command (always uses clamav-daemon).
-- Takes file path, returns success boolean and detection result or error.
function malware_scan:scan_file(file_path)
	-- Always use INSTREAM method (bypasses file permissions)
	return self:scan_file_instream(file_path)
end

-- Scan a file using ClamAV's INSTREAM command (stream content over socket).
-- This bypasses file permission issues by reading the file and sending it to ClamAV.
-- Takes file path, returns success boolean and detection result or error.
function malware_scan:scan_file_instream(file_path)
	self:log_debug("=== INSTREAM: scan_file_instream() called for: " .. file_path .. " ===")

	local ok, cached = self:is_in_cache(file_path)
	if ok and cached then
		self:log_debug("file found in cache: " .. cached)
		return true, cached
	end

	self.logger:log(ERR, "scanning file via INSTREAM: " .. file_path)
	self:log_debug("INSTREAM: Opening file for reading")

	-- Open file for reading
	local file, err = io.open(file_path, "rb")
	if not file then
		return false, "failed to open file: " .. (err or "unknown")
	end

	self:log_debug("INSTREAM: File opened successfully, creating socket")

	local clamav_socket
	clamav_socket, err = self:socket()
	if not clamav_socket then
		self.logger:log(ERR, "INSTREAM socket creation failed: " .. tostring(err))
		file:close()
		return false, "socket failed: " .. err
	end

	self:log_debug("INSTREAM: Socket created, sending INSTREAM command")

	-- Send INSTREAM command
	local bytes
	bytes, err = clamav_socket:send("zINSTREAM\0")
	if not bytes then
		self.logger:log(ERR, "INSTREAM command send failed: " .. tostring(err))
		clamav_socket:close()
		file:close()
		return false, "socket:send(INSTREAM) failed: " .. err
	end

	self:log_debug("INSTREAM: Command sent, reading file chunks")

	-- Send file in chunks with length prefix
	local chunk_size = 8192
	local total_bytes = 0
	local chunk_count = 0

	while true do
		local chunk = file:read(chunk_size)
		if not chunk then
			break
		end

		local chunk_len = #chunk
		total_bytes = total_bytes + chunk_len
		chunk_count = chunk_count + 1

		self:log_debug("INSTREAM: Read chunk " .. chunk_count .. ", size: " .. chunk_len)

		-- Send 4-byte length in network byte order (big-endian)
		-- Using math operations instead of bit library for compatibility
		local len_bytes = string.char(
			math.floor(chunk_len / 16777216) % 256,  -- byte 1 (most significant)
			math.floor(chunk_len / 65536) % 256,     -- byte 2
			math.floor(chunk_len / 256) % 256,       -- byte 3
			chunk_len % 256                           -- byte 4 (least significant)
		)

		bytes, err = clamav_socket:send(len_bytes .. chunk)
		if not bytes then
			self.logger:log(ERR, "INSTREAM failed to send chunk " .. chunk_count .. ": " .. tostring(err))
			clamav_socket:close()
			file:close()
			return false, "socket:send(chunk) failed: " .. err
		end

		self:log_debug("INSTREAM: Chunk " .. chunk_count .. " sent successfully")
	end

	file:close()
	self:log_debug("INSTREAM: All chunks sent - " .. chunk_count .. " chunks, " .. total_bytes .. " bytes total")

	-- Send 0-length to indicate end of stream
	self:log_debug("INSTREAM: Sending EOF marker")
	bytes, err = clamav_socket:send("\0\0\0\0")
	if not bytes then
		self.logger:log(ERR, "INSTREAM EOF send failed: " .. tostring(err))
		clamav_socket:close()
		return false, "socket:send(EOF) failed: " .. err
	end

	self:log_debug("INSTREAM: EOF sent, waiting for response")

	-- Receive response
	-- ClamAV may close connection quickly, so we need to handle partial reads
	local data, err, partial
	data, err, partial = clamav_socket:receive("*l")

	-- Log what we got for debugging
	self:log_debug("INSTREAM receive result - data: " .. tostring(data) .. ", err: " .. tostring(err) .. ", partial: " .. tostring(partial))

	-- If socket was closed, check if we got partial data
	if not data and err == "closed" and partial and partial ~= "" then
		-- We got the response but socket closed before newline
		-- This is normal for ClamAV closing connection after detection
		data = partial
		self:log_debug("INSTREAM: Using partial response before socket close")
	end

	-- If still no data, this is an error condition
	if not data or data == "" then
		clamav_socket:close()
		self.logger:log(ERR, "socket:receive() failed: " .. (err or "unknown") .. " - no data received")
		return false, "ClamAV connection error: " .. (err or "no response")
	end

	clamav_socket:close()

	-- Debug: Show last few bytes of the response (only in debug mode)
	if self:is_debug() then
		local len = #data
		local last_chars = ""
		for i = math.max(1, len - 5), len do
			local byte = string.byte(data, i)
			last_chars = last_chars .. string.format(" %d(0x%02X)", byte, byte)
		end
		self:log_debug("INSTREAM: Last 6 bytes of response:" .. last_chars)
	end

	-- Strip trailing whitespace/newline/null bytes from ClamAV response
	-- ClamAV INSTREAM responses end with null byte
	-- In Lua patterns, %z matches null bytes
	data = data:gsub("[%z\r\n\t ]+$", "")
	self:log_debug("INSTREAM: After trimming - data: [" .. data .. "], length: " .. #data)

	local detected = "clean"

	-- Parse response (format: "stream: OK" or "stream: Virus.Name FOUND")
	self:log_debug("INSTREAM: Parsing response: [" .. data .. "]")
	if data:match(" OK$") then
		detected = "clean"
		self:log_debug("INSTREAM result: CLEAN")
	elseif data:match(" FOUND$") then
		self:log_debug("INSTREAM: FOUND pattern matched, extracting virus name")
		local virus_name = data:match(": (.+) FOUND$")
		if virus_name then
			detected = virus_name
			self.logger:log(NOTICE, "INSTREAM: malware detected - " .. virus_name)
		else
			detected = "unknown_virus"
			self.logger:log(WARN, "INSTREAM: malware detected but virus name unknown")
		end
	elseif data:match("ERROR") then
		-- Check if it's a size limit error
		if data:match("INSTREAM size limit exceeded") or data:match("size limit") then
			self.logger:log(
				ERR,
				"ClamAV INSTREAM size limit exceeded: " .. data .. " - file too large for ClamAV, consider increasing MALWARE_SCAN_CLAMAV_MAX_SIZE"
			)
			return false, "file size exceeds ClamAV StreamMaxLength limit"
		end
		self.logger:log(ERR, "ClamAV INSTREAM error: " .. data)
		return false, "ClamAV error: " .. data
	else
		self.logger:log(WARN, "unexpected ClamAV INSTREAM response: " .. data)
		detected = "clean"
	end

	ok, err = self:add_to_cache(file_path, detected)
	if not ok then
		self.logger:log(ERR, "can't cache result: " .. err)
	end

	self:log_debug("INSTREAM: Scan completed, returning detected = " .. tostring(detected))
	return true, detected
end

-- Check if scan result is in cache.
-- Returns success boolean and cached value or nil.
function malware_scan:is_in_cache(file_path)
	local ok, data = self.cachestore:get("plugin_malware_scan_file_" .. file_path)
	if not ok then
		return false, nil
	end
	return true, data
end

-- Add scan result to cache.
-- Returns success boolean and error message if failed.
function malware_scan:add_to_cache(file_path, value)
	local ok, err = self.cachestore:set(
		"plugin_malware_scan_file_" .. file_path, 
		value, 
		3600
	)
	if not ok then
		return false, err
	end
	return true
end

-- Delete temporary file after scanning.
-- Returns success boolean and error message if failed.
function malware_scan:cleanup_file(file_path)
	if not file_path or file_path == "" then
		return false, "invalid file path"
	end

	-- Check if file exists first
	local file = io.open(file_path, "r")
	if not file then
		-- File doesn't exist - already cleaned up (possibly by security software like SentinelOne)
		self.logger:log(NOTICE, "temp file already removed (possibly by security software): " .. file_path)
		return true
	end
	file:close()

	-- File exists, try to remove it
	local ok, err = os.remove(file_path)
	if not ok then
		-- Check if error is "file not found" (race condition: deleted between check and remove)
		if err and (err:match("No such file") or err:match("cannot find")) then
			self.logger:log(NOTICE, "temp file already removed during cleanup: " .. file_path)
			return true
		end
		return false, err or "unknown error"
	end

	self.logger:log(NOTICE, "cleaned up temp file: " .. file_path)
	return true
end

-- Clean up orphaned temporary files older than specified age.
-- Scans temp directory and deletes files older than max_age seconds.
-- Returns success boolean and error message if failed.
function malware_scan:cleanup_orphaned_files(max_age)
	-- Use default nginx temp path for BunkerWeb
	local temp_path = "/var/tmp/bunkerweb/client_temp"
	
	local find_cmd = string.format(
		"find %s -type f -mmin +%d 2>/dev/null",
		temp_path,
		math.floor(max_age / 60)
	)
	
	local handle = io.popen(find_cmd)
	if not handle then
		return false, "failed to execute find command"
	end
	
	local cleaned_count = 0
	local error_count = 0
	
	for file_path in handle:lines() do
		local ok, err = os.remove(file_path)
		if ok then
			cleaned_count = cleaned_count + 1
		else
			-- Check if error is "file not found" (already deleted by security software)
			if err and (err:match("No such file") or err:match("cannot find")) then
				-- File already removed, count as cleaned
				cleaned_count = cleaned_count + 1
			else
				-- Actual error
				error_count = error_count + 1
				self.logger:log(
					WARN,
					"failed to remove orphaned file " .. file_path .. ": " .. (err or "unknown")
				)
			end
		end
	end
	
	handle:close()
	
	if cleaned_count > 0 then
		self.logger:log(
			NOTICE,
			"cleaned up " .. cleaned_count .. " orphaned temp files from " .. temp_path
		)
	end
	
	return true
end

-- Extract actual file content from multipart body.
-- The temp file contains the entire multipart/form-data body including headers.
-- This function extracts just the file content from the part with filename=.
-- Returns success boolean and extracted content or error message.
function malware_scan:extract_file_content(file_path)
	local file, err = io.open(file_path, "rb")
	if not file then
		return false, "failed to open file: " .. (err or "unknown")
	end

	-- Read the entire file (should be reasonable size for uploads)
	local content = file:read("*a")
	file:close()

	if not content or content == "" then
		return false, "file is empty"
	end

	-- Find the part that contains filename= (the actual file upload)
	local filename_pos = content:find('filename="')
	if not filename_pos then
		-- Try without quotes
		filename_pos = content:find("filename=")
		if not filename_pos then
			self.logger:log(ERR, "could not find filename in multipart body")
			return false, "no file upload found in multipart body"
		end
	end

	-- Find the end of headers for this part (double newline after filename line)
	local content_start = content:find("\r\n\r\n", filename_pos)
	if not content_start then
		-- Try just \n\n (some clients use this)
		content_start = content:find("\n\n", filename_pos)
		if not content_start then
			self.logger:log(ERR, "could not find end of file part headers")
			return false, "invalid multipart format"
		end
		content_start = content_start + 2  -- Skip \n\n
	else
		content_start = content_start + 4  -- Skip \r\n\r\n
	end

	-- Find the ending boundary AFTER the file content (starts with --)
	local boundary_pattern = "\r\n%-%-"
	local content_end = content:find(boundary_pattern, content_start)
	if not content_end then
		-- Try just \n--
		boundary_pattern = "\n%-%-"
		content_end = content:find(boundary_pattern, content_start)
		if not content_end then
			self.logger:log(ERR, "could not find ending multipart boundary")
			return false, "invalid multipart format"
		end
	end

	-- Extract just the file content (between headers and ending boundary)
	local file_content = content:sub(content_start, content_end - 1)

	self:log_debug("Extracted file content: " .. #file_content .. " bytes from " .. #content .. " bytes total")

	return true, file_content
end

-- Calculate SHA256 checksum of a file.
-- Takes file path, returns success boolean and checksum or error message.
-- For multipart uploads, extracts the actual file content first.
-- Returns special value "empty_file" for 0-byte files to skip calculation.
function malware_scan:calculate_sha256(file_path)
	-- Extract actual file content from multipart body
	local ok, file_content = self:extract_file_content(file_path)
	if not ok then
		self.logger:log(ERR, "failed to extract file content: " .. file_content)
		-- Fallback: hash the entire file as-is
		local file, err = io.open(file_path, "rb")
		if not file then
			return false, "failed to open file: " .. (err or "unknown")
		end

		local sha = sha256:new()
		if not sha then
			file:close()
			return false, "failed to create SHA256 instance"
		end

		while true do
			local chunk = file:read(8192)
			if not chunk then
				break
			end
			sha:update(chunk)
		end

		file:close()
		local checksum = to_hex(sha:final())
		self.logger:log(ERR, "calculated SHA256 of entire multipart body (fallback): " .. checksum)
		return true, checksum
	end

	-- Check if file is empty (0 bytes) - skip SHA256 calculation
	if #file_content == 0 then
		self.logger:log(ERR, "file is 0 bytes (empty), skipping SHA256 calculation")
		return true, "empty_file"
	end

	-- Calculate SHA256 of extracted file content
	local sha = sha256:new()
	if not sha then
		return false, "failed to create SHA256 instance"
	end

	sha:update(file_content)
	local checksum = to_hex(sha:final())

	self.logger:log(ERR, "calculated SHA256 of extracted file content (" .. #file_content .. " bytes): " .. checksum)
	return true, checksum
end

-- Check file checksum against VirusTotal API.
-- Takes file path and checksum, returns success boolean, detection result or error, and found boolean.
-- The found boolean indicates whether the file was found in VirusTotal's database.
function malware_scan:check_virustotal(file_path, checksum)
	-- Check if VirusTotal is enabled
	if self.variables["MALWARE_SCAN_USE_VIRUSTOTAL"] ~= "yes" then
		return true, "clean", false
	end

	-- Check if API key is configured and not a default value
	local api_key = self.variables["MALWARE_SCAN_VIRUSTOTAL_API_KEY"]
	if not api_key or api_key == "" or api_key == "your_api_key" or api_key == "your_token" then
		self.logger:log(ERR, "VirusTotal enabled but API key not configured or using default value")
		return true, "clean", false
	end

	-- Check cache
	local ok, cached = self:is_in_vt_cache(checksum)
	if ok and cached then
		self.logger:log(ERR, "file checksum " .. checksum .. " found in VT cache: " .. cached)
		-- Assume if it's in cache, it was found before
		return true, cached, true
	end

	-- Request from VirusTotal API
	self.logger:log(ERR, "sending request to VirusTotal API for checksum: " .. checksum)
	local found, response
	ok, found, response = self:virustotal_request("/files/" .. checksum)
	if not ok then
		self.logger:log(ERR, "VirusTotal API request failed: " .. found)
		return true, "clean", false
	end

	local result = "clean"
	if found then
		self.logger:log(ERR, "file found on VirusTotal, analyzing results")
		result = self:get_virustotal_result(response)
		self.logger:log(ERR, "VirusTotal result: " .. result)
	else
		self.logger:log(ERR, "file checksum " .. checksum .. " not found on VirusTotal (new file)")
	end

	-- Add to cache
	ok, err = self:add_to_vt_cache(checksum, result)
	if not ok then
		self.logger:log(ERR, "can't cache VT result: " .. err)
	end

	return true, result, found
end

-- Make HTTP request to VirusTotal API.
-- Takes API endpoint URL, returns success boolean, found boolean, and response data.
function malware_scan:virustotal_request(url)
	-- Get HTTP client
	local httpc, err = http_new()
	if not httpc then
		return false, err
	end

	-- Send request
	local res
	res, err = httpc:request_uri("https://www.virustotal.com/api/v3" .. url, {
		headers = {
			["x-apikey"] = self.variables["MALWARE_SCAN_VIRUSTOTAL_API_KEY"],
			["accept"] = "application/json",
			["User-Agent"] = USER_AGENT,
		},
	})
	if not res then
		return false, err
	end

	-- Check status
	if res.status == 404 then
		return true, false
	end
	if res.status ~= 200 then
		err = "received status " .. tostring(res.status) .. " from VirusTotal API"
		local ok, data = pcall(decode, res.body)
		if ok and data then
			err = err .. " with data " .. encode(data)
		end
		return false, err
	end

	-- Parse JSON response
	local ok, data = pcall(decode, res.body)
	if not ok then
		return false, "failed to decode JSON: " .. data
	end
	if not data.data or not data.data.attributes or not data.data.attributes.last_analysis_stats then
		return false, "malformed JSON response from VirusTotal"
	end

	return true, true, data.data.attributes.last_analysis_stats
end

-- Process VirusTotal analysis stats and determine if file is malicious.
-- Takes response stats, returns result string ("clean" or description of detections).
function malware_scan:get_virustotal_result(response)
	local suspicious = response["suspicious"] or 0
	local malicious = response["malicious"] or 0

	local suspicious_threshold = tonumber(self.variables["MALWARE_SCAN_VIRUSTOTAL_SUSPICIOUS"]) or 5
	local malicious_threshold = tonumber(self.variables["MALWARE_SCAN_VIRUSTOTAL_MALICIOUS"]) or 3

	if suspicious > suspicious_threshold or malicious > malicious_threshold then
		return tostring(suspicious) .. " suspicious and " .. tostring(malicious) .. " malicious"
	end

	return "clean"
end

-- Check if VirusTotal scan result is in cache.
-- Returns success boolean and cached value or nil.
function malware_scan:is_in_vt_cache(checksum)
	local ok, data = self.cachestore:get("plugin_malware_scan_vt_" .. checksum)
	if not ok then
		return false, nil
	end
	return true, data
end

-- Add VirusTotal scan result to cache.
-- Returns success boolean and error message if failed.
function malware_scan:add_to_vt_cache(checksum, value)
	-- Differential caching: clean results cached for 5 minutes, malicious for 1 hour
	-- This prevents false negatives if a file becomes identified as malware shortly after upload
	local cache_ttl
	if value == "clean" then
		cache_ttl = 300  -- 5 minutes for clean files
		self.logger:log(ERR, "[CACHE_CLEAN] VirusTotal result cached for 5 minutes")
	else
		cache_ttl = tonumber(self.variables["MALWARE_SCAN_CACHE_TTL"]) or 3600  -- 1 hour for malicious
		self.logger:log(ERR, "[CACHE_MALWARE] VirusTotal result cached for " .. cache_ttl .. " seconds")
	end

	local ok, err = self.cachestore:set(
		"plugin_malware_scan_vt_" .. checksum,
		value,
		cache_ttl
	)
	if not ok then
		return false, err
	end
	return true
end

-- Upload file to VirusTotal for analysis.
-- Takes file path, returns success boolean, analysis ID or error message, and file size.
-- Only uploads files smaller than the configured max size (default 32MB).
function malware_scan:virustotal_upload_file(file_path)
	self.logger:log(ERR, "preparing to upload file to VirusTotal")

	-- Extract file content from multipart body
	local ok, file_content = self:extract_file_content(file_path)
	if not ok then
		return false, "failed to extract file content: " .. file_content
	end

	local file_size = #file_content
	self:log_debug("extracted file size: " .. file_size .. " bytes")

	-- Check file size against max upload size
	local max_size = tonumber(self.variables["MALWARE_SCAN_VT_MAX_UPLOAD_SIZE"]) or 33554432
	if file_size > max_size then
		self.logger:log(ERR, "file too large for VirusTotal upload: " .. file_size .. " bytes (max: " .. max_size .. " bytes)")
		return false, "file too large for upload (max " .. max_size .. " bytes)"
	end

	self.logger:log(ERR, "uploading file to VirusTotal (" .. file_size .. " bytes)")

	-- Get HTTP client
	local httpc, err = http_new()
	if not httpc then
		return false, err
	end

	-- Create multipart/form-data boundary
	local boundary = "----WebKitFormBoundary" .. ngx.time()

	-- Build multipart body
	local body_parts = {}
	table.insert(body_parts, "--" .. boundary .. "\r\n")
	table.insert(body_parts, 'Content-Disposition: form-data; name="file"; filename="upload"\r\n')
	table.insert(body_parts, "Content-Type: application/octet-stream\r\n\r\n")
	table.insert(body_parts, file_content)
	table.insert(body_parts, "\r\n--" .. boundary .. "--\r\n")

	local upload_body = table.concat(body_parts)

	-- Send upload request
	local res
	res, err = httpc:request_uri("https://www.virustotal.com/api/v3/files", {
		method = "POST",
		headers = {
			["x-apikey"] = self.variables["MALWARE_SCAN_VIRUSTOTAL_API_KEY"],
			["accept"] = "application/json",
			["Content-Type"] = "multipart/form-data; boundary=" .. boundary,
			["Content-Length"] = tostring(#upload_body),
			["User-Agent"] = USER_AGENT,
		},
		body = upload_body,
	})

	if not res then
		return false, err
	end

	-- Check status
	if res.status ~= 200 then
		err = "received status " .. tostring(res.status) .. " from VirusTotal upload API"
		local decode_ok, data = pcall(decode, res.body)
		if decode_ok and data then
			err = err .. " with data " .. encode(data)
		end
		return false, err
	end

	-- Parse JSON response
	local decode_ok, data = pcall(decode, res.body)
	if not decode_ok then
		return false, "failed to decode JSON: " .. data
	end

	-- Extract analysis ID from response
	local analysis_id = nil
	if data.data and data.data.id then
		analysis_id = data.data.id
		self.logger:log(ERR, "file uploaded to VirusTotal successfully, analysis ID: " .. analysis_id)
	else
		self.logger:log(ERR, "file uploaded but no analysis ID returned")
	end

	return true, analysis_id, file_size
end

-- Vote on a file in VirusTotal.
-- Takes SHA256 checksum and verdict ("harmless" or "malicious").
-- Returns success boolean and error message if failed.
function malware_scan:virustotal_vote(checksum, verdict)
	self.logger:log(ERR, "voting on VirusTotal file " .. checksum .. " as " .. verdict)

	-- Validate verdict
	if verdict ~= "harmless" and verdict ~= "malicious" then
		return false, "invalid verdict: " .. verdict .. " (must be 'harmless' or 'malicious')"
	end

	-- Get HTTP client
	local httpc, err = http_new()
	if not httpc then
		return false, err
	end

	-- Build vote request body
	local vote_data = {
		data = {
			type = "vote",
			attributes = {
				verdict = verdict
			}
		}
	}

	local body = encode(vote_data)

	-- Send vote request
	local res
	res, err = httpc:request_uri("https://www.virustotal.com/api/v3/files/" .. checksum .. "/votes", {
		method = "POST",
		headers = {
			["x-apikey"] = self.variables["MALWARE_SCAN_VIRUSTOTAL_API_KEY"],
			["accept"] = "application/json",
			["Content-Type"] = "application/json",
			["Content-Length"] = tostring(#body),
			["User-Agent"] = USER_AGENT,
		},
		body = body,
	})

	if not res then
		return false, err
	end

	-- Check status (200 or 201 are success)
	if res.status ~= 200 and res.status ~= 201 then
		err = "received status " .. tostring(res.status) .. " from VirusTotal vote API"
		local decode_ok, data = pcall(decode, res.body)
		if decode_ok and data then
			err = err .. " with data " .. encode(data)
		end
		return false, err
	end

	self.logger:log(ERR, "vote submitted successfully to VirusTotal")
	return true
end

-- Share detected malware file with threat intelligence platforms.
-- Takes file path, checksum, and detector name, uploads file if sharing is enabled.
-- Returns success boolean and error message if failed.
-- Currently supports VirusTotal (ThreatFox has no upload, SentinelOne TBD).
function malware_scan:share_detected_file(file_path, checksum, detector_name)
	-- Check if file sharing is enabled
	if self.variables["MALWARE_SCAN_SHARE_FILES"] ~= "yes" then
		self:log_debug("File sharing disabled, not uploading detected malware")
		return true
	end

	-- Check if VirusTotal is enabled for sharing
	if self.variables["MALWARE_SCAN_USE_VIRUSTOTAL"] ~= "yes" then
		self.logger:log(ERR, "File sharing enabled but VirusTotal not configured - cannot share detected file")
		return true
	end

	self.logger:log(ERR, "[SHARE] File detected by " .. detector_name .. ", checking if already known to VirusTotal")

	-- Check if file is already known to VirusTotal
	local vt_ok, vt_found, vt_response = self:virustotal_request("/files/" .. checksum)
	if not vt_ok then
		self.logger:log(ERR, "[SHARE] VirusTotal check failed: " .. vt_found .. " - cannot determine if file should be shared")
		return true
	end

	if vt_found then
		self.logger:log(ERR, "[SHARE] File already known to VirusTotal (detected by " .. detector_name .. ") - skipping upload")
		return true
	end

	-- File is unknown to VirusTotal, upload it
	self.logger:log(ERR, "[SHARE] File unknown to VirusTotal, uploading for threat intelligence (detected by " .. detector_name .. ")")
	local upload_ok, analysis_id, file_size = self:virustotal_upload_file(file_path)

	if not upload_ok then
		self.logger:log(ERR, "[SHARE] Failed to upload file to VirusTotal: " .. analysis_id)
		return false, analysis_id
	end

	self.logger:log(ERR, "[SHARE] File uploaded successfully (" .. file_size .. " bytes), analysis ID: " .. tostring(analysis_id))

	-- Auto-vote if enabled
	if self.variables["MALWARE_SCAN_VT_AUTO_VOTE"] == "yes" then
		self.logger:log(ERR, "[SHARE] Auto-voting file as malicious on VirusTotal")
		local vote_ok, vote_err = self:virustotal_vote(checksum, "malicious")
		if vote_ok then
			self.logger:log(ERR, "[SHARE] Malicious vote submitted successfully")
		else
			self.logger:log(ERR, "[SHARE] Failed to submit vote: " .. vote_err)
		end
	end

	return true
end

-- Check file hash against ThreatFox (abuse.ch) API.
-- Takes SHA256 or MD5 checksum, returns success boolean and detection result or error.
-- Returns malware family information if hash is found in ThreatFox IOC database.
function malware_scan:check_threatfox(checksum)
	-- Check if ThreatFox is enabled
	if self.variables["MALWARE_SCAN_USE_THREATFOX"] ~= "yes" then
		return true, "clean"
	end

	-- Check cache first
	local ok, cached = self:is_in_threatfox_cache(checksum)
	if ok and cached then
		self.logger:log(ERR, "file checksum " .. checksum .. " found in ThreatFox cache: " .. cached)
		return true, cached
	end

	-- Request from ThreatFox API
	self.logger:log(ERR, "sending request to ThreatFox API for checksum: " .. checksum)
	local found, malware_info
	ok, found, malware_info = self:threatfox_request(checksum)
	if not ok then
		self.logger:log(ERR, "ThreatFox API request failed: " .. found)
		return true, "clean"
	end

	local result = "clean"
	if found then
		self.logger:log(ERR, "file hash found in ThreatFox IOC database")
		result = malware_info
		self.logger:log(ERR, "ThreatFox result: " .. result)
	else
		self.logger:log(ERR, "file checksum " .. checksum .. " not found in ThreatFox")
	end

	-- Add to cache
	ok, err = self:add_to_threatfox_cache(checksum, result)
	if not ok then
		self.logger:log(ERR, "can't cache ThreatFox result: " .. err)
	end

	return true, result
end

-- Make HTTP request to ThreatFox API.
-- Takes hash (SHA256 or MD5), returns success boolean, found boolean, and malware info.
function malware_scan:threatfox_request(hash)
	-- Get HTTP client
	local httpc, err = http_new()
	if not httpc then
		return false, err
	end

	-- Get API key (required for ThreatFox) and check for default values
	local api_key = self.variables["MALWARE_SCAN_THREATFOX_API_KEY"]
	if not api_key or api_key == "" or api_key == "your_api_key" or api_key == "your_token" then
		return false, "ThreatFox API key is required but not configured or using default value"
	end

	-- Build request body
	local request_data = {
		query = "search_hash",
		hash = hash
	}

	local body = encode(request_data)

	-- Send request with Auth-Key in HTTP header
	local res
	res, err = httpc:request_uri("https://threatfox-api.abuse.ch/api/v1/", {
		method = "POST",
		headers = {
			["Auth-Key"] = api_key,
			["Content-Type"] = "application/json",
			["accept"] = "application/json",
			["Content-Length"] = tostring(#body),
			["User-Agent"] = USER_AGENT,
		},
		body = body,
	})

	if not res then
		return false, err
	end

	-- Check status
	if res.status ~= 200 then
		err = "received status " .. tostring(res.status) .. " from ThreatFox API"
		local decode_ok, data = pcall(decode, res.body)
		if decode_ok and data then
			err = err .. " with data " .. encode(data)
		end
		return false, err
	end

	-- Parse JSON response
	local decode_ok, data = pcall(decode, res.body)
	if not decode_ok then
		return false, "failed to decode JSON: " .. data
	end

	-- Check query status
	if not data.query_status then
		return false, "malformed JSON response from ThreatFox"
	end

	if data.query_status == "no_result" then
		-- Hash not found in ThreatFox
		return true, false
	end

	if data.query_status ~= "ok" then
		return false, "ThreatFox query failed: " .. data.query_status
	end

	-- Extract malware information
	if not data.data or #data.data == 0 then
		return true, false
	end

	-- Build malware info string from first IOC
	local ioc = data.data[1]
	local malware_name = ioc.malware_printable or ioc.malware or "unknown"
	local threat_type = ioc.threat_type_desc or ioc.threat_type or "unknown"
	local confidence = ioc.confidence_level or 0
	local ioc_count = #data.data

	local malware_info = string.format(
		"%s (%s, confidence: %d%%, %d IOCs)",
		malware_name,
		threat_type,
		confidence,
		ioc_count
	)

	return true, true, malware_info
end

-- Check if ThreatFox result is in cache.
-- Returns success boolean and cached value or nil.
function malware_scan:is_in_threatfox_cache(checksum)
	local ok, data = self.cachestore:get("plugin_malware_scan_threatfox_" .. checksum)
	if not ok then
		return false, nil
	end
	return true, data
end

-- Add ThreatFox result to cache.
-- Returns success boolean and error message if failed.
function malware_scan:add_to_threatfox_cache(checksum, value)
	-- Differential caching: clean results cached for 5 minutes, malicious for 1 hour
	-- This prevents false negatives if a file becomes identified as malware shortly after upload
	local cache_ttl
	if value == "clean" then
		cache_ttl = 300  -- 5 minutes for clean files
		self.logger:log(ERR, "[CACHE_CLEAN] ThreatFox result cached for 5 minutes")
	else
		cache_ttl = tonumber(self.variables["MALWARE_SCAN_CACHE_TTL"]) or 3600  -- 1 hour for malicious
		self.logger:log(ERR, "[CACHE_MALWARE] ThreatFox result cached for " .. cache_ttl .. " seconds")
	end

	local ok, err = self.cachestore:set(
		"plugin_malware_scan_threatfox_" .. checksum,
		value,
		cache_ttl
	)
	if not ok then
		return false, err
	end
	return true
end

-- Check file hash against SentinelOne API.
-- Takes SHA256 checksum, returns success boolean and detection result or error.
-- Returns threat information if hash is found in SentinelOne's threat database.
function malware_scan:check_sentinelone(checksum)
	-- Check if SentinelOne is enabled
	if self.variables["MALWARE_SCAN_USE_SENTINELONE"] ~= "yes" then
		return true, "clean"
	end

	-- Check cache first
	local ok, cached = self:is_in_sentinelone_cache(checksum)
	if ok and cached then
		self.logger:log(ERR, "file checksum " .. checksum .. " found in SentinelOne cache: " .. cached)
		return true, cached
	end

	-- Request from SentinelOne API
	self.logger:log(ERR, "sending request to SentinelOne API for checksum: " .. checksum)
	local found, threat_info
	ok, found, threat_info = self:sentinelone_request(checksum)
	if not ok then
		self.logger:log(ERR, "SentinelOne API request failed: " .. found)
		return true, "clean"
	end

	local result = "clean"
	if found then
		self.logger:log(ERR, "file hash found in SentinelOne threat database")
		result = threat_info
		self.logger:log(ERR, "SentinelOne result: " .. result)
	else
		self.logger:log(ERR, "file checksum " .. checksum .. " not found in SentinelOne")
	end

	-- Add to cache
	ok, err = self:add_to_sentinelone_cache(checksum, result)
	if not ok then
		self.logger:log(ERR, "can't cache SentinelOne result: " .. err)
	end

	return true, result
end

-- Make HTTP request to SentinelOne API.
-- Takes hash (SHA256), returns success boolean, found boolean, and threat info.
function malware_scan:sentinelone_request(hash)
	-- Get HTTP client
	local httpc, err = http_new()
	if not httpc then
		return false, err
	end

	-- Get API token and management URL (required for SentinelOne) and check for default values
	local api_token = self.variables["MALWARE_SCAN_SENTINELONE_API_TOKEN"]
	if not api_token or api_token == "" or api_token == "your_api_key" or api_token == "your_token" then
		return false, "SentinelOne API token is required but not configured or using default value"
	end

	local mgmt_url = self.variables["MALWARE_SCAN_SENTINELONE_MANAGEMENT_URL"]
	if not mgmt_url or mgmt_url == "" or mgmt_url == "https://your-console.example.com" then
		return false, "SentinelOne Management URL is required but not configured or using default value"
	end

	-- Remove trailing slash from management URL if present
	mgmt_url = mgmt_url:gsub("/$", "")

	-- Build API endpoint for threat lookup by hash
	-- Using /web/api/v2.1/threats endpoint with contentHash filter
	local api_url = mgmt_url .. "/web/api/v2.1/threats"

	-- Send request with contentHashes filter
	local res
	res, err = httpc:request_uri(api_url, {
		method = "GET",
		headers = {
			["Authorization"] = "ApiToken " .. api_token,
			["Content-Type"] = "application/json",
			["accept"] = "application/json",
			["User-Agent"] = USER_AGENT,
		},
		query = {
			contentHashes = hash,
			limit = "1"
		}
	})

	if not res then
		return false, err
	end

	-- Check status
	if res.status ~= 200 then
		err = "received status " .. tostring(res.status) .. " from SentinelOne API"
		local decode_ok, data = pcall(decode, res.body)
		if decode_ok and data then
			err = err .. " with data " .. encode(data)
		end
		return false, err
	end

	-- Parse JSON response
	local decode_ok, data = pcall(decode, res.body)
	if not decode_ok then
		return false, "failed to decode JSON: " .. data
	end

	-- Check if threats were found
	if not data.data or #data.data == 0 then
		-- Hash not found in SentinelOne
		return true, false
	end

	-- Extract threat information from first result
	local threat = data.data[1]
	local threat_name = threat.threatName or threat.maliciousProcessArguments or "unknown threat"
	local classification = threat.classification or "unknown"
	local confidence_level = threat.confidenceLevel or "unknown"

	-- Build threat info string
	local threat_info = string.format(
		"%s (Classification: %s, Confidence: %s)",
		threat_name,
		classification,
		confidence_level
	)

	return true, true, threat_info
end

-- Check if SentinelOne result is in cache.
-- Returns success boolean and cached value or nil.
function malware_scan:is_in_sentinelone_cache(checksum)
	local ok, data = self.cachestore:get("plugin_malware_scan_sentinelone_" .. checksum)
	if not ok then
		return false, nil
	end
	return true, data
end

-- Add SentinelOne result to cache.
-- Returns success boolean and error message if failed.
function malware_scan:add_to_sentinelone_cache(checksum, value)
	-- Differential caching: clean results cached for 5 minutes, malicious for 1 hour
	-- This prevents false negatives if a file becomes identified as malware shortly after upload
	local cache_ttl
	if value == "clean" then
		cache_ttl = 300  -- 5 minutes for clean files
		self.logger:log(ERR, "[CACHE_CLEAN] SentinelOne result cached for 5 minutes")
	else
		cache_ttl = tonumber(self.variables["MALWARE_SCAN_CACHE_TTL"]) or 3600  -- 1 hour for malicious
		self.logger:log(ERR, "[CACHE_MALWARE] SentinelOne result cached for " .. cache_ttl .. " seconds")
	end

	local ok, err = self.cachestore:set(
		"plugin_malware_scan_sentinelone_" .. checksum,
		value,
		cache_ttl
	)
	if not ok then
		return false, err
	end
	return true
end

-- Scan content directly via ClamAV's INSTREAM command.
-- Takes content as string, returns success boolean and detection result or error.
-- Used for testing ClamAV with EICAR test string.
function malware_scan:scan_content_instream(content)
	self:log_debug("=== INSTREAM: scan_content_instream() called with " .. #content .. " bytes ===")

	self.logger:log(ERR, "scanning content via INSTREAM: " .. #content .. " bytes")

	local clamav_socket, err = self:socket()
	if not clamav_socket then
		self.logger:log(ERR, "INSTREAM socket creation failed: " .. tostring(err))
		return false, "socket failed: " .. err
	end

	self:log_debug("INSTREAM: Socket created, sending INSTREAM command")

	-- Send INSTREAM command
	local bytes
	bytes, err = clamav_socket:send("zINSTREAM\0")
	if not bytes then
		self.logger:log(ERR, "INSTREAM command send failed: " .. tostring(err))
		clamav_socket:close()
		return false, "socket:send(INSTREAM) failed: " .. err
	end

	self:log_debug("INSTREAM: Command sent, sending content")

	-- Send content in chunks with length prefix
	local chunk_size = 8192
	local total_bytes = 0
	local chunk_count = 0
	local pos = 1

	while pos <= #content do
		local chunk = content:sub(pos, pos + chunk_size - 1)
		local chunk_len = #chunk
		total_bytes = total_bytes + chunk_len
		chunk_count = chunk_count + 1

		self:log_debug("INSTREAM: Sending chunk " .. chunk_count .. ", size: " .. chunk_len)

		-- Send 4-byte length in network byte order (big-endian)
		local len_bytes = string.char(
			math.floor(chunk_len / 16777216) % 256,
			math.floor(chunk_len / 65536) % 256,
			math.floor(chunk_len / 256) % 256,
			chunk_len % 256
		)

		bytes, err = clamav_socket:send(len_bytes .. chunk)
		if not bytes then
			self.logger:log(ERR, "INSTREAM failed to send chunk " .. chunk_count .. ": " .. tostring(err))
			clamav_socket:close()
			return false, "socket:send(chunk) failed: " .. err
		end

		pos = pos + chunk_size
	end

	self:log_debug("INSTREAM: All chunks sent - " .. chunk_count .. " chunks, " .. total_bytes .. " bytes total")

	-- Send 0-length to indicate end of stream
	self:log_debug("INSTREAM: Sending EOF marker")
	bytes, err = clamav_socket:send("\0\0\0\0")
	if not bytes then
		self.logger:log(ERR, "INSTREAM EOF send failed: " .. tostring(err))
		clamav_socket:close()
		return false, "socket:send(EOF) failed: " .. err
	end

	self:log_debug("INSTREAM: EOF sent, waiting for response")

	-- Receive response
	local data, err, partial
	data, err, partial = clamav_socket:receive("*l")

	self:log_debug("INSTREAM receive result - data: " .. tostring(data) .. ", err: " .. tostring(err) .. ", partial: " .. tostring(partial))

	-- If socket was closed, check if we got partial data
	if not data and err == "closed" and partial and partial ~= "" then
		data = partial
		self:log_debug("INSTREAM: Using partial response before socket close")
	end

	-- If still no data, this is an error condition
	if not data or data == "" then
		clamav_socket:close()
		self.logger:log(ERR, "socket:receive() failed: " .. (err or "unknown") .. " - no data received")
		return false, "ClamAV connection error: " .. (err or "no response")
	end

	clamav_socket:close()

	-- Strip trailing whitespace/newline/null bytes from ClamAV response
	data = data:gsub("[%z\r\n\t ]+$", "")
	self:log_debug("INSTREAM: After trimming - data: [" .. data .. "], length: " .. #data)

	local detected = "clean"

	-- Parse response (format: "stream: OK" or "stream: Virus.Name FOUND")
	self:log_debug("INSTREAM: Parsing response: [" .. data .. "]")
	if data:match(" OK$") then
		detected = "clean"
		self:log_debug("INSTREAM result: CLEAN")
	elseif data:match(" FOUND$") then
		self:log_debug("INSTREAM: FOUND pattern matched, extracting virus name")
		local virus_name = data:match(": (.+) FOUND$")
		if virus_name then
			detected = virus_name
			self.logger:log(NOTICE, "INSTREAM: malware detected - " .. virus_name)
		else
			detected = "unknown_virus"
			self.logger:log(WARN, "INSTREAM: malware detected but virus name unknown")
		end
	elseif data:match("ERROR") then
		self.logger:log(ERR, "ClamAV INSTREAM error: " .. data)
		return false, "ClamAV error: " .. data
	else
		self.logger:log(WARN, "unexpected ClamAV INSTREAM response: " .. data)
		detected = "clean"
	end

	self:log_debug("INSTREAM: Scan completed, returning detected = " .. tostring(detected))
	return true, detected
end

-- API endpoint handler for testing ClamAV and VirusTotal connectivity.
-- Responds to POST requests at /malware-scan/ping, /malware-scan/test-eicar, and /malware-scan/virustotal-ping.
function malware_scan:api()
	-- ClamAV connectivity test
	if self.ctx.bw.uri == "/malware-scan/ping" and self.ctx.bw.request_method == "POST" then
		local check, err = has_variable("MALWARE_SCAN_ENABLED", "yes")
		if check == nil then
			return self:ret(true, "error while checking variable MALWARE_SCAN_ENABLED (" .. err .. ")")
		end
		if not check then
			return self:ret(true, "Malware scan plugin not enabled")
		end

		local ok, data = self:command("PING")
		if not ok then
			return self:ret(true, "connectivity with ClamAV failed : " .. data, HTTP_INTERNAL_SERVER_ERROR)
		end
		if data ~= "PONG" then
			return self:ret(true, "wrong data received from ClamAV : " .. data, HTTP_INTERNAL_SERVER_ERROR)
		end
		return self:ret(true, "connectivity with ClamAV is successful", HTTP_OK)
	end

	-- ClamAV EICAR test
	if self.ctx.bw.uri == "/malware-scan/test-eicar" and self.ctx.bw.request_method == "POST" then
		local check, err = has_variable("MALWARE_SCAN_ENABLED", "yes")
		if check == nil then
			return self:ret(true, "error while checking variable MALWARE_SCAN_ENABLED (" .. err .. ")")
		end
		if not check then
			return self:ret(true, "Malware scan plugin not enabled")
		end

		-- EICAR test virus string
		local eicar = "X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"

		self.logger:log(ERR, "Testing ClamAV with EICAR test file")
		local ok, detected = self:scan_content_instream(eicar)

		if not ok then
			return self:ret(
				true,
				"ClamAV scan failed: " .. detected,
				HTTP_INTERNAL_SERVER_ERROR
			)
		end

		if detected == "clean" then
			return self:ret(
				true,
				"WARNING: ClamAV did not detect EICAR test file (expected: Eicar-Signature, got: clean)",
				HTTP_INTERNAL_SERVER_ERROR
			)
		end

		-- Successfully detected EICAR
		return self:ret(
			true,
			"ClamAV successfully detected EICAR test file: " .. detected,
			HTTP_OK
		)
	end

	-- VirusTotal connectivity test
	if self.ctx.bw.uri == "/malware-scan/virustotal-ping" and self.ctx.bw.request_method == "POST" then
		local check, err = has_variable("MALWARE_SCAN_ENABLED", "yes")
		if check == nil then
			return self:ret(true, "error while checking variable MALWARE_SCAN_ENABLED (" .. err .. ")")
		end
		if not check then
			return self:ret(true, "Malware scan plugin not enabled")
		end

		if self.variables["MALWARE_SCAN_USE_VIRUSTOTAL"] ~= "yes" then
			return self:ret(true, "VirusTotal integration not enabled", HTTP_INTERNAL_SERVER_ERROR)
		end

		if not self.variables["MALWARE_SCAN_VIRUSTOTAL_API_KEY"]
			or self.variables["MALWARE_SCAN_VIRUSTOTAL_API_KEY"] == "" then
			return self:ret(true, "VirusTotal API key not configured", HTTP_INTERNAL_SERVER_ERROR)
		end

		-- Test with EICAR test file SHA256 checksum
		local ok, found, response = self:virustotal_request(
			"/files/275a021bbfb6489e54d471899f7db9d1663fc695ec2fe2a2c4538aabf651fd0f"
		)
		if not ok then
			return self:ret(
				true,
				"error while connecting to VirusTotal API: " .. found,
				HTTP_INTERNAL_SERVER_ERROR
			)
		end
		if not found then
			return self:ret(
				true,
				"error while testing VirusTotal: EICAR test file not found on VirusTotal",
				HTTP_INTERNAL_SERVER_ERROR
			)
		end
		return self:ret(
			true,
			"connectivity with VirusTotal is successful, response: " .. encode(response),
			HTTP_OK
		)
	end

	return self:ret(false, "success")
end

return malware_scan
