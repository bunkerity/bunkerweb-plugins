local class = require("middleclass")
local plugin = require("bunkerweb.plugin")
local utils = require("bunkerweb.utils")
local cjson = require("cjson")
local http = require("resty.http")
-- Note: sha256 and str (resty.string) are now only used in malware_scan_file.lua

-- Load modules using initialization module
-- Add plugin directory to package path so require() can find the modules
package.path = package.path .. ";/etc/bunkerweb/plugins/malware-scan/?.lua"

-- Load initialization module
local ms_init = require("malware_scan_init")

-- Initialize all dependencies (loads modules and sets up cross-dependencies)
local deps = ms_init.initialize()

-- Extract modules for easier access throughout the code
local ms_logger = deps.modules.logger
local cache = deps.modules.cache
local database = deps.modules.database
local file_ops = deps.modules.file_ops
local clamav = deps.modules.clamav
local virustotal = deps.modules.virustotal
local sentinelone = deps.modules.sentinelone
local malwarebazaar = deps.modules.malwarebazaar
local webhook = deps.modules.webhook
local multipart_full_scan = deps.modules.multipart_full_scan
local ms_utils = deps.modules.ms_utils
local ms_config = deps.modules.ms_config
local ms_orchestrator = deps.modules.ms_orchestrator
local ms_api = deps.modules.ms_api
local ms_scheduler = deps.modules.ms_scheduler
local ui_metrics = deps.modules.ui_metrics

-- Extract load status for modules that need status checks
local multipart_full_scan_load_ok = deps.status.multipart_full_scan
local ms_utils_load_ok = deps.status.ms_utils
local ms_config_load_ok = deps.status.ms_config
local ms_orchestrator_load_ok = deps.status.ms_orchestrator

-- Ngx constants
local ngx = ngx
local ERR = ngx.ERR
local WARN = ngx.WARN
local NOTICE = ngx.NOTICE
local INFO = ngx.INFO

-- Plugin version
local VERSION = "0.8.0"

local malware_scan = class("malware-scan", plugin)

local socket = ngx.socket
local HTTP_INTERNAL_SERVER_ERROR = ngx.HTTP_INTERNAL_SERVER_ERROR
local HTTP_OK = ngx.HTTP_OK
local has_variable = utils.has_variable
local get_deny_status = utils.get_deny_status
local tonumber = tonumber
local tostring = tostring
local decode = cjson.decode
local encode = cjson.encode
local http_new = http.new
-- Note: to_hex (str.to_hex) now only used in malware_scan_file.lua

-- User-Agent for external API calls
local USER_AGENT = "bunkerweb - https://github.com/bunkerity/bunkerweb - malware-scan module v" .. VERSION

-- Version prefix for debug messages
local DEBUG_PREFIX = "[v" .. VERSION .. "] [DEBUG]"

-- Initialize plugin instance with context.
function malware_scan:initialize(ctx)
	plugin.initialize(self, "malware-scan", ctx)
	-- Note: Redis initialization moved to access() phase after file upload check
	-- to avoid wasteful initialization on every GET request
end

-- Init phase: Runs once on manager process (not workers).
-- NOTE: Cleanup is handled by the scheduler job (malware-scan-cache-cleanup.py)
--       which runs at startup and correctly reads environment variables via getenv().
--       The init() phase cannot reliably detect per-site or environment configuration,
--       as has_variable() only checks BunkerWeb's global database configuration.
function malware_scan:init()
	self.logger:log(NOTICE, "[INIT] Entering init phase for malware-scan v" .. VERSION .. " (manager process)")
	self.logger:log(NOTICE, "[INIT] Cache cleanup is handled by scheduler job 'malware-scan-cache-cleanup'")
	self.logger:log(NOTICE, "[INIT] (Scheduler job correctly reads environment variables, init phase cannot)")
	return self:ret(true, "init complete")
end

-- Helper function to check if debug mode is enabled.
-- Returns true if MALWARE_SCAN_DEBUG=yes, false otherwise.
function malware_scan:is_debug()
	return self.variables["MALWARE_SCAN_DEBUG"] == "yes"
end

-- Log a message only if debug mode is enabled.
-- Uses INFO level for debug messages (semantically correct).
-- Includes version prefix for easier tracking across versions.
function malware_scan:log_debug(message)
	if self:is_debug() then
		self.logger:log(INFO, DEBUG_PREFIX .. " " .. message)
	end
end

-- Mask sensitive values (API keys, webhook URLs) for security.
-- Delegates to utils.data_mask_sensitive() with plugin context.
--- @param value The sensitive value to mask (API key, webhook URL, etc.)
--- @return string result Masked string or original value if unmasking is enabled
function malware_scan:mask_sensitive(value)
	if ms_utils_load_ok and ms_utils then
		return ms_utils.data_mask_sensitive(value, self.variables["MALWARE_SCAN_UNMASK_KEYS"])
	end
	-- Fallback if utils not loaded: simple masking
	return value and #value > 8 and value:sub(1, 4) .. "***" or "***"
end

-- Sanitize external data (scanner results, filenames) before logging to prevent log injection (CWE-117).
-- Delegates to utils.log_sanitize() for safe logging.
--- @param data The external data to sanitize (scanner signature, API response, etc.)
--- @return string result Sanitized string safe for logging
function malware_scan:sanitize_external_data(data)
	if ms_utils_load_ok and ms_utils then
		return ms_utils.log_sanitize(data)
	end
	-- Fallback: simple tostring if utils not loaded
	return tostring(data or "")
end

-- Init worker phase: Runs in each worker process (workers only, not manager).
-- Used for worker-specific initialization like ClamAV connectivity checks.
-- Also handles cache cleanup with distributed locking to ensure only one worker cleans.
function malware_scan:init_worker()
	-- Log entry into init_worker for diagnostics
	self.logger:log(NOTICE, "[INIT_WORKER] Entering init_worker phase for malware-scan v" .. VERSION)

	local init_needed, err = has_variable("USE_MALWARE_SCANNER", "yes")
	if init_needed == nil then
		self.logger:log(ERR, "[INIT_WORKER] Failed to check USE_MALWARE_SCANNER: " .. err)
		return self:ret(false, "can't check USE_MALWARE_SCANNER variable : " .. err)
	end

	-- Check if initialization is needed
	if not init_needed then
		self.logger:log(NOTICE, "[INIT_WORKER] Malware scanner disabled - skipping worker initialization")
		self.logger:log(NOTICE, "[INIT_WORKER] (Cleanup handled by manager process in init phase)")
		return self:ret(true, "init_worker not needed (disabled)")
	end

	if self.is_loading then
		self.logger:log(NOTICE, "[INIT_WORKER] Skipping - plugin is in loading phase")
		return self:ret(true, "init_worker not needed (loading)")
	end

	self.logger:log(NOTICE, "[INIT_WORKER] Malware scanning enabled - proceeding with initialization")

	-- Load, validate, and dump configuration using config module
	if ms_config_load_ok and ms_config then
		local module_status = {
			clamav = clamav,
			cache = cache,
			file_ops = file_ops,
			virustotal = virustotal,
			sentinelone = sentinelone,
			webhook = webhook,
		}
		local cfg_ok, cfg_err = ms_config.load_validate_and_dump(self, module_status)
		if not cfg_ok then
			return self:ret(false, cfg_err)
		end
	else
		-- Fallback if config module not loaded (log basic info only)
		self.logger:log(WARN, "[INIT_WORKER] Config module not loaded - using fallback configuration logging")
		self.logger:log(NOTICE, "[INIT_WORKER] USE_MALWARE_SCANNER = " .. (self.variables["USE_MALWARE_SCANNER"] or "(not set)"))
		self.logger:log(NOTICE, "[INIT_WORKER] MALWARE_SCAN_CLAMAV_ENABLED = " .. (self.variables["MALWARE_SCAN_CLAMAV_ENABLED"] or "(not set)"))
	end

	-- Test ClamAV connectivity if ClamAV scanning is enabled
	if clamav and self.variables["MALWARE_SCAN_CLAMAV_ENABLED"] == "yes" then
		local clamav_host = self.variables["MALWARE_SCAN_CLAMAV_HOST"]
		local clamav_port = self.variables["MALWARE_SCAN_CLAMAV_PORT"]

		self.logger:log(NOTICE, "[INIT_WORKER] Testing ClamAV connectivity to " .. clamav_host .. ":" .. clamav_port .. " (timeout: 2s)")

		local test_ok, test_err = clamav.test_connectivity(self, 2000)
		if not test_ok then
			self.logger:log(ERR, "[INIT_WORKER] ClamAV connectivity test FAILED: " .. test_err)
			return self:ret(false, "ClamAV connectivity test failed: " .. test_err)
		end

		self.logger:log(NOTICE, "[INIT_WORKER] âœ“ ClamAV connectivity test PASSED - Worker ready for malware scanning")
	else
		self.logger:log(NOTICE, "[INIT_WORKER] ClamAV scanning disabled or module not loaded - skipping connectivity test")
	end

	-- Cache cleanup with distributed locking (only first worker performs cleanup)
	-- Check if any cleanup flag is enabled (granular or master switch)
	local cleanup_enabled = self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ALL"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_CLAMAV"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_VIRUSTOTAL"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_SENTINELONE"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_MALWAREBAZAAR"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV4"] == "yes"
		or self.variables["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV6"] == "yes"

	if cleanup_enabled then
		if cache then
			-- Try to acquire distributed lock
			local lock_acquired = cache.try_acquire_cleanup_lock(self)
			if lock_acquired then
				self.logger:log(NOTICE, "[CACHE_CLEANUP] Lock acquired - this worker will perform cleanup")
				local cleanup_ok = cache.cleanup_all(self)
				if not cleanup_ok then
					self.logger:log(WARN, "[CACHE_CLEANUP] Cache cleanup encountered errors")
				else
					self.logger:log(NOTICE, "[CACHE_CLEANUP] Cache cleanup completed successfully")
				end
				-- Release lock
				cache.release_cleanup_lock(self)
			else
				self.logger:log(NOTICE, "[CACHE_CLEANUP] Another worker is handling cleanup - skipping")
			end
		else
			self.logger:log(WARN, "[CACHE_CLEANUP] Cache cleanup requested but cache module not loaded")
		end
	end

	-- Cleanup orphaned files (workers only - they handle uploads)
	if self.variables["MALWARE_SCAN_CLEANUP_ORPHANED"] == "yes" and file_ops then
		local cleanup_age = tonumber(self.variables["MALWARE_SCAN_CLEANUP_AGE"]) or 3600
		local cleanup_ok, cleanup_err = file_ops.orphan_cleanup(self, cleanup_age)
		if not cleanup_ok then
			self.logger:log(
				WARN,
				"failed to cleanup orphaned files: " .. cleanup_err
			)
		end
	end

	-- Initialize UI metrics to 0 so UI has data to display even before first scan
	self:set_metric("counter_malware_detected", 0)
	self:set_metric("counter_files_scanned", 0)
	self:set_metric("counter_cache_hits", 0)
	self.logger:log(NOTICE, "[INIT_WORKER] Initialized UI metrics counters")

	return self:ret(true, "success")
end

-- Access phase handler - scan uploaded files for malware.
-- Checks for file uploads, scans with ClamAV and/or VirusTotal, and blocks infected files.
function malware_scan:access()
	self:log_debug("=== MALWARE-SCAN ACCESS PHASE CALLED ===")
	self:log_debug("Request: " .. tostring(self.ctx.bw.uri) .. " Method: " .. tostring(self.ctx.bw.request_method))
	self:log_debug("Content-Type: " .. tostring(self.ctx.bw.http_content_type))

	-- PERFORMANCE: Check for file upload FIRST before any expensive operations
	-- Exit immediately for non-upload requests to avoid unnecessary processing
	if
		not self.ctx.bw.http_content_type
		or (
			not self.ctx.bw.http_content_type:match("boundary")
			or not self.ctx.bw.http_content_type:match("multipart/form%-data")
		)
	then
		return self:ret(true, "no file upload detected")
	end

	self:log_debug("File upload detected, initializing malware scan")

	-- Initialize Redis connection for MalwareBazaar hash lookups (deferred from initialize phase)
	-- Only do this for actual file uploads to avoid wasteful initialization on GET requests
	local redis_ok, redis_err = database.connect(self)
	if not redis_ok then
		self.logger:log(WARN, "Redis setup failed: " .. (redis_err or "unknown error"))
	end

	-- Pre-scan validation and initialization using orchestrator
	local scan_ctx, early_result
	if ms_orchestrator_load_ok and ms_orchestrator then
		scan_ctx, early_result = ms_orchestrator.pre_scan_validate(self, file_ops, ui_metrics, webhook, get_deny_status)
		if not scan_ctx then
			return early_result
		end
	else
		-- Fallback if orchestrator not loaded (should not happen in production)
		self.logger:log(ERR, "Orchestrator not loaded - using legacy code path")
		return self:ret(false, "orchestrator module not available")
	end

	-- Extract variables from scan context
	local scanner_state = scan_ctx.scanner_state
	local body_file = scan_ctx.body_file
	local checksum = scan_ctx.checksum
	local checksum_ok = scan_ctx.checksum_ok
	local file_size = scan_ctx.file_size
	local detections = scan_ctx.detections

	-- Extract scanner states for compatibility
	local clamav_enabled = scanner_state.clamav
	local virustotal_enabled = scanner_state.virustotal
	local sentinelone_enabled = scanner_state.sentinelone
	local malwarebazaar_enabled = scanner_state.malwarebazaar

	-- Comprehensive cache checking using orchestrator
	local cache_result
	if ms_orchestrator_load_ok and ms_orchestrator then
		cache_result = ms_orchestrator.cache_check_comprehensive(
			self, scan_ctx, cache, webhook, file_ops, ui_metrics, get_deny_status
		)

		-- If blocked by cache, return immediately
		if cache_result.blocked then
			return cache_result.block_result
		end

		-- Update scanner state from cache results
		scanner_state = cache_result.scanner_state
		detections = cache_result.detections

		-- Extract updated scanner states
		clamav_enabled = scanner_state.clamav
		virustotal_enabled = scanner_state.virustotal
		sentinelone_enabled = scanner_state.sentinelone
		malwarebazaar_enabled = scanner_state.malwarebazaar
	else
		-- Fallback if orchestrator not loaded (should not happen in production)
		self.logger:log(ERR, "Orchestrator cache check not available - using legacy code path")
	end

	-- Configure scan limits using orchestrator
	local scan_limits
	if ms_orchestrator_load_ok and ms_orchestrator then
		scan_limits = ms_orchestrator.configure_scan_limits(self, scan_ctx)
	else
		-- Fallback if orchestrator not loaded (should not happen in production)
		self.logger:log(ERR, "Orchestrator configure_scan_limits not available - using legacy code path")
		return self:ret(false, "orchestrator module not available")
	end

	-- Extract configuration from scan limits
	local clamav_actually_scanned = false
	local clamav_skipped_reason = nil

	-- Update scanner state for body scan
	scanner_state = scan_limits.scanner_state
	clamav_enabled = scanner_state.clamav
	virustotal_enabled = scanner_state.virustotal
	sentinelone_enabled = scanner_state.sentinelone
	malwarebazaar_enabled = scanner_state.malwarebazaar

	-- ============================================================================
	-- SCANNER INVOCATION: Orchestrated body scan across all enabled scanners
	-- ============================================================================
	-- Call orchestrator to handle all scanner invocations (MalwareBazaar, ClamAV, VirusTotal, SentinelOne)
	-- This centralizes ~400-500 lines of scanner logic into a single function call

	-- Update scanner state with current enabled flags (may have been disabled by size checks or multipart logic)
	scanner_state.clamav = clamav_enabled
	scanner_state.virustotal = virustotal_enabled
	scanner_state.sentinelone = sentinelone_enabled
	scanner_state.malwarebazaar = malwarebazaar_enabled

	local blocking_result, detected, scan_info
	if ms_orchestrator_load_ok and ms_orchestrator then
		blocking_result, detected, scan_info = ms_orchestrator.body_scan(
			self, body_file, checksum, checksum_ok, file_size,
			scanner_state, detections,
			clamav, virustotal, sentinelone, malwarebazaar,
			cache, webhook, file_ops, get_deny_status
		)

		-- Extract scan info
		clamav_actually_scanned = scan_info.clamav_actually_scanned or clamav_actually_scanned
		clamav_skipped_reason = scan_info.clamav_skipped_reason or clamav_skipped_reason
		checksum = scan_info.checksum
		checksum_ok = scan_info.checksum_ok

		-- If orchestrator returned a blocking result, return it immediately
		if blocking_result then
			return blocking_result
		end
	else
		-- Fallback if orchestrator not loaded (graceful degradation)
		self.logger:log(ERR, "[ORCHESTRATOR] body_scan() not available - scanner invocation disabled")
		detected = "clean"
	end

	-- ============================================================================
	-- POST-SCAN PROCESSING
	-- ============================================================================
	-- From here onwards, all scanners have completed (either clean or resume mode)

	-- Build scan result object for post-scan processing
	local scan_result = {
		detected = detected,
		checksum = checksum,
		checksum_ok = checksum_ok,
		clamav_actually_scanned = clamav_actually_scanned
	}

	-- Call orchestrator for post-scan processing
	if ms_orchestrator_load_ok and ms_orchestrator then
		return ms_orchestrator.post_scan_complete(
			self, scan_ctx, scan_limits, scan_result,
			webhook, file_ops, multipart_full_scan, multipart_full_scan_load_ok, get_deny_status
		)
	else
		-- Fallback if orchestrator not loaded (should not happen in production)
		self.logger:log(ERR, "Orchestrator post_scan_complete not available - using legacy fallback")
		return self:ret(true, "scan complete (orchestrator unavailable)")
	end
end

-- API endpoint handler - delegates to API module
-- Handles test/diagnostic API endpoints (ping, test-eicar, virustotal-ping, etc.)
function malware_scan:api()
	if ms_api then
		return self:ret(ms_api.handle_request(self))
	end
	return self:ret(false, "success")
end

-- ============================================================================
-- SCHEDULED TASKS
-- ============================================================================

-- Scheduler hook: Runs periodically to update MalwareBazaar custom hash database
-- Called by BunkerWeb scheduler at intervals defined by MALWARE_SCAN_CUSTOM_HASHES_UPDATE_INTERVAL
-- Uses smart download with ETag caching to minimize bandwidth usage
function malware_scan:scheduler()
	if ms_scheduler then
		ms_scheduler.run(self)
	end
	return self:ret(true, "success")
end

return malware_scan
