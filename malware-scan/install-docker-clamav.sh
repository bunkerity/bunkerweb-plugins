#!/bin/bash

#############################################################################
# ClamAV Docker Installation Script (Debian & CentOS)
#
# Purpose: Automated installation and configuration of ClamAV using Docker
# Supported: Debian 11+, CentOS 7+, Rocky Linux 8+, AlmaLinux 8+
# Target Directory: /DATA/clamav (default, customizable with --install_dir)
# Container Name: clamav
# TCP Port: 3310
#
# Usage:
#   sudo ./install-docker-clamav.sh
#   sudo ./install-docker-clamav.sh --install_dir=/custom/path
#
# Options:
#   --install_dir=PATH    Custom installation directory (default: /DATA/clamav)
#
# Features:
#   - Auto-detects OS (Debian/CentOS/Rocky/AlmaLinux)
#   - Installs Docker if not present
#   - Creates persistent data directory
#   - Configures memory-optimized ClamAV
#   - Sets up systemd service for auto-start
#   - Tests installation with EICAR
#
#############################################################################

set -e  # Exit on error
set -u  # Exit on undefined variable

# Default Configuration
INSTALL_DIR="/DATA/clamav"
CONTAINER_NAME="clamav"
CLAMAV_IMAGE="clamav/clamav:stable"
CLAMAV_PORT="3310"
MEMORY_LIMIT="4g"  # 4GB required for concurrent database reload (24/7 availability)
LOG_DRIVER="json-file"  # Options: json-file, syslog, journald (json-file is most compatible)
SYSLOG_TAG="clamav"

# ============================================================================
# OS DETECTION
# ============================================================================

# Detect OS type
detect_os() {
    if [[ -f /etc/os-release ]]; then
        . /etc/os-release
        OS_ID="$ID"
        OS_VERSION="${VERSION_ID:-}"
    elif [[ -f /etc/redhat-release ]]; then
        OS_ID="rhel"
        OS_VERSION=$(cat /etc/redhat-release | grep -oP '\d+' | head -1)
    elif [[ -f /etc/debian_version ]]; then
        OS_ID="debian"
        OS_VERSION=$(cat /etc/debian_version | grep -oP '\d+' | head -1)
    else
        OS_ID="unknown"
        OS_VERSION="unknown"
    fi

    # Normalize OS names
    case "$OS_ID" in
        debian|ubuntu)
            OS_TYPE="debian"
            ;;
        centos|rhel|rocky|almalinux|fedora)
            OS_TYPE="rhel"
            ;;
        *)
            OS_TYPE="unknown"
            ;;
    esac
}

# Check if OS is supported
check_os_support() {
    detect_os

    if [[ "$OS_TYPE" == "unknown" ]]; then
        log_error "Unsupported OS: $OS_ID"
        log_error "Supported: Debian 11+, CentOS 7+, Rocky Linux 8+, AlmaLinux 8+"
        exit 1
    fi

    log_info "Detected OS: $OS_ID (Type: $OS_TYPE) Version: $OS_VERSION"
}

# Package manager wrapper for OS-agnostic operations
pkg_update() {
    if [[ "$OS_TYPE" == "debian" ]]; then
        apt-get update -qq
    else
        yum update -y -q 2>/dev/null || dnf update -y -q
    fi
}

pkg_install() {
    local packages="$@"
    if [[ "$OS_TYPE" == "debian" ]]; then
        apt-get install -y -qq $packages
    else
        yum install -y -q $packages 2>/dev/null || dnf install -y -q $packages
    fi
}

# Parse command-line arguments
for arg in "$@"; do
    case $arg in
        --install_dir=*)
            INSTALL_DIR="${arg#*=}"
            ;;
        --help|-h)
            echo "ClamAV Docker Installation Script"
            echo ""
            echo "Usage: sudo $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --install_dir=PATH    Custom installation directory (default: /DATA/clamav)"
            echo "  --help, -h            Show this help message"
            echo ""
            echo "Examples:"
            echo "  sudo $0"
            echo "  sudo $0 --install_dir=/opt/clamav"
            echo "  sudo $0 --install_dir=/home/user/clamav"
            exit 0
            ;;
        *)
            echo "Unknown option: $arg"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root (use sudo)"
        exit 1
    fi
}

# Check system requirements
check_requirements() {
    log_info "Checking system requirements..."

    # Check if OS is supported
    check_os_support

    # Check RAM
    total_ram=$(free -g | awk '/^Mem:/{print $2}')
    if [[ $total_ram -lt 4 ]]; then
        log_warning "System has ${total_ram}GB RAM. Minimum 4GB required for 24/7 ClamAV availability."
        log_warning "(Concurrent database reload requires ~4GB peak memory)"
        read -p "Continue anyway? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    else
        log_success "System has ${total_ram}GB RAM (sufficient)"
    fi

    # Check disk space
    available_space=$(df -BG / | awk 'NR==2 {print $4}' | sed 's/G//')
    if [[ $available_space -lt 5 ]]; then
        log_error "Insufficient disk space. Need at least 5GB, have ${available_space}GB"
        exit 1
    else
        log_success "Disk space: ${available_space}GB available"
    fi
}

# Install Docker if not present
install_docker() {
    if command -v docker &> /dev/null; then
        log_success "Docker already installed ($(docker --version))"
    else
        log_info "Installing Docker..."
        pkg_update
    fi

    # Install netcat if not present (needed for port checking)
    if ! command -v nc &> /dev/null && ! command -v netcat &> /dev/null; then
        log_info "Installing netcat for port checking..."
        if [[ "$OS_TYPE" == "debian" ]]; then
            pkg_install netcat-openbsd
        else
            pkg_install nmap-ncat
        fi
    fi

    # Continue Docker installation if not already present
    if ! command -v docker &> /dev/null; then
        if [[ "$OS_TYPE" == "debian" ]]; then
            # Debian/Ubuntu Docker installation
            log_info "Installing Docker on Debian-based system..."

            # Install prerequisites
            pkg_install ca-certificates curl gnupg lsb-release

            # Add Docker's GPG key
            install -m 0755 -d /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/debian/gpg | \
                gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            chmod a+r /etc/apt/keyrings/docker.gpg

            # Set up Docker repository
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
              https://download.docker.com/linux/debian \
              $(lsb_release -cs) stable" | \
              tee /etc/apt/sources.list.d/docker.list > /dev/null

            # Install Docker Engine
            pkg_update
            pkg_install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

        else
            # CentOS/RHEL/Rocky/AlmaLinux Docker installation
            log_info "Installing Docker on RHEL-based system..."

            # Install prerequisites
            pkg_install yum-utils device-mapper-persistent-data lvm2

            # Add Docker repository
            if command -v yum &> /dev/null; then
                yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo -q 2>/dev/null || true
                pkg_install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            else
                dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 2>/dev/null || true
                pkg_install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            fi
        fi

        # Enable Docker service
        systemctl daemon-reload
        systemctl enable docker
        systemctl start docker

        log_success "Docker installed successfully ($(docker --version))"
    fi
}

# Create installation directory
create_directories() {
    log_info "Creating installation directory: ${INSTALL_DIR}"

    # Create main directory
    mkdir -p "${INSTALL_DIR}"
    mkdir -p "${INSTALL_DIR}/data"
    mkdir -p "${INSTALL_DIR}/config"
    mkdir -p "${INSTALL_DIR}/logs"

    log_success "Directories created"
}

# Create optimized ClamAV configuration files
create_configs() {
    log_info "Creating ClamAV configuration files..."

    # Create clamd.conf (memory optimized, aligned with install.sh defaults)
    cat > "${INSTALL_DIR}/config/clamd.conf" <<'EOF'
# ClamAV Daemon Configuration
# Memory-optimized for 3-4GB RAM systems
# Aligned with malware-scan plugin defaults

# Network Configuration
TCPSocket 3310
TCPAddr 127.0.0.1

# Performance Settings
MaxThreads 12
MaxConnectionQueueLength 30
ReadTimeout 300
CommandReadTimeout 30
SendBufTimeout 500

# File Size Limits (aligned with plugin: MALWARE_SCAN_CLAMAV_MAX_SIZE=26214400 = 25MB)
MaxScanSize 150M
MaxFileSize 30M
MaxRecursion 16
MaxFiles 10000
MaxEmbeddedPE 10M
MaxHTMLNormalize 10M
MaxHTMLNoTags 2M
MaxScriptNormalize 5M
MaxZipTypeRcg 1M
StreamMaxLength 25M

# Scan Options
ScanPE yes
ScanELF yes
ScanMail yes
ScanArchive yes
ScanHTML yes
ScanOLE2 yes
ScanPDF yes
ScanSWF yes
ScanXMLDOCS yes
ScanHWP3 yes

# IMPORTANT: Disable PUA detection (focus on real malware only)
# This prevents false positives from legitimate software
# and ensures only actual malware is detected and shared
DetectPUA no

# Self-check interval (seconds)
SelfCheck 600

# Idle timeout (seconds)
IdleTimeout 60

# Foreground mode (for Docker)
Foreground yes

# IMPORTANT: Enable concurrent reload for 24/7 availability
# Allows scanning to continue during database updates (no interruption)
# Trade-off: Higher peak RAM usage (~4GB) during database reload
# Ensures ClamAV socket is available 24/7 without downtime
ConcurrentDatabaseReload yes

# Logging (verbose mode for troubleshooting)
LogTime yes
LogVerbose yes
Debug yes
LogClean yes
EOF

    # Create freshclam.conf (memory optimized)
    cat > "${INSTALL_DIR}/config/freshclam.conf" <<'EOF'
# FreshClam Configuration
# Configured for 24/7 availability

# Database Mirror
DatabaseMirror database.clamav.net

# Update frequency (checks per day: 1-50)
# 12 checks per day = every 2 hours (recommended for production)
Checks 12

# Database directory
DatabaseDirectory /var/lib/clamav

# Logging
LogSyslog no
LogVerbose yes
LogTime yes

# Connection settings
ConnectTimeout 30
ReceiveTimeout 60

# Database testing enabled for reliability
# Ensures database integrity before loading
TestDatabases yes

# Bytecode
Bytecode yes

# Foreground mode (for Docker)
Foreground yes
EOF

    # Create docker-compose.yml for easier management
    cat > "${INSTALL_DIR}/docker-compose.yml" <<EOF
version: '3.8'

services:
  clamav:
    image: ${CLAMAV_IMAGE}
    container_name: ${CONTAINER_NAME}
    restart: unless-stopped
    ports:
      - "${CLAMAV_PORT}:3310"
    volumes:
      - ${INSTALL_DIR}/data:/var/lib/clamav
      - ${INSTALL_DIR}/config/clamd.conf:/etc/clamav/clamd.conf:ro
      - ${INSTALL_DIR}/config/freshclam.conf:/etc/clamav/freshclam.conf:ro
    logging:
      driver: syslog
      options:
        syslog-address: "unix:///dev/log"
        tag: "${SYSLOG_TAG}"
        syslog-facility: "daemon"
    environment:
      - CLAMAV_NO_FRESHCLAMD=false
      - CLAMD_STARTUP_TIMEOUT=1800
      - FRESHCLAM_CHECKS=12  # 12 checks per day = every 2 hours
    deploy:
      resources:
        limits:
          memory: ${MEMORY_LIMIT}
        reservations:
          memory: 2g
    healthcheck:
      test: ["CMD", "sh", "-c", "echo PING | nc localhost 3310 | grep PONG"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 300s
EOF

    log_success "Configuration files created"
}

# Pull ClamAV Docker image
pull_image() {
    log_info "Pulling ClamAV Docker image: ${CLAMAV_IMAGE}"
    docker pull ${CLAMAV_IMAGE}
    log_success "Image pulled successfully"
}

# Check if ClamAV is already running on target port
check_port_availability() {
    log_info "Checking if port ${CLAMAV_PORT} is available..."

    # Check if port is in use
    if command -v netcat &> /dev/null || command -v nc &> /dev/null; then
        # Use netcat to check port
        if nc -z localhost ${CLAMAV_PORT} 2>/dev/null; then
            # Port is in use - test if it's ClamAV
            local response=$(echo "PING" | nc -w 2 localhost ${CLAMAV_PORT} 2>/dev/null || echo "")

            if echo "$response" | grep -q "PONG"; then
                log_warning "ClamAV is already running on port ${CLAMAV_PORT}"
                log_info "Testing existing ClamAV daemon..."

                # Test with EICAR to verify it's working
                if echo 'X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*' | nc -w 5 localhost ${CLAMAV_PORT} 2>/dev/null | grep -q "FOUND"; then
                    log_success "Existing ClamAV daemon is working correctly"
                    log_info "No installation needed - ClamAV is already operational"
                    log_info ""
                    log_info "If you want to reinstall, first stop the existing daemon:"
                    log_info "  - For Docker: docker stop clamav && docker rm clamav"
                    log_info "  - For systemd: systemctl stop clamav-daemon && systemctl disable clamav-daemon"
                    log_info "    (Note: Disable prevents auto-start on reboot)"
                    log_info ""
                    exit 0
                else
                    log_warning "Port ${CLAMAV_PORT} responds to PING but may not be working correctly"
                    read -p "Continue with installation anyway? (y/N): " -n 1 -r
                    echo
                    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                        exit 1
                    fi
                fi
            else
                log_error "Port ${CLAMAV_PORT} is in use but not responding as ClamAV"
                log_error "Please free up port ${CLAMAV_PORT} before continuing"
                log_info "Check what's using the port with: sudo netstat -tlnp | grep ${CLAMAV_PORT}"
                exit 1
            fi
        else
            log_success "Port ${CLAMAV_PORT} is available"
        fi
    else
        # Netcat not available - install it now for better port checking
        log_info "Netcat not found, installing for better port checking..."
        apt-get update -qq
        apt-get install -y -qq netcat-openbsd
        log_success "Netcat installed"

        # Now check port again with netcat
        if nc -z localhost ${CLAMAV_PORT} 2>/dev/null; then
            # Port is in use - test if it's ClamAV
            local response=$(echo "PING" | nc -w 2 localhost ${CLAMAV_PORT} 2>/dev/null || echo "")

            if echo "$response" | grep -q "PONG"; then
                log_warning "ClamAV is already running on port ${CLAMAV_PORT}"
                log_info "Testing existing ClamAV daemon..."

                # Test with EICAR to verify it's working
                if echo 'X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*' | nc -w 5 localhost ${CLAMAV_PORT} 2>/dev/null | grep -q "FOUND"; then
                    log_success "Existing ClamAV daemon is working correctly"
                    log_info "No installation needed - ClamAV is already operational"
                    log_info ""
                    log_info "If you want to reinstall, first stop the existing daemon:"
                    log_info "  - For Docker: docker stop clamav && docker rm clamav"
                    log_info "  - For systemd: systemctl stop clamav-daemon && systemctl disable clamav-daemon"
                    log_info "    (Note: Disable prevents auto-start on reboot)"
                    log_info ""
                    exit 0
                else
                    log_warning "Port ${CLAMAV_PORT} responds to PING but may not be working correctly"
                    read -p "Continue with installation anyway? (y/N): " -n 1 -r
                    echo
                    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                        exit 1
                    fi
                fi
            else
                log_error "Port ${CLAMAV_PORT} is in use but not responding as ClamAV"
                log_error "Please free up port ${CLAMAV_PORT} before continuing"
                log_info "Check what's using the port with: sudo netstat -tlnp | grep ${CLAMAV_PORT}"
                exit 1
            fi
        else
            log_success "Port ${CLAMAV_PORT} is available"
        fi
    fi
}

# Stop and remove existing container if present
cleanup_existing() {
    if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        log_warning "Existing ClamAV container found, removing..."
        docker stop ${CONTAINER_NAME} 2>/dev/null || true
        docker rm ${CONTAINER_NAME} 2>/dev/null || true
        log_success "Existing container removed"
    fi
}

# Start ClamAV container
start_container() {
    log_info "Starting ClamAV container..."

    cd "${INSTALL_DIR}"

    # Build logging options based on LOG_DRIVER
    local log_opts=""
    if [[ "${LOG_DRIVER}" == "syslog" ]]; then
        log_opts="--log-driver=syslog --log-opt syslog-address=unix:///dev/log --log-opt tag=${SYSLOG_TAG}"
        log_info "Using syslog logging driver (logs will go to host syslog, not 'docker logs')"
    elif [[ "${LOG_DRIVER}" == "journald" ]]; then
        log_opts="--log-driver=journald --log-opt tag=${SYSLOG_TAG}"
        log_info "Using journald logging driver (view with 'journalctl -t ${SYSLOG_TAG}')"
    else
        log_opts="--log-driver=json-file"
        log_info "Using json-file logging driver (default, view with 'docker logs')"
    fi

    docker run -d \
        --name ${CONTAINER_NAME} \
        --restart unless-stopped \
        --memory="${MEMORY_LIMIT}" \
        --memory-swap="${MEMORY_LIMIT}" \
        -p ${CLAMAV_PORT}:3310 \
        -v "${INSTALL_DIR}/data:/var/lib/clamav" \
        -v "${INSTALL_DIR}/config/clamd.conf:/etc/clamav/clamd.conf:ro" \
        -v "${INSTALL_DIR}/config/freshclam.conf:/etc/clamav/freshclam.conf:ro" \
        ${log_opts} \
        -e CLAMAV_NO_FRESHCLAMD=false \
        -e CLAMD_STARTUP_TIMEOUT=1800 \
        -e FRESHCLAM_CHECKS=12 \
        ${CLAMAV_IMAGE}

    log_success "Container started successfully"
}

# Wait for ClamAV to be ready
wait_for_clamav() {
    log_info "Waiting for ClamAV to download signature databases..."
    log_info "This may take 10-30 minutes on first run..."

    local max_wait=1800  # 30 minutes
    local elapsed=0
    local check_interval=10

    while [[ $elapsed -lt $max_wait ]]; do
        # Check if clamd is ready by testing PING command
        if echo "PING" | nc -w 2 localhost ${CLAMAV_PORT} 2>/dev/null | grep -q "PONG"; then
            log_success "ClamAV is ready!"
            return 0
        fi

        # Check if container crashed
        if ! docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
            log_error "Container stopped unexpectedly"
            log_info "Check logs with: ${LOG_DRIVER == syslog && 'sudo journalctl -t ${SYSLOG_TAG} -n 50' || 'docker logs --tail 50 ${CONTAINER_NAME}'}"
            return 1
        fi

        # Show progress every minute
        if [[ $((elapsed % 60)) -eq 0 ]] && [[ $elapsed -gt 0 ]]; then
            log_info "Still waiting... (${elapsed}s elapsed)"
        fi

        sleep $check_interval
        elapsed=$((elapsed + check_interval))
    done

    log_error "Timeout waiting for ClamAV to start"
    return 1
}

# Test ClamAV installation
test_installation() {
    log_info "Testing ClamAV installation..."

    # Test 1: TCP connection
    log_info "Test 1: TCP connection to port ${CLAMAV_PORT}"
    if echo "PING" | nc -w 5 localhost ${CLAMAV_PORT} | grep -q "PONG"; then
        log_success "TCP connection test passed"
    else
        log_error "TCP connection test failed"
        return 1
    fi

    # Test 2: EICAR test file
    log_info "Test 2: EICAR malware detection"

    # Create EICAR test file
    local eicar_file="${INSTALL_DIR}/eicar.txt"
    echo 'X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*' > "${eicar_file}"

    # Scan using clamdscan inside container
    if docker exec ${CONTAINER_NAME} clamdscan /tmp/eicar.txt 2>&1 | grep -q "Eicar.*FOUND"; then
        log_success "EICAR detection test passed"
    else
        # Try alternative method: pipe to container
        if cat "${eicar_file}" | docker exec -i ${CONTAINER_NAME} clamdscan - 2>&1 | grep -q "Eicar.*FOUND"; then
            log_success "EICAR detection test passed"
        else
            log_warning "EICAR detection test inconclusive (may still be working)"
        fi
    fi

    # Clean up test file
    rm -f "${eicar_file}"

    # Test 3: Database info
    log_info "Test 3: Checking signature database"
    local db_count=$(docker exec ${CONTAINER_NAME} sigtool --info=/var/lib/clamav/main.cvd 2>/dev/null | grep "Signatures:" | awk '{print $2}' || echo "0")
    if [[ $db_count -gt 0 ]]; then
        log_success "Signature database loaded (${db_count} signatures)"
    else
        log_warning "Could not verify signature count"
    fi

    log_success "Installation tests completed"
}

# Create systemd service for auto-start
create_systemd_service() {
    log_info "Creating systemd service for auto-start..."

    cat > /etc/systemd/system/clamav-docker.service <<EOF
[Unit]
Description=ClamAV Docker Container
Requires=docker.service
After=docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/bin/docker start ${CONTAINER_NAME}
ExecStop=/usr/bin/docker stop ${CONTAINER_NAME}
TimeoutStartSec=0

[Install]
WantedBy=multi-user.target
EOF

    # Reload systemd and enable service
    systemctl daemon-reload
    systemctl enable clamav-docker.service

    log_success "Systemd service created and enabled"
}

# Create helper scripts
create_helper_scripts() {
    log_info "Creating helper scripts..."

    # Create start script
    cat > "${INSTALL_DIR}/start.sh" <<'EOF'
#!/bin/bash
docker start clamav && echo "ClamAV started"
EOF
    chmod +x "${INSTALL_DIR}/start.sh"

    # Create stop script
    cat > "${INSTALL_DIR}/stop.sh" <<'EOF'
#!/bin/bash
docker stop clamav && echo "ClamAV stopped"
EOF
    chmod +x "${INSTALL_DIR}/stop.sh"

    # Create restart script
    cat > "${INSTALL_DIR}/restart.sh" <<'EOF'
#!/bin/bash
docker restart clamav && echo "ClamAV restarted"
EOF
    chmod +x "${INSTALL_DIR}/restart.sh"

    # Create logs script (adapts based on logging driver)
    if [[ "${LOG_DRIVER}" == "syslog" ]] || [[ "${LOG_DRIVER}" == "journald" ]]; then
        cat > "${INSTALL_DIR}/logs.sh" <<EOF
#!/bin/bash
# ClamAV logs are sent to syslog
echo "=== ClamAV Logs (from syslog) ==="
sudo journalctl -t ${SYSLOG_TAG} -f
EOF
    else
        cat > "${INSTALL_DIR}/logs.sh" <<'EOF'
#!/bin/bash
docker logs -f clamav
EOF
    fi
    chmod +x "${INSTALL_DIR}/logs.sh"

    # Create status script
    cat > "${INSTALL_DIR}/status.sh" <<'EOF'
#!/bin/bash
echo "=== Container Status ==="
docker ps -a | grep clamav

echo -e "\n=== Memory Usage ==="
docker stats --no-stream clamav

echo -e "\n=== TCP Connection Test ==="
if echo "PING" | nc -w 5 localhost 3310 | grep -q "PONG"; then
    echo "✅ ClamAV is responding on port 3310"
else
    echo "❌ ClamAV is not responding on port 3310"
fi

echo -e "\n=== Recent Logs ==="
docker logs --tail 20 clamav
EOF
    chmod +x "${INSTALL_DIR}/status.sh"

    # Create update script
    cat > "${INSTALL_DIR}/update.sh" <<EOF
#!/bin/bash
echo "Updating ClamAV Docker image..."
docker pull clamav/clamav:stable
echo "Recreating container with new image..."
docker stop clamav
docker rm clamav
cd "${INSTALL_DIR}"
docker-compose up -d
echo "Update completed"
EOF
    chmod +x "${INSTALL_DIR}/update.sh"

    log_success "Helper scripts created in ${INSTALL_DIR}/"
}

# Print installation summary
print_summary() {
    echo
    echo "========================================"
    log_success "ClamAV Docker Installation Complete!"
    echo "========================================"
    echo
    echo "Installation Directory: ${INSTALL_DIR}"
    echo "Container Name: ${CONTAINER_NAME}"
    echo "TCP Port: ${CLAMAV_PORT}"
    echo "Memory Limit: ${MEMORY_LIMIT}"
    echo
    echo "Configuration Files:"
    echo "  - ${INSTALL_DIR}/config/clamd.conf"
    echo "  - ${INSTALL_DIR}/config/freshclam.conf"
    echo "  - ${INSTALL_DIR}/docker-compose.yml"
    echo
    echo "Data Directory: ${INSTALL_DIR}/data"
    echo
    echo "Logging Configuration:"
    if [[ "${LOG_DRIVER}" == "syslog" ]]; then
        echo "  Driver: syslog (logs sent to host syslog)"
        echo "  Tag: ${SYSLOG_TAG}"
        echo "  View logs: sudo journalctl -t ${SYSLOG_TAG} -f"
        echo "  Note: 'docker logs' will NOT work with syslog driver"
        echo "  Warning: syslog driver may fail on some systems - use json-file if issues occur"
    elif [[ "${LOG_DRIVER}" == "journald" ]]; then
        echo "  Driver: journald (logs sent to systemd journal)"
        echo "  Tag: ${SYSLOG_TAG}"
        echo "  View logs: sudo journalctl -t ${SYSLOG_TAG} -f"
    else
        echo "  Driver: json-file (default, most compatible)"
        echo "  View logs: docker logs -f clamav"
    fi
    echo
    echo "Helper Scripts:"
    echo "  - ${INSTALL_DIR}/start.sh       - Start ClamAV"
    echo "  - ${INSTALL_DIR}/stop.sh        - Stop ClamAV"
    echo "  - ${INSTALL_DIR}/restart.sh     - Restart ClamAV"
    echo "  - ${INSTALL_DIR}/logs.sh        - View logs"
    echo "  - ${INSTALL_DIR}/status.sh      - Check status"
    echo "  - ${INSTALL_DIR}/update.sh      - Update ClamAV"
    echo
    echo "Quick Commands:"
    if [[ "${LOG_DRIVER}" == "syslog" ]] || [[ "${LOG_DRIVER}" == "journald" ]]; then
        echo "  View logs:     sudo journalctl -t ${SYSLOG_TAG} -f"
    else
        echo "  View logs:     docker logs -f ${CONTAINER_NAME}"
    fi
    echo "  Check status:  docker ps | grep ${CONTAINER_NAME}"
    echo "  Test PING:     echo PING | nc localhost ${CLAMAV_PORT}"
    echo "  Stop:          docker stop ${CONTAINER_NAME}"
    echo "  Start:         docker start ${CONTAINER_NAME}"
    echo
    echo "ClamAV Configuration:"
    echo "  - DetectPUA: disabled (real malware only)"
    echo "  - LogVerbose: enabled (detailed scanning logs)"
    echo "  - Debug: enabled (daemon debugging)"
    echo "  - LogClean: enabled (logs clean files)"
    echo "  - StreamMaxLength: 25MB (matches plugin default)"
    echo "  - ConcurrentDatabaseReload: enabled (24/7 availability, no scanning interruption)"
    echo "  - FreshClam Checks: 12 per day (every 2 hours)"
    echo "  - TestDatabases: enabled (database integrity checking)"
    echo
    echo "BunkerWeb Integration:"
    echo "  USE_MALWARE_SCANNER=yes"
    echo "  MALWARE_SCAN_CLAMAV_ENABLED=yes"
    echo "  MALWARE_SCAN_CLAMAV_HOST=localhost"
    echo "  MALWARE_SCAN_CLAMAV_PORT=${CLAMAV_PORT}"
    echo "  MALWARE_SCAN_CLAMAV_TIMEOUT=10000"
    echo "  MALWARE_SCAN_CLAMAV_MAX_SIZE=26214400  # 25MB, must match StreamMaxLength"
    echo
    echo "========================================"
}

# Main installation flow
main() {
    echo "========================================"
    echo "  ClamAV Docker Installation Script"
    echo "  Target: ${INSTALL_DIR}"
    echo "========================================"
    echo

    check_root
    check_requirements
    check_port_availability
    install_docker
    create_directories
    create_configs
    pull_image
    cleanup_existing
    start_container
    wait_for_clamav
    test_installation
    create_systemd_service
    create_helper_scripts
    print_summary
}

# Run main installation
main "$@"
