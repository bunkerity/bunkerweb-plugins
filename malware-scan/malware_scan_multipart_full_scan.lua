-- BunkerWeb Malware Scan - Multipart Full Scan Module
-- Handles multipart parsing and per-file scanning when resume mode is enabled
-- Only activates when MALWARE_SCAN_RESUME_SCAN_ON_FIRST_HIT=yes
-- Provides comprehensive threat intelligence by scanning all files before blocking

local logger = require("malware_scan_logger")
local ngx = ngx
local get_deny_status = require("bunkerweb.utils").get_deny_status
local utils = require("malware_scan_utils")
local orchestrator = require("malware_scan_orchestrator")

-- Module table
local multipart_full_scan = {}

-- Module version
multipart_full_scan.VERSION = "0.8.0"

-- Module dependencies (set via setters)
local cache = nil
local file_ops = nil
local clamav = nil
local virustotal = nil
local sentinelone = nil
local malwarebazaar = nil
local webhook = nil

-- Setter functions for module dependencies
function multipart_full_scan.set_cache_module(cache_module)
	cache = cache_module
end

function multipart_full_scan.set_file_ops_module(file_ops_module)
	file_ops = file_ops_module
end

function multipart_full_scan.set_clamav_module(clamav_module)
	clamav = clamav_module
end

function multipart_full_scan.set_virustotal_module(vt_module)
	virustotal = vt_module
end

function multipart_full_scan.set_sentinelone_module(s1_module)
	sentinelone = s1_module
end

function multipart_full_scan.set_malwarebazaar_module(mbz_module)
	malwarebazaar = mbz_module
end

function multipart_full_scan.set_webhook_module(webhook_module)
	webhook = webhook_module
end

-- No longer need internal parsing functions - we'll use file_ops.multipart_parse()

-- Scan a single file with all enabled scanners
-- Scanner execution order optimized for performance:
--   1. MalwareBazaar (fastest: ~1ms Redis lookup, 1M+ hashes, blocks immediately)
--   2. ClamAV (local scan: 100-1000ms, no API costs)
--   3. VirusTotal (API call: 100-500ms, 70+ engines, paid)
--   4. SentinelOne (API call: 100-500ms, enterprise AV, paid)
--- @return table detections Table of detections (empty if clean), keyed by scanner name
local function multipart_full_scan_scan_individual_file(plugin, temp_file, file_checksum, file_size, filename, enabled_scanners)
	local file_detections = {}

	-- Sanitize filename for safe logging (prevent log injection)
	local safe_filename = utils.log_sanitize(filename)

	-- 1. Scan with MalwareBazaar if enabled (FASTEST - run first!)
	logger.log_error( string.format("[v%s] [MULTIPART_SCAN_DEBUG] MalwareBazaar check: enabled=%s, checksum=%s, checksum_empty=%s",
		multipart_full_scan.VERSION, tostring(enabled_scanners.malwarebazaar), tostring(file_checksum ~= nil), tostring(file_checksum == "empty_file")))

	if enabled_scanners.malwarebazaar and file_checksum and file_checksum ~= "empty_file" then
		logger.log_error( string.format("[v%s] [MULTIPART_SCAN_DEBUG] Entering MalwareBazaar scan for %s", multipart_full_scan.VERSION, safe_filename))

		-- Check cache first
		local mbz_cached = nil
		if cache then
			local cache_ok, cached_result, cached_size = cache.malwarebazaar_check(plugin, file_checksum, file_size)
			if cache_ok and cached_result and orchestrator.result_is_malware(cached_result) then
				logger.log_error( "[MULTIPART] MalwareBazaar cache hit for " .. safe_filename .. ": " .. cached_result)
				file_detections["MalwareBazaar (cached)"] = cached_result
				mbz_cached = cached_result
			end
		end

		-- If not in cache, query MalwareBazaar
		if not mbz_cached and malwarebazaar then
			logger.log_error( string.format("[v%s] [MULTIPART_SCAN_DEBUG] Calling malwarebazaar.check_malwarebazaar for %s", multipart_full_scan.VERSION, safe_filename))
			local mbz_ok, mbz_result = malwarebazaar.check_malwarebazaar(plugin, file_checksum, file_size)
			logger.log_error( string.format("[v%s] [MULTIPART_SCAN_DEBUG] MalwareBazaar result: ok=%s, result=%s", multipart_full_scan.VERSION, tostring(mbz_ok), tostring(mbz_result)))

			if mbz_ok and mbz_result and orchestrator.result_is_malware(mbz_result) then
				logger.log_error( "[MULTIPART] MalwareBazaar detected malware in " .. safe_filename .. ": " .. mbz_result)
				file_detections["MalwareBazaar"] = mbz_result

				-- Cache the result
				if cache then
					cache.malwarebazaar_add(plugin, file_checksum, mbz_result, file_size)
				end
			end
		elseif not mbz_cached and not malwarebazaar then
			logger.log_error( string.format("[v%s] [MULTIPART_SCAN_DEBUG] MalwareBazaar module not loaded!", multipart_full_scan.VERSION))
		end
	else
		logger.log_error( string.format("[v%s] [MULTIPART_SCAN_DEBUG] Skipping MalwareBazaar: condition failed", multipart_full_scan.VERSION))
	end

	-- 2. Scan with ClamAV if enabled (local, no API costs)
	if enabled_scanners.clamav then
		-- Check cache first
		local file_cached = nil
		if file_checksum and file_checksum ~= "empty_file" and cache then
			local cache_ok, cached_result, cached_size = cache.clamav_check(plugin, file_checksum, file_size)
			if cache_ok and cached_result and orchestrator.result_is_malware(cached_result) then
				logger.log_error( "[MULTIPART] ClamAV cache hit for " .. safe_filename .. ": " .. cached_result)
				file_detections["ClamAV (cached)"] = cached_result
				file_cached = cached_result
			end
		end

		-- If not in cache, scan with ClamAV
		if not file_cached and clamav then
			local scan_ok, scan_result = clamav.scan_file_instream(plugin, temp_file)
			if scan_ok and scan_result and orchestrator.result_is_malware(scan_result) then
				logger.log_error( "[MULTIPART] ClamAV detected malware in " .. safe_filename .. ": " .. scan_result)
				file_detections["ClamAV"] = scan_result

				-- Cache the result
				if file_checksum and file_checksum ~= "empty_file" and cache then
					cache.clamav_add(plugin, file_checksum, scan_result, file_size)
				end
			end
		end
	end

	-- 3. Scan with VirusTotal if enabled (paid API)
	if enabled_scanners.virustotal and file_checksum and file_checksum ~= "empty_file" then
		-- Check cache first
		local vt_cached = nil
		if cache then
			local cache_ok, cached_result = cache.is_in_virustotal_cache(plugin, file_checksum)
			if cache_ok and cached_result and orchestrator.result_is_malware(cached_result) then
				logger.log_error( "[MULTIPART] VirusTotal cache hit for " .. safe_filename .. ": " .. cached_result)
				file_detections["VirusTotal (cached)"] = cached_result
				vt_cached = cached_result
			end
		end

		-- If not in cache, query VirusTotal
		if not vt_cached and virustotal then
			local vt_ok, vt_result = virustotal.check_hash(plugin, file_checksum, file_size)
			if vt_ok and vt_result and orchestrator.result_is_malware(vt_result) then
				logger.log_error( "[MULTIPART] VirusTotal detected malware in " .. safe_filename .. ": " .. vt_result)
				file_detections["VirusTotal"] = vt_result

				-- Cache the result
				if cache then
					cache.virustotal_add(plugin, file_checksum, vt_result)
				end
			end
		end
	end

	-- 4. Scan with SentinelOne if enabled (paid API)
	if enabled_scanners.sentinelone and file_checksum and file_checksum ~= "empty_file" then
		-- Check cache first
		local s1_cached = nil
		if cache then
			local cache_ok, cached_result = cache.is_in_sentinelone_cache(plugin, file_checksum)
			if cache_ok and cached_result and orchestrator.result_is_malware(cached_result) then
				logger.log_error( "[MULTIPART] SentinelOne cache hit for " .. safe_filename .. ": " .. cached_result)
				file_detections["SentinelOne (cached)"] = cached_result
				s1_cached = cached_result
			end
		end

		-- If not in cache, query SentinelOne
		if not s1_cached and sentinelone then
			local s1_ok, s1_result = sentinelone.check_hash(plugin, file_checksum, file_size)
			if s1_ok and s1_result and orchestrator.result_is_malware(s1_result) then
				logger.log_error( "[MULTIPART] SentinelOne detected malware in " .. safe_filename .. ": " .. s1_result)
				file_detections["SentinelOne"] = s1_result

				-- Cache the result
				if cache then
					cache.sentinelone_add(plugin, file_checksum, s1_result)
				end
			end
		end
	end

	return file_detections
end

-- Main function: Parse multipart upload and scan each individual file
-- Called from main plugin when resume mode is enabled
--- @return boolean success True to continue, false to block
--- @return string|nil message Block message if success=false
--- @return number|nil status HTTP status code if blocking
--- @return table|nil data Block response data if blocking
function multipart_full_scan.scan_multipart_files(plugin, body_file, checksum, detections, enabled_scanners)
	-- Check if multipart scanning is possible
	if not plugin.ctx.bw.http_content_type or
	   not plugin.ctx.bw.http_content_type:match("multipart/form%-data") then
		logger.log_error( "[MULTIPART] Not multipart/form-data, skipping per-file scan")
		return true, nil, nil, nil
	end

	-- Check if file_ops module is available
	if not file_ops then
		logger.log_error( "[MULTIPART] file_ops module not loaded, cannot parse multipart uploads")
		return true, nil, nil, nil
	end

	logger.log_error( "[MULTIPART] Starting per-file scanning in resume mode")

	-- Use file_ops to parse multipart upload (includes security validation)
	local parse_ok, files_or_err, attack_indicator = file_ops.multipart_parse(plugin, body_file, plugin.ctx.bw.http_content_type)
	if not parse_ok then
		-- Check if this is a security attack (malicious filename detected)
		if files_or_err and files_or_err:match("malicious filename detected") then
			logger.log_error( "[MULTIPART] SECURITY ALERT: " .. files_or_err)
			-- Return error to trigger immediate blocking
			return false,
			       files_or_err,
			       get_deny_status(),
			       {
			       	id = "malicious_filename_attack",
			       	file = body_file,
			       	error = files_or_err
			       }
		end

		logger.log_error( "[MULTIPART] Failed to parse multipart upload: " .. tostring(files_or_err))
		return true, nil, nil, nil
	end

	local files = files_or_err
	logger.log_error( "[MULTIPART] Parsed " .. #files .. " file(s) from multipart upload")

	-- Track if filename attack was detected (will block after full scan)
	local filename_attack_detected = (attack_indicator == "filename_attack_detected")

	-- Track per-file detections
	local per_file_detections = {}
	local files_scanned = 0

	-- Scan each extracted file
	for _, file_info in ipairs(files) do
		local filename = file_info.filename
		local temp_file = file_info.filepath
		local file_size = file_info.size
		local file_type = file_info.file_type or "unknown"

		-- Sanitize filename for logging (prevent log injection)
		local safe_filename = utils.log_sanitize(filename)
		logger.log_error( "[MULTIPART] Processing file: " .. safe_filename .. " (size: " .. file_size .. " bytes, type: " .. file_type .. ")")
		files_scanned = files_scanned + 1

		-- Calculate SHA256 for this file
		local file_checksum, file_checksum_ok
		if file_ops then
			file_checksum_ok, file_checksum = file_ops.hash_calculate(plugin, temp_file)
		else
			file_checksum_ok, file_checksum = false, nil
		end

		if file_checksum_ok and file_checksum and file_checksum ~= "empty_file" then
			logger.log_error( "[MULTIPART] File SHA256: " .. file_checksum)
		end

		-- DEBUG: Log checksum status and enabled scanners for MalwareBazaar
		logger.log_error( string.format("[v%s] [MULTIPART_SCAN_DEBUG] file_checksum_ok=%s, file_checksum=%s, enabled_scanners.malwarebazaar=%s",
			multipart_full_scan.VERSION, tostring(file_checksum_ok), tostring(file_checksum), tostring(enabled_scanners.malwarebazaar)))

		-- Scan this file with all enabled scanners
		local file_detections = multipart_full_scan_scan_individual_file(
			plugin,
			temp_file,
			file_checksum,
			file_size,
			filename,
			enabled_scanners
		)

		-- Store per-file detections if any
		if next(file_detections) ~= nil then
			per_file_detections[filename] = {
				checksum = file_checksum,
				detections = file_detections,
				size = file_size,
				file_type = file_type
			}
		end

		-- Cleanup temp file
		if file_ops then
			file_ops.file_cleanup(plugin, temp_file)
		else
			os.remove(temp_file)
		end
	end

	logger.log_error( "[MULTIPART] Scanned " .. files_scanned .. " individual files")

	-- If filename attack or per-file detections exist, return blocking response
	if filename_attack_detected or next(per_file_detections) ~= nil then
		if filename_attack_detected then
			logger.log_error( "[MULTIPART] Filename injection attack detected during parsing - blocking request")
		end
		if next(per_file_detections) ~= nil then
			logger.log_error( "[MULTIPART] Malware detected in individual files - blocking request")
		end

		-- Count total infected files for webhook truncation logic
		local infected_file_count = 0
		for _ in pairs(per_file_detections) do
			infected_file_count = infected_file_count + 1
		end

		-- Merge per-file detections into main detections table for webhook
		-- Limit to first 5 files to prevent webhook message size issues
		local MAX_FILES_IN_WEBHOOK = 5
		local files_added = 0
		local truncated = false

		for fname, fdata in pairs(per_file_detections) do
			if files_added < MAX_FILES_IN_WEBHOOK then
				for scanner, detection in pairs(fdata.detections) do
					-- Create composite key with filename (sanitize for safety)
					local safe_fname = utils.log_sanitize(fname)
					local key = scanner .. " (file: " .. safe_fname .. ")"
					detections[key] = detection
				end
				files_added = files_added + 1
			else
				truncated = true
				-- Don't break - continue to log all detections to server logs below
			end
		end

		-- Log ALL detections to server logs (not truncated)
		local report_msg
		if filename_attack_detected and infected_file_count > 0 then
			report_msg = string.format(
				"[MULTIPART] Full detection report: %d file(s) with content malware detected + filename injection attack(s)",
				infected_file_count
			)
		elseif filename_attack_detected then
			report_msg = "[MULTIPART] Full detection report: filename injection attack(s) detected, no content malware found"
		else
			report_msg = string.format(
				"[MULTIPART] Full detection report: %d file(s) with malware detected",
				infected_file_count
			)
		end
		logger.log_error( report_msg)
		for fname, fdata in pairs(per_file_detections) do
			local safe_fname = utils.log_sanitize(fname)
			for scanner, detection in pairs(fdata.detections) do
				logger.log_error( string.format(
					"[MULTIPART]   - %s: %s = %s",
					safe_fname,
					scanner,
					detection
				))
			end
		end

		-- Add truncation notice to webhook if we hit the limit
		if truncated then
			local remaining = infected_file_count - MAX_FILES_IN_WEBHOOK
			detections["NOTICE"] = string.format(
				"Showing first %d of %d infected files. %d more file(s) with malware detected. Check server logs for complete details.",
				MAX_FILES_IN_WEBHOOK,
				infected_file_count,
				remaining
			)
			logger.log_error( string.format(
				"[MULTIPART] Webhook truncated: showing %d/%d infected files in notification (limit: %d per webhook)",
				MAX_FILES_IN_WEBHOOK,
				infected_file_count,
				MAX_FILES_IN_WEBHOOK
			))
		end

		-- Add filename attack to detections for webhook visibility
		if filename_attack_detected then
			detections["ðŸš¨ Filename Injection Attack"] = "Malicious characters detected in filename (null byte or path traversal attempt)"
		end

		-- Send ONE aggregated webhook notification at end (not per-file)
		if checksum and next(detections) ~= nil then
		logger.log_error( string.format(
			"[MULTIPART] Sending single aggregated webhook for %d infected file(s)",
			infected_file_count
		))
		webhook.notify(webhook, plugin, checksum, detections)





		end

		-- Cleanup original body file
		local cleanup_enabled = plugin.variables["MALWARE_SCAN_CLEANUP_FILES"]
		if cleanup_enabled ~= "no" then
			local cleanup_ok, cleanup_err
			if file_ops then
				cleanup_ok, cleanup_err = file_ops.file_cleanup(plugin, body_file)
			else
				cleanup_ok, cleanup_err = true, nil
			end
			if not cleanup_ok then
				logger.log_error( "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
			end
		end

		-- Build detailed response with per-file information
		local infected_files = {}
		for fname, fdata in pairs(per_file_detections) do
			table.insert(infected_files, fname)
		end

		-- Build appropriate error message based on detection type
		local error_msg
		local error_id
		if filename_attack_detected and next(per_file_detections) ~= nil then
			error_msg = "filename injection attack and malware detected in multipart files: " .. table.concat(infected_files, ", ")
			error_id = "filename_attack_and_malware_detected"
		elseif filename_attack_detected then
			error_msg = "filename injection attack detected in multipart upload"
			error_id = "filename_attack_detected"
		else
			error_msg = "malware detected in multipart files: " .. table.concat(infected_files, ", ")
			error_id = "malware_detected_multipart"
		end

		return false,
		       error_msg,
		       get_deny_status(),
		       {
		       	id = error_id,
		       	file = body_file,
		       	checksum = checksum,
		       	per_file_detections = per_file_detections,
		       	infected_files = infected_files,
		       	files_scanned = files_scanned,
		       	filename_attack_detected = filename_attack_detected
		       }
	end

	-- No detections in per-file scan, continue normally
	return true, nil, nil, nil
end

-- Return module
return multipart_full_scan
