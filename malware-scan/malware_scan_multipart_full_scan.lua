-- BunkerWeb Malware Scan - Multipart Full Scan Module
-- Handles multipart parsing and per-file scanning when resume mode is enabled
-- Only activates when MALWARE_SCAN_RESUME_SCAN_ON_FIRST_HIT=yes
-- Provides comprehensive threat intelligence by scanning all files before blocking

local ngx = ngx
local ERR = ngx.ERR
local NOTICE = ngx.NOTICE
local get_deny_status = require("bunkerweb.utils").get_deny_status
local utils = require("malware_scan_utils")

-- Module table
local multipart_full_scan = {}

-- Module dependencies (set via setters)
local cache = nil
local file_ops = nil
local clamav = nil
local virustotal = nil
local threatfox = nil
local sentinelone = nil
local webhook = nil

-- Setter functions for module dependencies
function multipart_full_scan.set_cache_module(cache_module)
	cache = cache_module
end

function multipart_full_scan.set_file_ops_module(file_ops_module)
	file_ops = file_ops_module
end

function multipart_full_scan.set_clamav_module(clamav_module)
	clamav = clamav_module
end

function multipart_full_scan.set_virustotal_module(vt_module)
	virustotal = vt_module
end

function multipart_full_scan.set_threatfox_module(tf_module)
	threatfox = tf_module
end

function multipart_full_scan.set_sentinelone_module(s1_module)
	sentinelone = s1_module
end

function multipart_full_scan.set_webhook_module(webhook_module)
	webhook = webhook_module
end

-- No longer need internal parsing functions - we'll use file_ops.parse_multipart_files()

-- Scan a single file with all enabled scanners
-- Returns table of detections (empty if clean)
local function scan_individual_file(plugin, temp_file, file_checksum, file_size, filename, enabled_scanners)
	local file_detections = {}

	-- Sanitize filename for safe logging (prevent log injection)
	local safe_filename = utils.sanitize_for_logging(filename)

	-- Scan with ClamAV if enabled
	if enabled_scanners.clamav then
		-- Check cache first
		local file_cached = nil
		if file_checksum and file_checksum ~= "empty_file" and cache then
			local cache_ok, cached_result, cached_size = cache.is_in_clamav_cache(plugin, file_checksum, file_size)
			if cache_ok and cached_result and cached_result ~= "clean" then
				plugin.logger:log(ERR, "[MULTIPART] ClamAV cache hit for " .. safe_filename .. ": " .. cached_result)
				file_detections["ClamAV (cached)"] = cached_result
				file_cached = cached_result
			end
		end

		-- If not in cache, scan with ClamAV
		if not file_cached and clamav then
			local scan_ok, scan_result = clamav.scan_file_instream(plugin, temp_file)
			if scan_ok and scan_result and scan_result ~= "clean" then
				plugin.logger:log(ERR, "[MULTIPART] ClamAV detected malware in " .. safe_filename .. ": " .. scan_result)
				file_detections["ClamAV"] = scan_result

				-- Cache the result
				if file_checksum and file_checksum ~= "empty_file" and cache then
					cache.add_to_clamav_cache(plugin, file_checksum, scan_result, file_size)
				end
			end
		end
	end

	-- Scan with VirusTotal if enabled
	if enabled_scanners.virustotal and file_checksum and file_checksum ~= "empty_file" then
		-- Check cache first
		local vt_cached = nil
		if cache then
			local cache_ok, cached_result = cache.is_in_virustotal_cache(plugin, file_checksum)
			if cache_ok and cached_result and cached_result ~= "clean" then
				plugin.logger:log(ERR, "[MULTIPART] VirusTotal cache hit for " .. safe_filename .. ": " .. cached_result)
				file_detections["VirusTotal (cached)"] = cached_result
				vt_cached = cached_result
			end
		end

		-- If not in cache, query VirusTotal
		if not vt_cached and virustotal then
			local vt_ok, vt_result = virustotal.check_hash(plugin, file_checksum)
			if vt_ok and vt_result and vt_result ~= "clean" then
				plugin.logger:log(ERR, "[MULTIPART] VirusTotal detected malware in " .. safe_filename .. ": " .. vt_result)
				file_detections["VirusTotal"] = vt_result

				-- Cache the result
				if cache then
					cache.add_to_virustotal_cache(plugin, file_checksum, vt_result)
				end
			end
		end
	end

	-- Scan with ThreatFox if enabled
	if enabled_scanners.threatfox and file_checksum and file_checksum ~= "empty_file" then
		-- Check cache first
		local tf_cached = nil
		if cache then
			local cache_ok, cached_result = cache.is_in_threatfox_cache(plugin, file_checksum)
			if cache_ok and cached_result and cached_result ~= "clean" then
				plugin.logger:log(ERR, "[MULTIPART] ThreatFox cache hit for " .. safe_filename .. ": " .. cached_result)
				file_detections["ThreatFox (cached)"] = cached_result
				tf_cached = cached_result
			end
		end

		-- If not in cache, query ThreatFox
		if not tf_cached and threatfox then
			local tf_ok, tf_result = threatfox.check_hash(plugin, file_checksum)
			if tf_ok and tf_result and tf_result ~= "clean" then
				plugin.logger:log(ERR, "[MULTIPART] ThreatFox detected malware in " .. safe_filename .. ": " .. tf_result)
				file_detections["ThreatFox"] = tf_result

				-- Cache the result
				if cache then
					cache.add_to_threatfox_cache(plugin, file_checksum, tf_result)
				end
			end
		end
	end

	-- Scan with SentinelOne if enabled
	if enabled_scanners.sentinelone and file_checksum and file_checksum ~= "empty_file" then
		-- Check cache first
		local s1_cached = nil
		if cache then
			local cache_ok, cached_result = cache.is_in_sentinelone_cache(plugin, file_checksum)
			if cache_ok and cached_result and cached_result ~= "clean" then
				plugin.logger:log(ERR, "[MULTIPART] SentinelOne cache hit for " .. safe_filename .. ": " .. cached_result)
				file_detections["SentinelOne (cached)"] = cached_result
				s1_cached = cached_result
			end
		end

		-- If not in cache, query SentinelOne
		if not s1_cached and sentinelone then
			local s1_ok, s1_result = sentinelone.check_hash(plugin, file_checksum)
			if s1_ok and s1_result and s1_result ~= "clean" then
				plugin.logger:log(ERR, "[MULTIPART] SentinelOne detected malware in " .. safe_filename .. ": " .. s1_result)
				file_detections["SentinelOne"] = s1_result

				-- Cache the result
				if cache then
					cache.add_to_sentinelone_cache(plugin, file_checksum, s1_result)
				end
			end
		end
	end

	return file_detections
end

-- Main function: Parse multipart upload and scan each individual file
-- Called from main plugin when resume mode is enabled
-- Returns:
--   - success: boolean (true = continue, false = should block)
--   - message: string (block message if success=false)
--   - status: number (HTTP status code if blocking)
--   - data: table (block response data)
function multipart_full_scan.scan_multipart_files(plugin, body_file, checksum, detections, enabled_scanners)
	-- Check if multipart scanning is possible
	if not plugin.ctx.bw.http_content_type or
	   not plugin.ctx.bw.http_content_type:match("multipart/form%-data") then
		plugin.logger:log(ERR, "[MULTIPART] Not multipart/form-data, skipping per-file scan")
		return true, nil, nil, nil
	end

	-- Check if file_ops module is available
	if not file_ops then
		plugin.logger:log(ERR, "[MULTIPART] file_ops module not loaded, cannot parse multipart uploads")
		return true, nil, nil, nil
	end

	plugin.logger:log(ERR, "[MULTIPART] Starting per-file scanning in resume mode")

	-- Use file_ops to parse multipart upload (includes security validation)
	local parse_ok, files_or_err, attack_indicator = file_ops.parse_multipart_files(plugin, body_file, plugin.ctx.bw.http_content_type)
	if not parse_ok then
		-- Check if this is a security attack (malicious filename detected)
		if files_or_err and files_or_err:match("malicious filename detected") then
			plugin.logger:log(ERR, "[MULTIPART] SECURITY ALERT: " .. files_or_err)
			-- Return error to trigger immediate blocking
			return false,
			       files_or_err,
			       get_deny_status(),
			       {
			       	id = "malicious_filename_attack",
			       	file = body_file,
			       	error = files_or_err
			       }
		end

		plugin.logger:log(ERR, "[MULTIPART] Failed to parse multipart upload: " .. tostring(files_or_err))
		return true, nil, nil, nil
	end

	local files = files_or_err
	plugin.logger:log(ERR, "[MULTIPART] Parsed " .. #files .. " file(s) from multipart upload")

	-- Track if filename attack was detected (will block after full scan)
	local filename_attack_detected = (attack_indicator == "filename_attack_detected")

	-- Track per-file detections
	local per_file_detections = {}
	local files_scanned = 0

	-- Scan each extracted file
	for _, file_info in ipairs(files) do
		local filename = file_info.filename
		local temp_file = file_info.filepath
		local file_size = file_info.size

		-- Sanitize filename for logging (prevent log injection)
		local safe_filename = utils.sanitize_for_logging(filename)
		plugin.logger:log(ERR, "[MULTIPART] Processing file: " .. safe_filename .. " (size: " .. file_size .. " bytes)")
		files_scanned = files_scanned + 1

		-- Calculate SHA256 for this file
		local file_checksum, file_checksum_ok
		if file_ops then
			file_checksum_ok, file_checksum = file_ops.calculate_sha256(plugin, temp_file)
		else
			file_checksum_ok, file_checksum = false, nil
		end

		if file_checksum_ok and file_checksum and file_checksum ~= "empty_file" then
			plugin.logger:log(ERR, "[MULTIPART] File SHA256: " .. file_checksum)
		end

		-- Scan this file with all enabled scanners
		local file_detections = scan_individual_file(
			plugin,
			temp_file,
			file_checksum,
			file_size,
			filename,
			enabled_scanners
		)

		-- Store per-file detections if any
		if next(file_detections) ~= nil then
			per_file_detections[filename] = {
				checksum = file_checksum,
				detections = file_detections,
				size = file_size
			}
		end

		-- Cleanup temp file
		if file_ops then
			file_ops.cleanup_file(plugin, temp_file)
		else
			os.remove(temp_file)
		end
	end

	plugin.logger:log(ERR, "[MULTIPART] Scanned " .. files_scanned .. " individual files")

	-- If filename attack or per-file detections exist, return blocking response
	if filename_attack_detected or next(per_file_detections) ~= nil then
		if filename_attack_detected then
			plugin.logger:log(ERR, "[MULTIPART] Filename injection attack detected during parsing - blocking request")
		end
		if next(per_file_detections) ~= nil then
			plugin.logger:log(ERR, "[MULTIPART] Malware detected in individual files - blocking request")
		end

		-- Count total infected files for webhook truncation logic
		local infected_file_count = 0
		for _ in pairs(per_file_detections) do
			infected_file_count = infected_file_count + 1
		end

		-- Merge per-file detections into main detections table for webhook
		-- Limit to first 5 files to prevent webhook message size issues
		local MAX_FILES_IN_WEBHOOK = 5
		local files_added = 0
		local truncated = false

		for fname, fdata in pairs(per_file_detections) do
			if files_added < MAX_FILES_IN_WEBHOOK then
				for scanner, detection in pairs(fdata.detections) do
					-- Create composite key with filename (sanitize for safety)
					local safe_fname = utils.sanitize_for_logging(fname)
					local key = scanner .. " (file: " .. safe_fname .. ")"
					detections[key] = detection
				end
				files_added = files_added + 1
			else
				truncated = true
				-- Don't break - continue to log all detections to server logs below
			end
		end

		-- Log ALL detections to server logs (not truncated)
		local report_msg
		if filename_attack_detected and infected_file_count > 0 then
			report_msg = string.format(
				"[MULTIPART] Full detection report: %d file(s) with content malware detected + filename injection attack(s)",
				infected_file_count
			)
		elseif filename_attack_detected then
			report_msg = "[MULTIPART] Full detection report: filename injection attack(s) detected, no content malware found"
		else
			report_msg = string.format(
				"[MULTIPART] Full detection report: %d file(s) with malware detected",
				infected_file_count
			)
		end
		plugin.logger:log(ERR, report_msg)
		for fname, fdata in pairs(per_file_detections) do
			local safe_fname = utils.sanitize_for_logging(fname)
			for scanner, detection in pairs(fdata.detections) do
				plugin.logger:log(ERR, string.format(
					"[MULTIPART]   - %s: %s = %s",
					safe_fname,
					scanner,
					detection
				))
			end
		end

		-- Add truncation notice to webhook if we hit the limit
		if truncated then
			local remaining = infected_file_count - MAX_FILES_IN_WEBHOOK
			detections["NOTICE"] = string.format(
				"Showing first %d of %d infected files. %d more file(s) with malware detected. Check server logs for complete details.",
				MAX_FILES_IN_WEBHOOK,
				infected_file_count,
				remaining
			)
			plugin.logger:log(ERR, string.format(
				"[MULTIPART] Webhook truncated: showing %d/%d infected files in notification (limit: %d per webhook)",
				MAX_FILES_IN_WEBHOOK,
				infected_file_count,
				MAX_FILES_IN_WEBHOOK
			))
		end

		-- Add filename attack to detections for webhook visibility
		if filename_attack_detected then
			detections["ðŸš¨ Filename Injection Attack"] = "Malicious characters detected in filename (null byte or path traversal attempt)"
		end

		-- Send ONE aggregated webhook notification at end (not per-file)
		if checksum and next(detections) ~= nil then
			if webhook then
				plugin.logger:log(ERR, string.format(
					"[MULTIPART] Sending single aggregated webhook for %d infected file(s)",
					infected_file_count
				))
				local ok, err = pcall(webhook.send_notification, plugin, checksum, detections)
				if not ok then
					plugin.logger:log(ERR, "[WEBHOOK] Failed to send notification: " .. tostring(err))
				end
			else
				plugin.logger:log(ERR, "[WEBHOOK] Skipping - module not loaded")
			end
		end

		-- Cleanup original body file
		local cleanup_enabled = plugin.variables["MALWARE_SCAN_CLEANUP_FILES"]
		if cleanup_enabled ~= "no" then
			local cleanup_ok, cleanup_err
			if file_ops then
				cleanup_ok, cleanup_err = file_ops.cleanup_file(plugin, body_file)
			else
				cleanup_ok, cleanup_err = true, nil
			end
			if not cleanup_ok then
				plugin.logger:log(ERR, "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
			end
		end

		-- Build detailed response with per-file information
		local infected_files = {}
		for fname, fdata in pairs(per_file_detections) do
			table.insert(infected_files, fname)
		end

		-- Build appropriate error message based on detection type
		local error_msg
		local error_id
		if filename_attack_detected and next(per_file_detections) ~= nil then
			error_msg = "filename injection attack and malware detected in multipart files: " .. table.concat(infected_files, ", ")
			error_id = "filename_attack_and_malware_detected"
		elseif filename_attack_detected then
			error_msg = "filename injection attack detected in multipart upload"
			error_id = "filename_attack_detected"
		else
			error_msg = "malware detected in multipart files: " .. table.concat(infected_files, ", ")
			error_id = "malware_detected_multipart"
		end

		return false,
		       error_msg,
		       get_deny_status(),
		       {
		       	id = error_id,
		       	file = body_file,
		       	checksum = checksum,
		       	per_file_detections = per_file_detections,
		       	infected_files = infected_files,
		       	files_scanned = files_scanned,
		       	filename_attack_detected = filename_attack_detected
		       }
	end

	-- No detections in per-file scan, continue normally
	return true, nil, nil, nil
end

-- Return module
return multipart_full_scan
