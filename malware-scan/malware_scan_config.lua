-- BunkerWeb Malware Scan - Configuration Module
-- Centralized configuration parsing, validation, and logging
-- Provides clean interface for config handling across the plugin

local logger = require("malware_scan_logger")
local lfs = require("lfs")

-- Module table
local config = {}

-- Module version
config.VERSION = "0.8.0"

-- ============================================================================
-- CONFIGURATION MASKING
-- ============================================================================

-- Mask sensitive configuration values for safe logging.
-- Identifies sensitive keys (API keys, tokens, webhook URLs) and masks their values.
-- This prevents accidental exposure of credentials in logs.
--
-- Masking rules:
-- - Keys ending with _KEY, _TOKEN, or _WEBHOOK_URL: Show "[MASKED]"
-- - Empty or nil values: Show "(not set)"
-- - All other values: Show as-is
--
-- Example:
--   config_mask_if_sensitive("MALWARE_SCAN_API_VIRUSTOTAL_KEY", "abc123xyz789")
--   Returns: "[MASKED]"
--
--   config_mask_if_sensitive("MALWARE_SCAN_CLAMAV_HOST", "clamav")
--   Returns: "clamav"
--
--- @param key string The configuration key name (used to detect sensitive fields)
--- @param value string The configuration value to potentially mask
--- @return string Masked string or original value, or "(not set)" if empty
local function config_mask_if_sensitive(key, value)
	if not value or value == "" then
		return "(not set)"
	end
	-- Mask API keys, tokens, and webhook URLs (pattern matching on key name)
	if key:match("_KEY$") or key:match("_TOKEN$") or key:match("_WEBHOOK_URL$") then
		return "[MASKED]"
	end
	return value
end

-- ============================================================================
-- CONFIGURATION LOADING
-- ============================================================================

-- Load and validate configuration from plugin variables.
-- Extracts all plugin configuration into a structured table for easy access.
-- Performs basic validation on critical settings.
--
-- Configuration structure:
-- {
--   core = { enabled, debug, unmask_keys },
--   clamav = { enabled, host, port, timeout, max_size },
--   file_limits = { hash_max_size },
--   behavior = { block_memory_uploads, cleanup_files, cleanup_orphaned, ... },
--   cache = { use_shared_database, virus_ttl, clean_ttl, shared_ttl },
--   cache_cleanup = { all, clamav, virustotal, sentinelone, attacker_ipv4, attacker_ipv6 },
--   api = { virustotal = {...}, sentinelone = {...} },
--   webhooks = { teams = {...}, discord = {...} },
--   attackers = { track, ttl },
--   multipart = { scan_full_body }
-- }
--
--- @param plugin Plugin The plugin instance (provides access to self.variables)
--- @return table|nil cfg Configuration table with all settings
--- @return string|nil error Error message on failure
function config.load(plugin)
	local vars = plugin.variables

	-- Validate that variables are accessible
	if not vars then
		return nil, "plugin.variables is nil"
	end

	-- Build configuration table
	local cfg = {
		-- Core settings
		core = {
			enabled = vars["USE_MALWARE_SCANNER"] or "no",
			debug = vars["MALWARE_SCAN_DEBUG"] or "no",
			unmask_keys = vars["MALWARE_SCAN_UNMASK_KEYS"] or "",
		},

		-- ClamAV settings
		clamav = {
			enabled = vars["MALWARE_SCAN_CLAMAV_ENABLED"] or "yes",
			host = vars["MALWARE_SCAN_CLAMAV_HOST"] or "clamav",
			port = vars["MALWARE_SCAN_CLAMAV_PORT"] or "3310",
			timeout = vars["MALWARE_SCAN_CLAMAV_TIMEOUT"] or "10000",
			max_size = vars["MALWARE_SCAN_CLAMAV_MAX_SIZE"] or "26214400",
		},

		-- File size limits
		file_limits = {
			hash_max_size = vars["MALWARE_SCAN_HASH_MAX_SIZE"] or "67108864",
		},

		-- Behavior settings
		behavior = {
			block_memory_uploads = vars["MALWARE_SCAN_BLOCK_MEMORY_UPLOADS"] or "yes",
			cleanup_files = vars["MALWARE_SCAN_CLEANUP_FILES"] or "yes",
			cleanup_orphaned = vars["MALWARE_SCAN_CLEANUP_ORPHANED"] or "yes",
			cleanup_age = vars["MALWARE_SCAN_CLEANUP_AGE"] or "3600",
			skip_others_on_clamav_detect = vars["MALWARE_SCAN_SKIP_OTHERS_ON_CLAMAV_DETECT"] or "yes",
			resume_scan_on_first_hit = vars["MALWARE_SCAN_RESUME_SCAN_ON_FIRST_HIT"] or "no",
			block_on_filename_injection_attack = vars["MALWARE_SCAN_BLOCK_ON_FILENAME_INJECTION_ATTACK"] or "yes",
		},

		-- Cache settings
		cache = {
			use_shared_database = vars["MALWARE_SCAN_USE_SHARED_DATABASE"] or "no",
			virus_ttl = vars["MALWARE_SCAN_CACHE_VIRUS_TTL"] or "86400",
			clean_ttl = vars["MALWARE_SCAN_CACHE_CLEAN_TTL"] or "3600",
			shared_ttl = vars["MALWARE_SCAN_CACHE_SHARED_TTL"] or "86400",
		},

		-- Cache cleanup on restart
		cache_cleanup = {
			all = vars["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ALL"] or "no",
			clamav = vars["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_CLAMAV"] or "no",
			virustotal = vars["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_VIRUSTOTAL"] or "no",
			sentinelone = vars["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_SENTINELONE"] or "no",
			attacker_ipv4 = vars["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV4"] or "no",
			attacker_ipv6 = vars["MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV6"] or "no",
		},

		-- API integrations
		api = {
			virustotal = {
				enabled = vars["MALWARE_SCAN_API_USE_VIRUSTOTAL"] or "no",
				key = vars["MALWARE_SCAN_API_VIRUSTOTAL_KEY"] or "",
				suspicious_threshold = vars["MALWARE_SCAN_API_VIRUSTOTAL_SUSPICIOUS"] or "5",
				malicious_threshold = vars["MALWARE_SCAN_API_VIRUSTOTAL_MALICIOUS"] or "1",
			},
			sentinelone = {
				enabled = vars["MALWARE_SCAN_API_USE_SENTINELONE"] or "no",
				url = vars["MALWARE_SCAN_API_SENTINELONE_URL"] or "",
				token = vars["MALWARE_SCAN_API_SENTINELONE_TOKEN"] or "",
			},
		},

		-- Webhook notifications
		webhooks = {
			teams = {
				url = vars["MALWARE_SCAN_TEAMS_WEBHOOK_URL"] or "",
				rate_limit = vars["MALWARE_SCAN_TEAMS_WEBHOOK_RATE_LIMIT"] or "60",
			},
			discord = {
				url = vars["MALWARE_SCAN_DISCORD_WEBHOOK_URL"] or "",
				rate_limit = vars["MALWARE_SCAN_DISCORD_WEBHOOK_RATE_LIMIT"] or "60",
			},
		},

		-- Attacker tracking
		attackers = {
			track = vars["MALWARE_SCAN_TRACK_ATTACKERS"] or "yes",
			ttl = vars["MALWARE_SCAN_TRACK_ATTACKER_TTL"] or "3600",
		},

		-- Multipart scanning
		multipart = {
			scan_full_body = vars["MALWARE_SCAN_SCAN_FULL_MULTIPART_BODY"] or "no",
		},
	}

	return cfg
end

-- ============================================================================
-- CONFIGURATION VALIDATION (BASIC)
-- ============================================================================

-- Validate critical configuration values.
-- Checks that required settings are present and within acceptable ranges.
-- Currently validates ClamAV connectivity settings.
--
--- @param cfg Configuration table from config.load()
--- @return boolean success True on success
--- @return string|nil error Error message on validation failure
function config.validate(cfg)
	if not cfg then
		return false, "configuration is nil"
	end

	-- Validate ClamAV settings if enabled
	if cfg.clamav.enabled == "yes" then
		if not cfg.clamav.host or cfg.clamav.host == "" then
			return false, "MALWARE_SCAN_CLAMAV_HOST is required when ClamAV is enabled"
		end

		local port = tonumber(cfg.clamav.port)
		if not port or port < 1 or port > 65535 then
			return false, "MALWARE_SCAN_CLAMAV_PORT must be between 1 and 65535"
		end

		local timeout = tonumber(cfg.clamav.timeout)
		if not timeout or timeout < 100 then
			return false, "MALWARE_SCAN_CLAMAV_TIMEOUT must be at least 100ms"
		end
	end

	return true
end

-- ============================================================================
-- COMPREHENSIVE STARTUP VALIDATION
-- ============================================================================

-- Load utilities module for numerical validation (lazy load to avoid init issues)
local utils = nil
local function config_get_utils()
	if not utils then
		utils = require("malware_scan_utils")
	end
	return utils
end

--- Create directory recursively (like mkdir -p)
--- @param path string Directory path to create
--- @return boolean success True if directory was created or already exists
--- @return string|nil error Error message on failure
local function config_mkdir_recursive(path)
	if not path or path == "" then
		return false, "path is empty"
	end

	-- Check if directory already exists
	local attr = lfs.attributes(path, "mode")
	if attr == "directory" then
		return true, nil
	elseif attr then
		return false, "path exists but is not a directory"
	end

	-- Split path into components
	local components = {}
	for component in path:gmatch("[^/]+") do
		table.insert(components, component)
	end

	-- Build path incrementally
	local current_path = path:sub(1, 1) == "/" and "/" or ""
	for _, component in ipairs(components) do
		current_path = current_path .. component .. "/"

		-- Check if this level exists
		local level_attr = lfs.attributes(current_path, "mode")
		if not level_attr then
			-- Create this directory level
			local ok, err = lfs.mkdir(current_path)
			if not ok then
				return false, "failed to create directory " .. current_path .. ": " .. (err or "unknown error")
			end
		elseif level_attr ~= "directory" then
			return false, "path component exists but is not a directory: " .. current_path
		end
	end

	return true, nil
end

--- Check if a directory exists and is writable
--- @param path string Directory path to check
--- @return boolean exists True if directory exists
--- @return boolean writable True if directory is writable
--- @return string|nil error Error message if any
local function config_check_directory(path)
	if not path or path == "" then
		return false, false, "path is empty"
	end

	-- Validate path to prevent command injection
	local u = config_get_utils()
	local validated_path, err = u.validate_and_escape_path(path)
	if not validated_path then
		return false, false, err
	end

	-- Check if directory exists using lfs.attributes (non-blocking)
	local attr = lfs.attributes(path, "mode")
	if not attr then
		return false, false, "directory does not exist"
	end

	if attr ~= "directory" then
		return false, false, "path is not a directory"
	end

	-- Check write permission by attempting to create a test file
	-- Use os.tmpname() for safe temporary file creation
	local tmpname = os.tmpname()
	local test_file = path .. "/" .. tmpname:match("([^/]+)$")
	local fh, open_err = io.open(test_file, "w")
	if not fh then
		return true, false, "directory is not writable: " .. (open_err or "unknown error")
	end
	fh:close()

	-- Clean up test file
	local remove_ok, remove_err = os.remove(test_file)
	if not remove_ok then
		-- Log but don't fail - directory is writable even if cleanup failed
		logger.log_warn(string.format("Failed to remove write test file %s: %s", test_file, remove_err or "unknown error"))
	end

	return true, true, nil
end

--- Check if a file exists and is readable
--- @param path string File path to check
--- @return boolean exists True if file exists
--- @return boolean readable True if file is readable
--- @return string|nil error Error message if any
local function config_check_file(path)
	if not path or path == "" then
		return false, false, "path is empty"
	end

	-- Validate path to prevent command injection
	local u = config_get_utils()
	local validated_path, err = u.validate_and_escape_path(path)
	if not validated_path then
		return false, false, err
	end

	-- Check if file exists using lfs.attributes (non-blocking)
	local attr = lfs.attributes(path, "mode")
	if not attr then
		return false, false, "file does not exist"
	end

	if attr ~= "file" then
		return false, false, "path is not a file"
	end

	-- Check read permission by attempting to open the file
	local fh, open_err = io.open(path, "r")
	if not fh then
		return true, false, "file is not readable: " .. (open_err or "unknown error")
	end
	fh:close()

	return true, true, nil
end

--- Check if a Unix socket exists
--- @param path string Socket path to check
--- @return boolean exists True if socket exists
--- @return string|nil error Error message if any
local function config_check_socket(path)
	if not path or path == "" then
		return false, "socket path is empty"
	end

	-- Validate path to prevent command injection
	local u = config_get_utils()
	local validated_path, err = u.validate_and_escape_path(path)
	if not validated_path then
		return false, err
	end

	-- Check if socket exists using lfs.attributes (non-blocking)
	local attr = lfs.attributes(path, "mode")
	if not attr or attr ~= "socket" then
		return false, "socket does not exist or is not a socket file"
	end

	return true, nil
end

--- Validate path configurations
--- @param variables table Plugin configuration variables (plugin.variables)
--- @return boolean valid True if all paths are valid
--- @return table errors List of validation errors
local function config_validate_paths(variables)
	local errors = {}

	-- Validate export path (if set)
	local export_path = variables["MALWARE_SCAN_VIRUSFILE_LOCAL_EXPORT_PATH"]
	if export_path and export_path ~= "" then
		local exists, writable, err = config_check_directory(export_path)
		if not exists then
			-- Directory doesn't exist - try to create it recursively (like mkdir -p)
			local u = config_get_utils()
			local validated_path, escape_err = u.validate_and_escape_path(export_path)
			if not validated_path then
				table.insert(errors, string.format(
					"Export path validation failed: %s (%s)",
					export_path, escape_err or "unknown error"
				))
			else
				local mkdir_ok, mkdir_err = config_mkdir_recursive(export_path)
				if not mkdir_ok then
					table.insert(errors, string.format(
						"Export path does not exist and could not be created: %s (error: %s)",
						export_path, mkdir_err or "unknown error"
					))
				end
			end
		elseif not writable then
			table.insert(errors, string.format(
				"Export path is not writable: %s (%s)",
				export_path, err or "unknown error"
			))
		end
	end

	-- Validate temp directory
	local temp_path = "/var/tmp/bunkerweb/client_temp"
	local exists, writable, err = config_check_directory(temp_path)
	if not exists then
		table.insert(errors, string.format(
			"Temp directory does not exist: %s (%s)",
			temp_path, err or "unknown error"
		))
	elseif not writable then
		table.insert(errors, string.format(
			"Temp directory is not writable: %s (%s)",
			temp_path, err or "unknown error"
		))
	end

	-- Validate allowlist file (if set)
	local allowlist_file = variables["MALWARE_SCAN_ALLOWLIST_FILE"]
	if allowlist_file and allowlist_file ~= "" then
		local exists, readable, err = config_check_file(allowlist_file)
		if not exists then
			table.insert(errors, string.format(
				"Allowlist file does not exist: %s (%s)",
				allowlist_file, err or "unknown error"
			))
		elseif not readable then
			table.insert(errors, string.format(
				"Allowlist file is not readable: %s (%s)",
				allowlist_file, err or "unknown error"
			))
		end
	end

	return #errors == 0, errors
end

--- Validate numerical configuration values
--- @param variables table Plugin configuration variables (plugin.variables)
--- @return boolean valid True if all numerical configs are valid
--- @return table errors List of validation errors
local function config_validate_numerical_configs(variables)
	local errors = {}
	local u = config_get_utils()

	-- Validate MALWARE_SCAN_MAX_FILE_SIZE (0 to 10GB)
	local max_file_size = tonumber(variables["MALWARE_SCAN_MAX_FILE_SIZE"])
	if max_file_size then
		local validated = u.validate_file_size(max_file_size, 10 * 1024 * 1024 * 1024)
		if validated == 0 and max_file_size ~= 0 then
			table.insert(errors, string.format(
				"MALWARE_SCAN_MAX_FILE_SIZE is invalid: %s (must be 0 to 10GB)",
				variables["MALWARE_SCAN_MAX_FILE_SIZE"]
			))
		end
	end

	-- Validate MALWARE_SCAN_HASH_MAX_SIZE (0 to 10GB)
	local hash_max_size = tonumber(variables["MALWARE_SCAN_HASH_MAX_SIZE"])
	if hash_max_size then
		local validated = u.validate_file_size(hash_max_size, 10 * 1024 * 1024 * 1024)
		if validated == 0 and hash_max_size ~= 0 then
			table.insert(errors, string.format(
				"MALWARE_SCAN_HASH_MAX_SIZE is invalid: %s (must be 0 to 10GB)",
				variables["MALWARE_SCAN_HASH_MAX_SIZE"]
			))
		end
	end

	-- Validate MALWARE_SCAN_MAX_FILES_PER_REQUEST (1 to 1000)
	local max_files = tonumber(variables["MALWARE_SCAN_MAX_FILES_PER_REQUEST"])
	if max_files then
		if max_files < 1 then
			table.insert(errors, string.format(
				"MALWARE_SCAN_MAX_FILES_PER_REQUEST is too low: %s (must be >= 1)",
				variables["MALWARE_SCAN_MAX_FILES_PER_REQUEST"]
			))
		elseif max_files > 1000 then
			table.insert(errors, string.format(
				"MALWARE_SCAN_MAX_FILES_PER_REQUEST is too high: %s (must be <= 1000)",
				variables["MALWARE_SCAN_MAX_FILES_PER_REQUEST"]
			))
		end
	end

	-- Validate MALWARE_SCAN_TRACK_ATTACKER_TTL (3600 to 31536000 = 1 hour to 1 year)
	local attacker_ttl = tonumber(variables["MALWARE_SCAN_TRACK_ATTACKER_TTL"])
	if attacker_ttl then
		-- Check bounds directly (validate_ttl doesn't enforce our minimum of 3600)
		if attacker_ttl < 3600 then
			table.insert(errors, string.format(
				"MALWARE_SCAN_TRACK_ATTACKER_TTL is too low: %s (must be >= 3600 seconds / 1 hour)",
				variables["MALWARE_SCAN_TRACK_ATTACKER_TTL"]
			))
		elseif attacker_ttl > 31536000 then
			table.insert(errors, string.format(
				"MALWARE_SCAN_TRACK_ATTACKER_TTL is too high: %s (must be <= 31536000 seconds / 1 year)",
				variables["MALWARE_SCAN_TRACK_ATTACKER_TTL"]
			))
		end
	end

	-- Validate MALWARE_SCAN_CACHE_HASH_MAXTTL (60 to 86400 = 1 minute to 1 day)
	local cache_ttl = tonumber(variables["MALWARE_SCAN_CACHE_HASH_MAXTTL"])
	if cache_ttl then
		if cache_ttl < 60 then
			table.insert(errors, string.format(
				"MALWARE_SCAN_CACHE_HASH_MAXTTL is too low: %s (must be >= 60 seconds / 1 minute)",
				variables["MALWARE_SCAN_CACHE_HASH_MAXTTL"]
			))
		elseif cache_ttl > 86400 then
			table.insert(errors, string.format(
				"MALWARE_SCAN_CACHE_HASH_MAXTTL is too high: %s (must be <= 86400 seconds / 1 day)",
				variables["MALWARE_SCAN_CACHE_HASH_MAXTTL"]
			))
		end
	end

	return #errors == 0, errors
end

--- Validate VirusTotal API key format
--- @param api_key string VirusTotal API key
--- @return boolean valid True if API key is valid
--- @return string|nil error Error message if invalid
local function config_validate_virustotal_key(api_key)
	if not api_key or api_key == "" then
		return false, "API key is empty"
	end

	-- VirusTotal API keys are 64 character hex strings
	if #api_key ~= 64 then
		return false, string.format("API key has invalid length: %d (expected 64)", #api_key)
	end

	if not api_key:match("^[a-fA-F0-9]+$") then
		return false, "API key contains invalid characters (expected hex string)"
	end

	return true, nil
end

--- Validate MalwareBazaar API key format
--- @param api_key string MalwareBazaar API key
--- @return boolean valid True if API key is valid
--- @return string|nil error Error message if invalid
local function config_validate_malwarebazaar_key(api_key)
	if not api_key or api_key == "" then
		return false, "API key is empty"
	end

	-- MalwareBazaar API keys are variable length alphanumeric strings
	if #api_key < 16 then
		return false, string.format("API key is too short: %d characters (expected >= 16)", #api_key)
	end

	if not api_key:match("^[a-zA-Z0-9]+$") then
		return false, "API key contains invalid characters (expected alphanumeric)"
	end

	return true, nil
end

--- Validate scanner dependencies
--- @param variables table Plugin configuration variables (plugin.variables)
--- @return boolean valid True if all scanner dependencies are valid
--- @return table errors List of validation errors
--- @return table warnings List of validation warnings
local function config_validate_scanner_dependencies(variables)
	local errors = {}
	local warnings = {}

	-- Check if any scanners are enabled
	local clamav_enabled = variables["MALWARE_SCAN_USE_CLAMAV"] == "yes"
	local virustotal_enabled = variables["MALWARE_SCAN_API_USE_VIRUSTOTAL"] == "yes"
	local sentinelone_enabled = variables["MALWARE_SCAN_API_USE_SENTINELONE"] == "yes"
	local malwarebazaar_enabled = variables["MALWARE_SCAN_MALWAREBAZAAR_HASH_LOOKUP"] == "yes"

	if not clamav_enabled and not virustotal_enabled and not sentinelone_enabled and not malwarebazaar_enabled then
		table.insert(warnings, "No scanners are enabled - plugin will not perform any malware scanning")
	end

	-- Validate ClamAV socket if enabled
	if clamav_enabled then
		local socket_path = variables["MALWARE_SCAN_CLAMAV_SOCKET"]
		if socket_path and socket_path ~= "" then
			local valid, err = config_check_socket(socket_path)
			if not valid then
				table.insert(errors, string.format(
					"ClamAV is enabled but socket is invalid: %s (%s)",
					socket_path, err or "unknown error"
				))
			end
		end
	end

	-- Validate VirusTotal API key if enabled
	if virustotal_enabled then
		local api_key = variables["MALWARE_SCAN_API_VIRUSTOTAL_KEY"]
		local valid, err = config_validate_virustotal_key(api_key)
		if not valid then
			table.insert(errors, string.format(
				"VirusTotal is enabled but API key is invalid: %s",
				err or "unknown error"
			))
		end

		-- Warn if upload is enabled
		if variables["MALWARE_SCAN_API_VIRUSTOTAL_UPLOAD_UNKNOWN"] == "yes" then
			table.insert(warnings, "VirusTotal file upload is enabled - files will be uploaded to public database (GDPR implications)")
		end
	end

	-- Validate MalwareBazaar API key if enabled
	if malwarebazaar_enabled then
		local api_key = variables["MALWARE_SCAN_API_MALWAREBAZAAR_KEY"]
		local valid, err = config_validate_malwarebazaar_key(api_key)
		if not valid then
			table.insert(errors, string.format(
				"MalwareBazaar is enabled but API key is invalid: %s",
				err or "unknown error"
			))
		end

		-- Warn if upload is enabled
		if variables["MALWARE_SCAN_API_MALWAREBAZAAR_UPLOAD_UNKNOWN"] == "yes" then
			table.insert(warnings, "MalwareBazaar file upload is enabled - files will be uploaded to public database (GDPR implications)")
		end
	end

	-- Warn if file sharing is enabled but VirusTotal is disabled
	if variables["MALWARE_SCAN_SHARE_FILES"] == "yes" and not virustotal_enabled then
		table.insert(warnings, "File sharing is enabled (MALWARE_SCAN_SHARE_FILES=yes) but VirusTotal is disabled - no files will be shared")
	end

	return #errors == 0, errors, warnings
end

--- Validate mutually exclusive or unusual option combinations
--- @param variables table Plugin configuration variables (plugin.variables)
--- @return boolean valid True if all option logic is valid
--- @return table errors List of validation errors
--- @return table warnings List of validation warnings
local function config_validate_option_logic(variables)
	local errors = {}
	local warnings = {}

	-- Check if both allow list and block list are configured (not actually mutually exclusive, just unusual)
	local allowlist = variables["MALWARE_SCAN_ALLOWLIST"]
	local allowlist_file = variables["MALWARE_SCAN_ALLOWLIST_FILE"]
	if (allowlist and allowlist ~= "") or (allowlist_file and allowlist_file ~= "") then
		table.insert(warnings, "Allow list is configured - false positives will bypass scanning")
	end

	-- Check if attacker tracking is disabled but ban actions are enabled
	if variables["MALWARE_SCAN_TRACK_ATTACKERS"] ~= "yes" then
		if variables["MALWARE_SCAN_BAN_ATTACKERS"] == "yes" then
			table.insert(warnings, "Ban attackers is enabled but attacker tracking is disabled - no attackers will be banned")
		end
	end

	return #errors == 0, errors, warnings
end

--- Comprehensive configuration validation at startup
-- Validates all configuration settings including paths, numerical values,
-- scanner dependencies, and logical consistency.
-- Returns validation results with errors (critical) and warnings (non-critical).
--
--- @param variables table Plugin configuration variables (plugin.variables)
--- @return boolean valid True if all validations pass
--- @return table errors List of critical validation errors
--- @return table warnings List of non-critical validation warnings
function config.validate_startup(variables)
	local all_errors = {}
	local all_warnings = {}

	-- Validate paths
	local paths_valid, paths_errors = config_validate_paths(variables)
	if not paths_valid then
		for _, err in ipairs(paths_errors) do
			table.insert(all_errors, "[PATH] " .. err)
		end
	end

	-- Validate numerical configs
	local numeric_valid, numeric_errors = config_validate_numerical_configs(variables)
	if not numeric_valid then
		for _, err in ipairs(numeric_errors) do
			table.insert(all_errors, "[CONFIG] " .. err)
		end
	end

	-- Validate scanner dependencies
	local scanner_valid, scanner_errors, scanner_warnings = config_validate_scanner_dependencies(variables)
	if not scanner_valid then
		for _, err in ipairs(scanner_errors) do
			table.insert(all_errors, "[SCANNER] " .. err)
		end
	end
	if scanner_warnings then
		for _, warn in ipairs(scanner_warnings) do
			table.insert(all_warnings, "[SCANNER] " .. warn)
		end
	end

	-- Validate option logic
	local logic_valid, logic_errors, logic_warnings = config_validate_option_logic(variables)
	if not logic_valid then
		for _, err in ipairs(logic_errors) do
			table.insert(all_errors, "[LOGIC] " .. err)
		end
	end
	if logic_warnings then
		for _, warn in ipairs(logic_warnings) do
			table.insert(all_warnings, "[LOGIC] " .. warn)
		end
	end

	return #all_errors == 0, all_errors, all_warnings
end

-- ============================================================================
-- CONFIGURATION LOGGING
-- ============================================================================

-- Dump full configuration to logs for diagnostics.
-- Logs all configuration settings in organized sections, masking sensitive values.
-- This is useful for troubleshooting and verifying configuration at worker startup.
--
-- Log sections:
-- 1. Core Settings
-- 2. ClamAV Settings
-- 3. File Size Limits
-- 4. Behavior Settings
-- 5. Cache Settings
-- 6. Cache Cleanup on Restart
-- 7. API Integrations
-- 8. Webhook Notifications
-- 9. Attacker Tracking
-- 10. Multipart Scanning
-- 11. Module Availability
--
--- @param plugin Plugin The plugin instance (provides logger)
--- @param cfg table Configuration table from config.load()
--- @param module_status table|nil Optional table with module availability status
function config.dump(plugin, cfg, module_status)
	logger.log_notice( "[INIT_WORKER] ========== Configuration Dump ==========")

	-- Core settings
	logger.log_notice( "[INIT_WORKER] ## Core Settings")
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   USE_MALWARE_SCANNER = %s", config_mask_if_sensitive("ENABLED", cfg.core.enabled)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_DEBUG = %s", config_mask_if_sensitive("DEBUG", cfg.core.debug)))

	-- ClamAV settings
	logger.log_notice( "[INIT_WORKER] ## ClamAV Settings")
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CLAMAV_ENABLED = %s", config_mask_if_sensitive("ENABLED", cfg.clamav.enabled)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CLAMAV_HOST = %s", config_mask_if_sensitive("HOST", cfg.clamav.host)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CLAMAV_PORT = %s", config_mask_if_sensitive("PORT", cfg.clamav.port)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CLAMAV_TIMEOUT = %s", config_mask_if_sensitive("TIMEOUT", cfg.clamav.timeout)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CLAMAV_MAX_SIZE = %s", config_mask_if_sensitive("SIZE", cfg.clamav.max_size)))

	-- File size limits
	logger.log_notice( "[INIT_WORKER] ## File Size Limits")
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_HASH_MAX_SIZE = %s", config_mask_if_sensitive("SIZE", cfg.file_limits.hash_max_size)))

	-- Behavior settings
	logger.log_notice( "[INIT_WORKER] ## Behavior Settings")
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_BLOCK_MEMORY_UPLOADS = %s", config_mask_if_sensitive("BLOCK", cfg.behavior.block_memory_uploads)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CLEANUP_FILES = %s", config_mask_if_sensitive("CLEANUP", cfg.behavior.cleanup_files)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CLEANUP_ORPHANED = %s", config_mask_if_sensitive("CLEANUP", cfg.behavior.cleanup_orphaned)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CLEANUP_AGE = %s", config_mask_if_sensitive("AGE", cfg.behavior.cleanup_age)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_SKIP_OTHERS_ON_CLAMAV_DETECT = %s", config_mask_if_sensitive("SKIP", cfg.behavior.skip_others_on_clamav_detect)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_RESUME_SCAN_ON_FIRST_HIT = %s", config_mask_if_sensitive("RESUME", cfg.behavior.resume_scan_on_first_hit)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_BLOCK_ON_FILENAME_INJECTION_ATTACK = %s", config_mask_if_sensitive("BLOCK", cfg.behavior.block_on_filename_injection_attack)))

	-- Cache settings
	logger.log_notice( "[INIT_WORKER] ## Cache Settings")
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_USE_SHARED_DATABASE = %s", config_mask_if_sensitive("USE", cfg.cache.use_shared_database)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CACHE_VIRUS_TTL = %s", config_mask_if_sensitive("TTL", cfg.cache.virus_ttl)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CACHE_CLEAN_TTL = %s", config_mask_if_sensitive("TTL", cfg.cache.clean_ttl)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CACHE_SHARED_TTL = %s", config_mask_if_sensitive("TTL", cfg.cache.shared_ttl)))

	-- Cache cleanup on restart
	logger.log_notice( "[INIT_WORKER] ## Cache Cleanup on Restart")
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ALL = %s", config_mask_if_sensitive("CLEANUP", cfg.cache_cleanup.all)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_CLAMAV = %s", config_mask_if_sensitive("CLEANUP", cfg.cache_cleanup.clamav)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_VIRUSTOTAL = %s", config_mask_if_sensitive("CLEANUP", cfg.cache_cleanup.virustotal)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_SENTINELONE = %s", config_mask_if_sensitive("CLEANUP", cfg.cache_cleanup.sentinelone)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV4 = %s", config_mask_if_sensitive("CLEANUP", cfg.cache_cleanup.attacker_ipv4)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV6 = %s", config_mask_if_sensitive("CLEANUP", cfg.cache_cleanup.attacker_ipv6)))

	-- API integrations
	logger.log_notice( "[INIT_WORKER] ## API Integrations")
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_API_USE_VIRUSTOTAL = %s", config_mask_if_sensitive("USE", cfg.api.virustotal.enabled)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_API_VIRUSTOTAL_KEY = %s", config_mask_if_sensitive("MALWARE_SCAN_API_VIRUSTOTAL_KEY", cfg.api.virustotal.key)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_API_VIRUSTOTAL_SUSPICIOUS = %s", config_mask_if_sensitive("SUSPICIOUS", cfg.api.virustotal.suspicious_threshold)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_API_VIRUSTOTAL_MALICIOUS = %s", config_mask_if_sensitive("MALICIOUS", cfg.api.virustotal.malicious_threshold)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_API_USE_SENTINELONE = %s", config_mask_if_sensitive("USE", cfg.api.sentinelone.enabled)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_API_SENTINELONE_URL = %s", config_mask_if_sensitive("URL", cfg.api.sentinelone.url)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_API_SENTINELONE_TOKEN = %s", config_mask_if_sensitive("MALWARE_SCAN_API_SENTINELONE_TOKEN", cfg.api.sentinelone.token)))

	-- Webhook notifications
	logger.log_notice( "[INIT_WORKER] ## Webhook Notifications")
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_TEAMS_WEBHOOK_URL = %s", config_mask_if_sensitive("MALWARE_SCAN_TEAMS_WEBHOOK_URL", cfg.webhooks.teams.url)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_TEAMS_WEBHOOK_RATE_LIMIT = %s", config_mask_if_sensitive("RATE", cfg.webhooks.teams.rate_limit)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_DISCORD_WEBHOOK_URL = %s", config_mask_if_sensitive("MALWARE_SCAN_DISCORD_WEBHOOK_URL", cfg.webhooks.discord.url)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_DISCORD_WEBHOOK_RATE_LIMIT = %s", config_mask_if_sensitive("RATE", cfg.webhooks.discord.rate_limit)))

	-- Attacker tracking
	logger.log_notice( "[INIT_WORKER] ## Attacker Tracking")
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_TRACK_ATTACKERS = %s", config_mask_if_sensitive("TRACK", cfg.attackers.track)))
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_TRACK_ATTACKER_TTL = %s", config_mask_if_sensitive("TTL", cfg.attackers.ttl)))

	-- Multipart scanning
	logger.log_notice( "[INIT_WORKER] ## Multipart Scanning")
	logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   MALWARE_SCAN_SCAN_FULL_MULTIPART_BODY = %s", config_mask_if_sensitive("SCAN", cfg.multipart.scan_full_body)))

	-- Module availability (if provided)
	if module_status then
		logger.log_notice( "[INIT_WORKER] ## Module Availability")
		logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   clamav_module = %s", module_status.clamav and "loaded" or "not loaded"))
		logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   cache_module = %s", module_status.cache and "loaded" or "not loaded"))
		logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   file_ops_module = %s", module_status.file_ops and "loaded" or "not loaded"))
		logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   virustotal_module = %s", module_status.virustotal and "loaded" or "not loaded"))
		logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   sentinelone_module = %s", module_status.sentinelone and "loaded" or "not loaded"))
		logger.log_notice( string.format("[v" .. config.VERSION .. "] [INIT_WORKER]   webhook_module = %s", module_status.webhook and "loaded" or "not loaded"))
	end

	logger.log_notice( "[INIT_WORKER] ========== End Configuration Dump ==========")
end

-- ============================================================================
-- COMBINED WORKFLOW
-- ============================================================================

-- Combined workflow: Load, validate, and dump configuration.
-- Convenience function for init_worker to perform all config setup in one call.
-- Logs errors and returns unified success/error result.
--
-- Example:
--   local cfg_ok, cfg_err = ms_config.load_validate_and_dump(plugin, module_status)
--   if not cfg_ok then
--     return self:ret(false, "configuration failed: " .. cfg_err)
--   end
--
--- @param plugin Plugin The plugin instance (provides access to self.variables and self.logger)
--- @param module_status table|nil Optional table of module availability {clamav=true, cache=true, ...}
--- @return boolean success True on success
--- @return string|nil error_message Error message on failure
function config.load_validate_and_dump(plugin, module_status)
	-- Load configuration
	local cfg, cfg_err = config.load(plugin)
	if not cfg then
		logger.log_error( "[INIT_WORKER] Failed to load configuration: " .. (cfg_err or "unknown error"))
		return false, "configuration load failed: " .. (cfg_err or "unknown error")
	end

	-- Validate configuration
	local valid, valid_err = config.validate(cfg)
	if not valid then
		logger.log_error( "[INIT_WORKER] Configuration validation failed: " .. (valid_err or "unknown error"))
		return false, "configuration validation failed: " .. (valid_err or "unknown error")
	end

	-- Dump configuration to logs
	config.dump(plugin, cfg, module_status)

	return true, nil
end

-- Return module
return config
