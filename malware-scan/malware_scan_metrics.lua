-- Malware Scan Plugin - Metrics Module
-- Provides Prometheus-compatible metrics for operational monitoring
--
-- Metrics Categories:
-- - Scanner execution (total, results by outcome)
-- - Cache performance (hits, misses, hit rate)
-- - Atomic locking (acquired, wait, timeout)
-- - Latency histograms (P50, P95, P99)
-- - API cost tracking
--
-- Usage:
--   local metrics = require("malware_scan_metrics")
--   metrics.init()
--   metrics.record_scan("clamav", "clean", 150)  -- 150ms latency
--   metrics.record_cache("clamav", true)         -- Cache hit
--   metrics.record_lock_acquired("clamav")
--

local metrics = {}

-- Module version
metrics.VERSION = "0.8.0"

-- Module state
metrics.enabled = false
metrics.prometheus = nil

--------------------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------------------

-- Initialize metrics module
-- Attempts to load Prometheus library and define metrics
-- Falls back gracefully if library not available
--- @return boolean success True if initialization succeeded
function metrics.init()
	-- Try to load Prometheus library
	local ok, prometheus = pcall(require, "prometheus")

	if not ok then
		-- Prometheus library not available - metrics disabled
		metrics.enabled = false
		return false
	end

	-- Initialize Prometheus with namespace
	metrics.prometheus = prometheus.init("plugin_malware_scan", {sync_interval=1})
	metrics.enabled = true

	-- ==========================================================================
	-- SCANNER EXECUTION METRICS
	-- ==========================================================================

	-- Total scans/queries per scanner (labels: scanner)
	metrics.scan_total = metrics.prometheus:counter(
		"scanner_total",
		"Total number of scans or API queries executed per scanner",
		{"scanner"}  -- scanner: clamav, virustotal, sentinelone
	)

	-- Scan results by scanner and outcome (labels: scanner, result)
	metrics.scan_result = metrics.prometheus:counter(
		"scanner_result_total",
		"Scan results by scanner and outcome (clean, malicious, error)",
		{"scanner", "result"}  -- result: clean, malicious, error, api_circuit_breaker
	)

	-- ==========================================================================
	-- CACHE PERFORMANCE METRICS
	-- ==========================================================================

	-- Cache hits per scanner (labels: scanner)
	metrics.cache_hits = metrics.prometheus:counter(
		"cache_hits_total",
		"Number of cache hits per scanner",
		{"scanner"}
	)

	-- Cache misses per scanner (labels: scanner)
	metrics.cache_misses = metrics.prometheus:counter(
		"cache_misses_total",
		"Number of cache misses per scanner",
		{"scanner"}
	)

	-- ==========================================================================
	-- ATOMIC LOCKING METRICS
	-- ==========================================================================

	-- Locks acquired per scanner (labels: scanner)
	metrics.lock_acquired = metrics.prometheus:counter(
		"lock_acquired_total",
		"Number of locks acquired (scanner performed scan/query)",
		{"scanner"}
	)

	-- Lock waits per scanner (labels: scanner)
	metrics.lock_wait = metrics.prometheus:counter(
		"lock_wait_total",
		"Number of times waited for concurrent scan/query result",
		{"scanner"}
	)

	-- Lock wait timeouts per scanner (labels: scanner)
	metrics.lock_timeout = metrics.prometheus:counter(
		"lock_timeout_total",
		"Number of lock wait timeouts (fell back to independent scan/query)",
		{"scanner"}
	)

	-- ==========================================================================
	-- LATENCY METRICS (HISTOGRAMS)
	-- ==========================================================================

	-- Scanner latency distribution (labels: scanner)
	-- Buckets: 10ms, 50ms, 100ms, 500ms, 1s, 2s, 5s, 10s
	metrics.scan_latency = metrics.prometheus:histogram(
		"scanner_latency_seconds",
		"Scanner execution latency distribution in seconds",
		{"scanner"},
		{0.01, 0.05, 0.1, 0.5, 1, 2, 5, 10}
	)

	-- ==========================================================================
	-- FILE PROCESSING METRICS
	-- ==========================================================================

	-- Total files processed
	metrics.files_total = metrics.prometheus:counter(
		"files_processed_total",
		"Total number of files processed"
	)

	-- Files blocked (malware detected)
	metrics.files_blocked = metrics.prometheus:counter(
		"files_blocked_total",
		"Number of files blocked due to malware detection"
	)

	-- Files allowed (clean)
	metrics.files_allowed = metrics.prometheus:counter(
		"files_allowed_total",
		"Number of clean files allowed"
	)

	-- ==========================================================================
	-- API COST TRACKING
	-- ==========================================================================

	-- API calls per scanner (for cost calculation)
	-- Separate from scan_total because scan_total includes cache hits
	metrics.api_calls_actual = metrics.prometheus:counter(
		"api_calls_actual_total",
		"Actual API calls made (excludes cache hits)",
		{"scanner"}  -- scanner: virustotal, sentinelone
	)

	-- API calls saved by caching/locking
	metrics.api_calls_saved = metrics.prometheus:counter(
		"api_calls_saved_total",
		"API calls saved by caching and atomic locking",
		{"scanner"}
	)

	return true
end

--------------------------------------------------------------------------------
-- METRIC RECORDING FUNCTIONS
--------------------------------------------------------------------------------

-- Record scanner execution
--- @param scanner string Scanner name (clamav, virustotal, sentinelone)
--- @param result string Result type (clean, malicious, error, api_circuit_breaker)
--- @param latency_ms number Optional latency in milliseconds
function metrics.record_scan(scanner, result, latency_ms)
	if not metrics.enabled then return end

	-- Increment total scans counter
	metrics.scan_total:inc(1, {scanner})

	-- Increment result-specific counter
	metrics.scan_result:inc(1, {scanner, result})

	-- Record latency if provided
	if latency_ms and latency_ms > 0 then
		metrics.scan_latency:observe(latency_ms / 1000, {scanner})
	end
end

-- Record cache hit or miss
--- @param scanner string Scanner name
--- @param hit boolean True for cache hit, false for cache miss
function metrics.record_cache(scanner, hit)
	if not metrics.enabled then return end

	if hit then
		metrics.cache_hits:inc(1, {scanner})
		-- Cache hit = API call saved (for API scanners)
		if scanner ~= "clamav" then
			metrics.api_calls_saved:inc(1, {scanner})
		end
	else
		metrics.cache_misses:inc(1, {scanner})
	end
end

-- Record lock acquisition
--- @param scanner string Scanner name
function metrics.record_lock_acquired(scanner)
	if not metrics.enabled then return end

	metrics.lock_acquired:inc(1, {scanner})
end

-- Record lock wait (thread waited for concurrent scan/query result)
--- @param scanner string Scanner name
--- @param timeout boolean True if wait timed out, false if got result
function metrics.record_lock_wait(scanner, timeout)
	if not metrics.enabled then return end

	if timeout then
		-- Timeout - fell back to independent scan/query
		metrics.lock_timeout:inc(1, {scanner})
	else
		-- Successful wait - got result from concurrent scan
		metrics.lock_wait:inc(1, {scanner})
		-- Wait succeeded = API call/scan saved
		metrics.api_calls_saved:inc(1, {scanner})
	end
end

-- Record actual API call (not from cache)
-- Call this when actually making an HTTP request to an API
--- @param scanner string Scanner name (virustotal, sentinelone)
function metrics.record_api_call(scanner)
	if not metrics.enabled then return end

	metrics.api_calls_actual:inc(1, {scanner})
end

-- Record file processed
--- @param blocked boolean True if file was blocked (malware), false if allowed (clean)
function metrics.record_file(blocked)
	if not metrics.enabled then return end

	metrics.files_total:inc(1)

	if blocked then
		metrics.files_blocked:inc(1)
	else
		metrics.files_allowed:inc(1)
	end
end

--------------------------------------------------------------------------------
-- METRICS EXPORT
--------------------------------------------------------------------------------

-- Collect and return Prometheus-formatted metrics
-- Call this from /metrics endpoint handler
--- @return string metrics Prometheus text format metrics
function metrics.collect()
	if not metrics.enabled or not metrics.prometheus then
		return "# Metrics not enabled - install lua-resty-prometheus\n"
	end

	return metrics.prometheus:collect()
end

return metrics
