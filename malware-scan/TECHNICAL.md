# Technical Documentation - Malware Scan Plugin

**Version**: 0.8.0 | **Last Updated**: 2026-01-27

This document provides technical details for developers working on the malware-scan plugin.

## Table of Contents

- [Architecture](#architecture)
- [File Structure](#file-structure)
- [Scanning Flow](#scanning-flow)
- [Security Features](#security-features)
- [Caching Strategy](#caching-strategy)
- [Module System](#module-system)
- [API Endpoints](#api-endpoints)
- [Error Handling](#error-handling)
- [Development](#development)

## Architecture

### Plugin Structure

The plugin follows a modular architecture with 21 specialized components:

```
malware-scan/
â”œâ”€â”€ malware-scan.lua               # Main entry point & request handling
â”œâ”€â”€ malware_scan_init.lua          # Module initialization & dependency injection
â”œâ”€â”€ malware_scan_orchestrator.lua  # Scanning workflow coordination
â”œâ”€â”€ malware_scan_cache.lua         # Caching & Redis operations (circuit breaker)
â”œâ”€â”€ malware_scan_database.lua      # Database operations & Redis connection pooling
â”œâ”€â”€ malware_scan_file.lua          # File operations (multipart parsing, hashing, cleanup)
â”œâ”€â”€ malware_scan_filetypes.lua     # File type validation & magic byte detection
â”œâ”€â”€ malware_scan_clamav.lua        # ClamAV INSTREAM protocol integration
â”œâ”€â”€ malware_scan_virustotal.lua    # VirusTotal v3 API integration
â”œâ”€â”€ malware_scan_sentinelone.lua   # SentinelOne threat intelligence API
â”œâ”€â”€ malware_scan_webhook.lua       # Discord & Microsoft Teams notifications
â”œâ”€â”€ malware_scan_utils.lua         # Utility functions (sanitization, validation)
â”œâ”€â”€ malware_scan_logger.lua        # Structured logging with masking
â”œâ”€â”€ malware_scan_config.lua        # Configuration variables & defaults
â”œâ”€â”€ malware_scan_malwarebazaar.lua # MalwareBazaar hash database integration
â”œâ”€â”€ malware_scan_custom_hashes.lua # Custom malware hash database support
â”œâ”€â”€ malware_scan_multipart_full_scan.lua # Full body multipart scanning
â”œâ”€â”€ malware_scan_api.lua           # Internal API endpoints (/malware-scan/*)
â”œâ”€â”€ malware_scan_scheduler.lua     # Job scheduling (hash DB updates)
â”œâ”€â”€ malware_scan_metrics.lua       # Performance metrics collection
â”œâ”€â”€ malware_scan_ui_metrics.lua    # Dashboard metrics UI integration
â””â”€â”€ plugin.json                    # Plugin metadata & configuration
```

**Total**: 21 modules providing comprehensive, maintainable architecture

### Design Principles

1. **Separation of Concerns**: Each module handles a specific domain (scanning, caching, APIs, etc.)
2. **Single Responsibility**: Modules have one clear purpose (e.g., ClamAV integration, Discord webhooks)
3. **Explicit Dependencies**: Modules receive dependencies via setter functions to avoid circular imports
4. **Fail-Safe Design**: Module load failures don't crash the pluginâ€”graceful degradation with fallbacks
5. **Idempotent Operations**: Safe to call functions multiple times without side effects
6. **Cluster-Ready**: Works correctly on both BunkerWeb manager and worker nodes
7. **Optional Dependencies**: Core features work even if optional libraries (lfs) unavailable

## File Structure

> **Note**: The 21 modules work together in a coordinated architecture. The sections below describe the major components. For complete details on all modules, see the source code comments in each file.

### malware-scan.lua (Main Entry Point)

**Purpose**: Coordinates scanning workflow and module interaction

**Key Functions**:
```lua
function malware_scan:initialize(ctx)        -- Plugin initialization
function malware_scan:init_worker()          -- Worker-level setup
function malware_scan:access()               -- Request interception (main entry point)
function malware_scan:api()                  -- API endpoints
function malware_scan:is_debug()             -- Debug check utility
function malware_scan:log_debug(message)     -- Debug logging
function malware_scan:mask_sensitive(value)  -- Sensitive data masking
```

**Module Loading Pattern**:
```lua
local cache = nil
local cache_load_ok, cache_load_err = pcall(function()
	cache = require("malware_scan_cache")
end)
if not cache_load_ok then
	-- Log error but continue (graceful degradation)
end

-- Initialize dependencies
if cache and clamav then
	clamav.set_cache_module(cache)
end
```

### malware_scan_cache.lua (Caching Layer)

**Purpose**: High-performance caching with circuit breaker pattern

**Key Features**:
- Local cachestore (BunkerWeb shared dict)
- Differential TTL (clean: 5min, malicious: 24h, max 7d)
- SHA256-based cache keys
- Per-scanner cache namespaces

**Cache Functions**:
```lua
-- ClamAV cache (v0.7.0)
cache.is_in_clamav_cache(plugin, checksum)   -- Check ClamAV result cache
cache.add_to_clamav_cache(plugin, checksum, value)  -- Store ClamAV result

-- VirusTotal cache
cache.is_in_vt_cache(plugin, checksum)       -- Check VT result cache
cache.add_to_vt_cache(plugin, checksum, value)  -- Store VT result

-- SentinelOne cache
cache.is_in_sentinelone_cache(plugin, checksum)
cache.add_to_sentinelone_cache(plugin, checksum, value)
```

**Cache Key Format**:
```
plugin_malware_scan_clamav_{sha256}      # ClamAV results
plugin_malware_scan_virustotal_{sha256}          # VirusTotal results
plugin_malware_scan_sentinelone_{sha256} # SentinelOne results
```

### malware_scan_file.lua (File Operations)

**Purpose**: Safe file handling and hashing

**Key Functions**:
```lua
file_ops.get_file_size(plugin, file_path)              -- Get file size
file_ops.calculate_sha256(plugin, file_path)           -- Calculate SHA256 hash
file_ops.extract_filename_from_upload(plugin, body)    -- Parse multipart filename
file_ops.extract_file_content(plugin, body_file)       -- Extract file from multipart
file_ops.cleanup_file(plugin, file_path)               -- Delete temp file
file_ops.cleanup_orphaned_files(plugin, max_age)       -- Clean old files
file_ops.share_detected_file(plugin, ...)              -- Share with VT
```

**Security**:
- Binary mode (`rb`/`wb`) - no code execution risk
- Trusted paths only (os.tmpname())
- Memory-safe string handling
- Boundary escaping for pattern matching

### malware_scan_clamav.lua (ClamAV Integration)

**Purpose**: ClamAV INSTREAM protocol implementation

**Key Functions**:
```lua
clamav.scan_file_instream(plugin, file_path)  -- Scan file via INSTREAM
clamav.socket(plugin)                          -- Create ClamAV socket
clamav.command(plugin, cmd)                    -- Send ClamAV command
```

**INSTREAM Protocol**:
1. Connect to ClamAV daemon (TCP socket)
2. Send `zINSTREAM\0` command
3. Stream file in 2048-byte chunks with size prefix
4. Send EOF (4-byte zero)
5. Parse response for virus name

**Advantages**:
- No file permission issues (streams content)
- Works with temp files
- Fast binary transfer
- Efficient for large files

### malware_scan_virustotal.lua (VirusTotal API)

**Purpose**: VirusTotal v3 API integration

**Key Functions**:
```lua
virustotal.check_virustotal(plugin, file_path, checksum)  -- Main VT check
virustotal.virustotal_request(plugin, url)                -- HTTP API call
virustotal.get_virustotal_result(plugin, response)        -- Parse response
virustotal.virustotal_upload_file(plugin, file_path)      -- Upload to VT
virustotal.virustotal_vote(plugin, checksum, verdict)     -- Vote on file
```

**API Workflow**:
1. Check cache for existing result
2. Query VT by SHA256 hash
3. If unknown & configured â†’ upload file
4. Parse detection stats (malicious/suspicious/harmless)
5. Cache result with differential TTL
6. Optionally vote on uploaded files

### malware_scan_webhook.lua (Notifications)

**Purpose**: Discord and Microsoft Teams webhook integration

**Key Functions**:
```lua
webhook.send_notification(plugin, checksum, detections)  -- Send webhook
webhook.send_discord_webhook(plugin, payload)            -- Discord-specific
webhook.send_teams_webhook(plugin, payload)              -- Teams-specific
```

**Payload Format**:
```json
{
  "content": "ðŸš¨ Malware Detected!",
  "embeds": [{
    "title": "Malware Detection Alert",
    "description": "File SHA256: 2546dcffc5ad854d...",
    "fields": [
      {"name": "Scanner", "value": "ClamAV"},
      {"name": "Detection", "value": "Eicar-Test-Signature"}
    ],
    "color": 15158332,
    "timestamp": "2026-01-18T20:02:48Z"
  }]
}
```

## Scanning Flow

### Multipart Upload Scanning Strategy

**Two Scanning Modes** (configurable via `MALWARE_SCAN_SCAN_FULL_MULTIPART_BODY`):

1. **Individual File Extraction Only** (default, recommended):
   - Skip scanning full multipart body (random HTTP boundaries make caching useless)
   - Extract individual files from multipart upload
   - Scan each file separately with consistent SHA256 (enables caching)
   - 75% faster on repeat uploads due to effective caching

2. **Full Body + Individual Files** (legacy mode, not recommended):
   - Scan entire multipart request body first
   - Then extract and scan individual files
   - Full body SHA256 changes every upload (random boundaries), wasting resources
   - Only useful if malware might be split across multipart boundaries (extremely rare)

**Why Random Boundaries Break Caching:**
```
Upload 1:                              Upload 2:
------WebKitBoundaryRaNd0m123          ------WebKitBoundaryDiFf3r3nt456
Content-Disposition: ...               Content-Disposition: ...
[same file bytes]                      [same file bytes]
------WebKitBoundaryRaNd0m123--        ------WebKitBoundaryDiFf3r3nt456--

SHA256(Upload 1) â‰  SHA256(Upload 2)    â† Different boundaries = different hash!
BUT:
SHA256(file bytes) = SHA256(file bytes) â† Individual files always match!
```

### Complete Request Flow

```
1. Request Arrives (POST /upload)
   â†“
2. access() Phase Triggered
   â†“
3. Check Content-Type (multipart/form-data?)
   â”œâ”€â†’ No: ALLOW (not a file upload)
   â””â”€â†’ Yes: Continue
   â†“
4. Read Request Body
   â†“
5. Check MALWARE_SCAN_SCAN_FULL_MULTIPART_BODY
   â”œâ”€â†’ yes: Continue to step 6 (scan full body)
   â””â”€â†’ no (default): Skip to step 11 (extract files directly)
   â†“
6. Calculate SHA256 Hash (full body)
   â†“
7. Check ClamAV Cache
   â”œâ”€â†’ HIT (malicious): BLOCK (instant, skip ClamAV)
   â”œâ”€â†’ HIT (clean): Continue to step 8
   â””â”€â†’ MISS: Continue to step 8
   â†“
8. Check Cloud Scanner Caches (if enabled)
   â”œâ”€â†’ VirusTotal HIT (malicious): BLOCK
   â””â”€â†’ All clean or miss: Continue
   â†“
9. ClamAV INSTREAM Scan
   â”œâ”€â†’ Malicious: Cache result, send webhook
   â”‚   â”œâ”€â†’ Fast Mode: BLOCK (skip cloud scanners)
   â”‚   â””â”€â†’ Full Mode: Continue to cloud scanners
   â””â”€â†’ Clean: Cache result, continue
   â†“
10. Cloud Scanners (if ClamAV clean or Full Mode)
    â”œâ”€â†’ VirusTotal API: Check hash
    â”‚   â””â”€â†’ Malicious: Cache, webhook, BLOCK
    â””â”€â†’ SentinelOne API: Check threat intel
        â””â”€â†’ Threat: Cache, webhook, BLOCK
   â†“
11. All Clean: ALLOW (cache clean results)
```

### Decision Tree

```
                    File Upload
                         |
                   [Content-Type?]
                    /         \
               multipart    other
                 /             \
           [SHA256]          ALLOW
              |
        [ClamAV Cache?]
          /      \
    HIT/mal    MISS/clean
      |           |
   BLOCK    [Cloud Cache?]
              /      \
        HIT/mal    MISS/clean
          |           |
       BLOCK    [ClamAV Scan]
                  /      \
           malicious    clean
              |           |
          [Fast Mode?]  [Cloud Scans]
           /      \       /      \
         yes      no    mal    clean
          |        |     |       |
       BLOCK   [Cloud] BLOCK  ALLOW
                  |
              [Result?]
               /      \
            mal      clean
             |         |
          BLOCK     ALLOW
```

## Security Features

### 1. Defense-in-Depth

**Multiple Layers**:
- Filename validation (path traversal, null bytes, length)
- File type magic bytes (not extension-based)
- Local ClamAV signatures (~10M+ patterns)
- Cloud threat intelligence (VirusTotal, SentinelOne)
- Cache-first optimization (known malware blocked instantly)

### 2. Filename Validation

**Checks Performed**:
```lua
-- Path traversal
if filename:match("%.%.") or filename:match("/") or filename:match("\\") then
    BLOCK("Path traversal attempt detected")
end

-- Null byte injection
if filename:match("%z") then
    BLOCK("Null byte injection detected")
end

-- Excessive length
if #filename > 255 then
    BLOCK("Filename too long")
end
```

**Threat Scenarios**:
- `../../etc/passwd` â†’ Path traversal attempt
- `safe.jpg%00.php` â†’ Null byte C string truncation
- `aaaaa...` (300 chars) â†’ Buffer overflow attempt

### 3. Boundary Pattern Escaping

**Attack**: Inject Lua patterns in multipart boundary

**Mitigation**:
```lua
-- Escape magic characters before pattern matching
local escaped_boundary = boundary:gsub("([%(%)%.%%%+%-%*%?%[%^%$])", "%%%1")
```

**Prevents**:
- Pattern injection (`%w+` â†’ literal `%w+`)
- DOS via catastrophic backtracking

### 4. Trusted File Paths

**Never use client-provided filenames for file operations**:
```lua
-- WRONG (path traversal vulnerability)
local temp_file = "/tmp/" .. client_filename

-- CORRECT (system-generated path)
local temp_file = os.tmpname()
```

### 5. Memory Safety

**Lua guarantees**:
- No buffer overflows (string handling is memory-safe)
- No code execution (files opened in binary mode only)
- Automatic garbage collection

### 6. File Size Limits

**Prevents resource exhaustion**:
```lua
-- ClamAV limit (default: 25MB)
if file_size > MALWARE_SCAN_CLAMAV_MAX_SIZE then
    skip_clamav()
end

-- Hash scanner limit (default: 64MB)
if file_size > MALWARE_SCAN_HASH_MAX_SIZE then
    skip_hash_calculation()
end
```

## Caching Strategy

### Cache Types

**Local Cache (BunkerWeb shared dict)**:
- Fastest (~1ms lookup)
- Shared across workers on same node
- Lost on restart
- Used for all scanners

### Differential TTL (Configurable)

**Clean Results**: Default 5 minutes (300 seconds)
- Configurable via `MALWARE_SCAN_CACHE_CLEAN_TTL`
- Shorter TTL prevents false negatives
- File could become flagged by new signatures
- Balance between performance and accuracy

**Malicious Results**: Default 90 days (7,776,000 seconds)
- Configurable via `MALWARE_SCAN_CACHE_VIRUS_TTL`
- Maximum 7 days (604,800 seconds) to prevent table growth
- Longer TTL for known malware
- Unlikely to become clean
- Faster blocking on repeat attacks
- Prevents cache table from growing unbounded

### Cache Performance

**Metrics** (v0.7.0):
- Cache miss (first upload): ~4 seconds (full scan)
- Cache hit (repeat upload): ~1 second (hash + lookup)
- **75% faster** on cached files

**Cache Hit Rate** (typical production):
- Legitimate files: ~60% (users upload same attachments)
- Malware: ~95% (attackers retry same payloads)

## Module System

### Module Loading

**Unconditional Loading** (cluster-compatible):
```lua
-- Load at file level (before class definition)
local cache = nil
local cache_load_ok, cache_load_err = pcall(function()
	cache = require("malware_scan_cache")
end)
```

**Why Unconditional?**:
- Variables not available during init phase on worker nodes
- Modules needed even if features disabled (cluster consistency)
- Fail-safe design (missing module doesn't crash plugin)

### Dependency Injection

**Pattern**:
```lua
-- In module
local _cache = nil

function module.set_cache_module(cache_mod)
	_cache = cache_mod
end

function module.check_cache(...)
	if _cache then
		return _cache.is_in_cache(...)
	end
	return false, nil  -- Graceful fallback
end
```

**Benefits**:
- Testable (can inject mock modules)
- Explicit dependencies
- No circular dependencies

### Module Call Pattern

**WRONG** (loses second+ return values):
```lua
ok, result = module and module.func() or self:func()
```

**CORRECT** (explicit if-then-else):
```lua
if module then
	ok, result = module.func(self, ...)
else
	self.logger:log(ERR, "Module not loaded")
	ok, result = false, "Module error"
end
```

**Why?**: Lua's `and/or` operators only return first value from multi-return functions.

## API Endpoints

**Internal BunkerWeb API only** (not directly accessible via HTTP)

### POST /malware-scan/ping

Test ClamAV connectivity:
```json
{
  "status": "success",
  "message": "PONG response from ClamAV"
}
```

### POST /malware-scan/test-eicar

Test malware detection with EICAR:
```json
{
  "status": "success",
  "detected": "Eicar-Test-Signature"
}
```

### POST /malware-scan/virustotal-ping

Test VirusTotal API:
```json
{
  "status": "success",
  "message": "VirusTotal API is reachable"
}
```

## Error Handling

### Failure Modes

**ClamAV Connection Failed**:
- Log error
- Skip ClamAV scan
- Continue with hash-based scanners
- **Fail-open** (allow if all scanners fail)

**Module Load Failed**:
- Log error with stack trace
- Continue without module
- Fallback to available scanners

**API Rate Limit Hit**:
- Log warning
- Return cached result if available
- Continue with other scanners

### Graceful Degradation

**Philosophy**: Better to allow clean files than block legitimate uploads on error

**Example**:
```
All scanners fail â†’ ALLOW (with warning logged)
ClamAV fails, VT succeeds â†’ Use VT result
VT rate limited â†’ Use cached result or allow
```

## Development

### Adding a New Scanner

1. **Create module file** (`malware_scan_newscan.lua`)
2. **Implement interface**:
   ```lua
   local newscan = {}

   function newscan.set_cache_module(cache_mod)
   function newscan.check_newscan(plugin, checksum)
       -- Return: ok (boolean), result (string)
   end

   return newscan
   ```

3. **Load in main file**:
   ```lua
   local newscan = nil
   pcall(function() newscan = require("malware_scan_newscan") end)
   ```

4. **Add cache functions** (in cache module)
5. **Update scanning flow** (in access() function)
6. **Add variables** (in plugin.json)

### Testing

**Unit Testing**:
```lua
-- Test with mock modules
local mock_cache = {
    is_in_cache = function() return true, "malicious" end
}
module.set_cache_module(mock_cache)
assert(module.check_cache(...) == "malicious")
```

**Integration Testing**:
```bash
# Test with EICAR file
curl -F "file=@eicar.txt" https://test.example.com/upload
# Expected: 403 Forbidden

# Test caching
curl -F "file=@eicar.txt" https://test.example.com/upload  # Miss
curl -F "file=@eicar.txt" https://test.example.com/upload  # Hit
# Second should be faster
```

### Syntax Validation

```bash
# Check all Lua files
luac -p *.lua

# Check syntax only
luac -p malware-scan.lua && echo "OK"
```

### Performance Profiling

**Enable debug logging**:
```bash
MALWARE_SCAN_DEBUG=yes
```

**Monitor metrics**:
- Cache hit rate: `grep "CACHE_HIT" nginx.log | wc -l`
- ClamAV scan time: `grep "scan_file returned" nginx.log`
- API response time: `grep "VirusTotal" nginx.log`

### Code Style

**Conventions**:
- Indentation: Tabs (BunkerWeb standard)
- Line length: <120 characters
- Comments: Clear and concise
- Error handling: Always check return values
- Logging: Use appropriate log levels (ERR, WARN, NOTICE, INFO)

**Example**:
```lua
function module.function_name(plugin, param1, param2)
	-- Clear description of what this does
	if not param1 then
		plugin.logger:log(ERR, "param1 is required")
		return false, "missing parameter"
	end

	-- Implementation
	local result = do_something(param1, param2)

	-- Always return status + result
	return true, result
end
```

