-- API Handler Module for Malware Scan Plugin
-- Handles test/diagnostic API endpoints
--
-- Endpoints:
--   POST /malware-scan/ping                 - Test ClamAV connectivity
--   POST /malware-scan/test-eicar           - Test ClamAV malware detection with EICAR
--   POST /malware-scan/virustotal-ping      - Test VirusTotal API connectivity
--   POST /malware-scan/malwarebazaar-stats  - Get MalwareBazaar hash database statistics
--   POST /malware-scan/clamav-stats         - Get ClamAV version and definition statistics
--   POST /malware-scan/test-discord         - Test Discord webhook connectivity
--   POST /malware-scan/test-teams           - Test Microsoft Teams webhook connectivity
--
-- Version: 0.8.0
-- Date: 2026-01-27

local api = {}

-- Module version
api.VERSION = "0.8.0"

-- Get required modules
local cjson = require("cjson")
local logger = require("malware_scan_logger")
local utils = require("malware_scan_utils")
local database = require("malware_scan_database")
local clamav = require("malware_scan_clamav")
local virustotal = require("malware_scan_virustotal")
local http = require("resty.http")

local encode = cjson.encode

local ngx = ngx
local HTTP_OK = ngx.HTTP_OK
local HTTP_INTERNAL_SERVER_ERROR = ngx.HTTP_INTERNAL_SERVER_ERROR

-- ============================================================================
-- CLAMAV API ENDPOINTS
-- ============================================================================

-- Test ClamAV connectivity with PING command
-- Also includes MalwareBazaar and ClamAV statistics in response
--- @param plugin table Plugin instance
--- @return boolean success Success flag
--- @return string response JSON response
--- @return number status HTTP status code
function api.clamav_ping(plugin)
	if plugin.variables["USE_MALWARE_SCANNER"] ~= "yes" then
		local response = encode({
			status = "warning",
			message = "Malware scan plugin not enabled"
		})
		return true, response, HTTP_OK
	end

	local ok, data = clamav.command(plugin, "PING")
	if not ok then
		local response = encode({
			status = "error",
			message = "connectivity with ClamAV failed : " .. tostring(data)
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end
	if data ~= "PONG" then
		local response = encode({
			status = "error",
			message = "wrong data received from ClamAV : " .. tostring(data)
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	-- Build response with stats
	local response_data = {
		status = "success",
		message = "ClamAV is operational"
	}

	-- Add MalwareBazaar stats if enabled
	if plugin.variables["MALWARE_SCAN_MALWAREBAZAAR_HASH_LOOKUP"] == "yes" and database.is_available(plugin) then
		local buckets = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"}
		local total_hashes = 0

		for _, bucket in ipairs(buckets) do
			local bucket_key = "malware_scan:hashes:" .. bucket
			local count = database.hlen(plugin, bucket_key)
			if count and type(count) == "number" then
				total_hashes = total_hashes + count
			end
		end

		-- Get database state
		local full_state = database.redis_get(plugin, "malware-scan:hashes:state:full") or "never"
		local recent_state = database.redis_get(plugin, "malware-scan:hashes:state:recent") or "never"
		local import_state = database.redis_get(plugin, "malware-scan:hashes:import_state") or "idle"
		local full_start_time = database.redis_get(plugin, "malware-scan:hashes:import_start_time:full")
		local full_end_time = database.redis_get(plugin, "malware-scan:hashes:import_end_time:full")
		local recent_start_time = database.redis_get(plugin, "malware-scan:hashes:import_start_time:recent")
		local recent_end_time = database.redis_get(plugin, "malware-scan:hashes:import_end_time:recent")
		local full_download_ever = database.redis_get(plugin, "malware_scan:full_download_ever_done")

			response_data.malwarebazaar = {
				total_hashes = total_hashes,
				buckets = 16,
				full_db_status = full_state,
				recent_db_status = recent_state,
				import_status = import_state,
				full_import_start_time = (full_start_time and full_start_time ~= ngx.null) and full_start_time or nil,
				full_import_end_time = (full_end_time and full_end_time ~= ngx.null) and full_end_time or nil,
				recent_import_start_time = (recent_start_time and recent_start_time ~= ngx.null) and recent_start_time or nil,
				recent_import_end_time = (recent_end_time and recent_end_time ~= ngx.null) and recent_end_time or nil,
				initialized = full_download_ever ~= nil and full_download_ever ~= ngx.null,
			import_progress = {
				full = {
					total = tonumber(database.redis_get(plugin, "malware-scan:hashes:import_total:full")) or 0,
					processed = (function()
						local sum = 0
						for _, bucket in ipairs(buckets) do
							sum = sum + (tonumber(database.redis_get(plugin, "malware-scan:hashes:import_processed:full:bucket_" .. bucket)) or 0)
						end
						return sum
					end)()
				},
				recent = {
					total = tonumber(database.redis_get(plugin, "malware-scan:hashes:import_total:recent")) or 0,
					processed = (function()
						local sum = 0
						for _, bucket in ipairs(buckets) do
							sum = sum + (tonumber(database.redis_get(plugin, "malware-scan:hashes:import_processed:recent:bucket_" .. bucket)) or 0)
						end
						return sum
					end)()
				}
			}
		}
	end

	-- Add ClamAV version stats
	local version_ok, version_data = clamav.command(plugin, "VERSION")
	if version_ok then
		local clamav_version = (version_data and version_data:match("ClamAV ([^/]+)")) or "unknown"
		local definition_version = (version_data and version_data:match("/(%d+)/")) or "unknown"
		local definition_date = (version_data and version_data:match("/%d+/(.+)$")) or "unknown"

		response_data.clamav_stats = {
			version = clamav_version,
			definitions = definition_version,
			updated = definition_date
		}
	end

	local response = encode(response_data)
	return true, response, HTTP_OK
end

-- Test ClamAV malware detection with EICAR test file
--- @param plugin table Plugin instance
--- @return boolean success Success flag
--- @return string response JSON response
--- @return number status HTTP status code
function api.clamav_test_eicar(plugin)
	if plugin.variables["USE_MALWARE_SCANNER"] ~= "yes" then
		local response = encode({
			status = "warning",
			message = "Malware scan plugin not enabled"
		})
		return true, response, HTTP_OK
	end

	-- EICAR test virus string
	local eicar = "X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"

	logger.log_error("Testing ClamAV with EICAR test file")
	local ok, detected = clamav.scan_content_instream(plugin, eicar)

	if not ok then
		local response = encode({
			status = "error",
			message = "ClamAV scan failed: " .. tostring(detected)
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	if detected == "clean" then
		local response = encode({
			status = "error",
			message = "WARNING: ClamAV did not detect EICAR test file (expected: Eicar-Signature, got: clean)"
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	-- Successfully detected EICAR
	local response = encode({
		status = "success",
		message = "ClamAV successfully detected EICAR test file: " .. tostring(detected)
	})
	return true, response, HTTP_OK
end

-- ============================================================================
-- STATISTICS API ENDPOINTS
-- ============================================================================

-- Get MalwareBazaar hash database statistics
-- Returns count of hashes across all 16 Redis buckets
--- @param plugin table Plugin instance
--- @return boolean success Success flag
--- @return string response JSON response
--- @return number status HTTP status code
function api.malwarebazaar_stats(plugin)
	if plugin.variables["USE_MALWARE_SCANNER"] ~= "yes" then
		local response = encode({
			status = "warning",
			message = "Malware scan plugin not enabled"
		})
		return true, response, HTTP_OK
	end

	if plugin.variables["MALWARE_SCAN_MALWAREBAZAAR_HASH_LOOKUP"] ~= "yes" then
		local response = encode({
			status = "success",
			total_hashes = 0,
			message = "MalwareBazaar hash lookup not enabled"
		})
		return true, response, HTTP_OK
	end

	if not database.is_available(plugin) then
		local response = encode({
			status = "error",
			message = "Redis not available"
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	-- Count hashes across all 16 buckets (0-9, A-F)
	local buckets = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"}
	local total_hashes = 0
	local bucket_counts = {}

	for _, bucket in ipairs(buckets) do
		local bucket_key = "malware_scan:hashes:" .. bucket
		local count = database.hlen(plugin, bucket_key)
		if count and type(count) == "number" then
			total_hashes = total_hashes + count
			bucket_counts[bucket] = count
		else
			bucket_counts[bucket] = 0
		end
	end

	-- Get hash database state information
	local full_state = database.redis_get(plugin, "malware-scan:hashes:state:full") or "never"
	local recent_state = database.redis_get(plugin, "malware-scan:hashes:state:recent") or "never"
	local import_state = database.redis_get(plugin, "malware-scan:hashes:import_state") or "unknown"
	local full_download_ever = database.redis_get(plugin, "malware_scan:full_download_ever_done")

	-- Get import progress information
	local full_import_total = tonumber(database.redis_get(plugin, "malware-scan:hashes:import_total:full")) or 0
	local recent_import_total = tonumber(database.redis_get(plugin, "malware-scan:hashes:import_total:recent")) or 0

	-- Sum up processed counts from all 16 buckets
	local full_import_processed = 0
	local recent_import_processed = 0
	for _, bucket in ipairs(buckets) do
		local full_processed = tonumber(database.redis_get(plugin, "malware-scan:hashes:import_processed:full:bucket_" .. bucket)) or 0
		local recent_processed = tonumber(database.redis_get(plugin, "malware-scan:hashes:import_processed:recent:bucket_" .. bucket)) or 0
		full_import_processed = full_import_processed + full_processed
		recent_import_processed = recent_import_processed + recent_processed
	end

	local response = encode({
		status = "success",
		total_hashes = total_hashes,
		bucket_counts = bucket_counts,
		buckets = 16,
		database_state = {
			full_download_status = full_state,
			recent_download_status = recent_state,
			import_status = import_state,
			full_database_initialized = full_download_ever ~= nil and full_download_ever ~= ngx.null
		},
		import_progress = {
			full = {
				total = full_import_total,
				processed = full_import_processed
			},
			recent = {
				total = recent_import_total,
				processed = recent_import_processed
			}
		}
	})
	return true, response, HTTP_OK
end

-- Get ClamAV virus definition statistics
-- Returns version and definition information
--- @param plugin table Plugin instance
--- @return boolean success Success flag
--- @return string response JSON response
--- @return number status HTTP status code
function api.clamav_stats(plugin)
	if plugin.variables["USE_MALWARE_SCANNER"] ~= "yes" then
		local response = encode({
			status = "warning",
			message = "Malware scan plugin not enabled"
		})
		return true, response, HTTP_OK
	end

	-- Get ClamAV version info
	local ok, version_data = clamav.command(plugin, "VERSION")
	if not ok then
		local response = encode({
			status = "error",
			message = "Failed to get ClamAV version: " .. tostring(version_data)
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	-- Parse version string (format: "ClamAV 1.0.0/26000/Mon Jan 1 12:00:00 2024")
	local clamav_version = (version_data and version_data:match("ClamAV ([^/]+)")) or "unknown"
	local definition_version = (version_data and version_data:match("/(%d+)/")) or "unknown"
	local definition_date = (version_data and version_data:match("/%d+/(.+)$")) or "unknown"

	local response = encode({
		status = "success",
		clamav_version = clamav_version,
		definition_version = definition_version,
		definition_date = definition_date,
		raw_version = version_data
	})
	return true, response, HTTP_OK
end

-- ============================================================================
-- WEBHOOK TEST ENDPOINTS
-- ============================================================================

-- Test Discord webhook connectivity
-- Sends a test notification to verify webhook configuration
--- @param plugin table Plugin instance
--- @return boolean success Success flag
--- @return string response JSON response
--- @return number status HTTP status code
function api.test_discord(plugin)
	if plugin.variables["USE_MALWARE_SCANNER"] ~= "yes" then
		local response = encode({
			status = "warning",
			message = "Malware scan plugin not enabled"
		})
		return true, response, HTTP_OK
	end

	local discord_url = plugin.variables["MALWARE_SCAN_DISCORD_WEBHOOK_URL"]
	if not discord_url or discord_url == "" or discord_url == "your_webhook_url" then
		local response = encode({
			status = "error",
			message = "Discord webhook not configured"
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	-- Parse URL
	local url_parts, err = utils.parse_webhook_url(discord_url)
	if not url_parts then
		local response = encode({
			status = "error",
			message = "Invalid Discord webhook URL: " .. tostring(err)
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	-- Build test message (Discord format)
	local test_payload = encode({
		embeds = {
			{
				title = "âœ… Discord Webhook Test",
				description = "This is a test message from BunkerWeb Malware Scanner",
				color = 65280,  -- Green color
				fields = {
					{name = "Status", value = "Webhook is configured correctly", inline = false},
					{name = "Instance", value = ngx.var.hostname or "unknown", inline = true},
					{name = "Test Time", value = os.date("!%Y-%m-%d %H:%M:%S UTC"), inline = true}
				},
				timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
			}
		}
	})

	-- Send test request
	local httpc = http.new()
	httpc:set_timeout(5000)

	local ok, conn_err = httpc:connect(url_parts.host, url_parts.port)
	if not ok then
		local response = encode({
			status = "error",
			message = "Failed to connect to Discord: " .. tostring(conn_err)
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	if url_parts.ssl then
		local session, ssl_err = httpc:ssl_handshake(nil, url_parts.host, false)
		if not session then
			httpc:close()
			local response = encode({
				status = "error",
				message = "SSL handshake failed: " .. tostring(ssl_err)
			})
			return true, response, HTTP_INTERNAL_SERVER_ERROR
		end
	end

	local res, req_err = httpc:request({
		method = "POST",
		path = url_parts.path,
		headers = {
			["Host"] = url_parts.host,
			["Content-Type"] = "application/json",
			["Content-Length"] = tostring(#test_payload)
		},
		body = test_payload
	})

	httpc:close()

	if not res then
		local response = encode({
			status = "error",
			message = "Request failed: " .. tostring(req_err)
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	if res.status >= 200 and res.status < 300 then
		local response = encode({
			status = "success",
			message = "Discord webhook test successful"
		})
		return true, response, HTTP_OK
	else
		local response = encode({
			status = "error",
			message = "Discord returned HTTP " .. res.status .. ": " .. (res.body or "no body")
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end
end

-- Test Microsoft Teams webhook connectivity
-- Sends a test notification to verify webhook configuration
--- @param plugin table Plugin instance
--- @return boolean success Success flag
--- @return string response JSON response
--- @return number status HTTP status code
function api.test_teams(plugin)
	if plugin.variables["USE_MALWARE_SCANNER"] ~= "yes" then
		local response = encode({
			status = "warning",
			message = "Malware scan plugin not enabled"
		})
		return true, response, HTTP_OK
	end

	local teams_url = plugin.variables["MALWARE_SCAN_TEAMS_WEBHOOK_URL"]
	if not teams_url or teams_url == "" or teams_url == "your_webhook_url" then
		local response = encode({
			status = "error",
			message = "Microsoft Teams webhook not configured"
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	-- Parse URL
	local url_parts, err = utils.parse_webhook_url(teams_url)
	if not url_parts then
		local response = encode({
			status = "error",
			message = "Invalid Teams webhook URL: " .. tostring(err)
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	-- Build test message (Teams MessageCard format)
	local test_payload = encode({
		["@type"] = "MessageCard",
		["@context"] = "https://schema.org/extensions",
		themeColor = "00FF00",  -- Green color
		summary = "Webhook Test",
		sections = {
			{
				activityTitle = "âœ… Microsoft Teams Webhook Test",
				activitySubtitle = "This is a test message from BunkerWeb Malware Scanner",
				facts = {
					{name = "Status", value = "Webhook is configured correctly"},
					{name = "Instance", value = ngx.var.hostname or "unknown"},
					{name = "Test Time", value = os.date("!%Y-%m-%d %H:%M:%S UTC")}
				},
				markdown = true
			}
		}
	})

	-- Send test request
	local httpc = http.new()
	httpc:set_timeout(5000)

	local ok, conn_err = httpc:connect(url_parts.host, url_parts.port)
	if not ok then
		local response = encode({
			status = "error",
			message = "Failed to connect to Teams: " .. tostring(conn_err)
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	if url_parts.ssl then
		local session, ssl_err = httpc:ssl_handshake(nil, url_parts.host, false)
		if not session then
			httpc:close()
			local response = encode({
				status = "error",
				message = "SSL handshake failed: " .. tostring(ssl_err)
			})
			return true, response, HTTP_INTERNAL_SERVER_ERROR
		end
	end

	local res, req_err = httpc:request({
		method = "POST",
		path = url_parts.path,
		headers = {
			["Host"] = url_parts.host,
			["Content-Type"] = "application/json",
			["Content-Length"] = tostring(#test_payload)
		},
		body = test_payload
	})

	httpc:close()

	if not res then
		local response = encode({
			status = "error",
			message = "Request failed: " .. tostring(req_err)
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	if res.status >= 200 and res.status < 300 then
		local response = encode({
			status = "success",
			message = "Microsoft Teams webhook test successful"
		})
		return true, response, HTTP_OK
	else
		local response = encode({
			status = "error",
			message = "Teams returned HTTP " .. res.status .. ": " .. (res.body or "no body")
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end
end

-- ============================================================================
-- VIRUSTOTAL API ENDPOINTS
-- ============================================================================

-- Test VirusTotal API connectivity
-- Uses EICAR test file SHA256 to verify API access
--- @param plugin table Plugin instance
--- @return boolean success Success flag
--- @return string response JSON response
--- @return number status HTTP status code
function api.virustotal_ping(plugin)
	if plugin.variables["USE_MALWARE_SCANNER"] ~= "yes" then
		local response = encode({
			status = "warning",
			message = "Malware scan plugin not enabled"
		})
		return true, response, HTTP_OK
	end

	if plugin.variables["MALWARE_SCAN_API_USE_VIRUSTOTAL"] ~= "yes" then
		local response = encode({
			status = "error",
			message = "VirusTotal integration not enabled"
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	if not plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_KEY"]
		or plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_KEY"] == "" then
		local response = encode({
			status = "error",
			message = "VirusTotal API key not configured"
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	-- Test with EICAR test file SHA256 checksum
	local ok, found, vt_response = virustotal.virustotal_request(
		plugin,
		"/files/275a021bbfb6489e54d471899f7db9d1663fc695ec2fe2a2c4538aabf651fd0f"
	)
	if not ok then
		local response = encode({
			status = "error",
			message = "error while connecting to VirusTotal API: " .. tostring(found)
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end
	if not found then
		local response = encode({
			status = "error",
			message = "error while testing VirusTotal: EICAR test file not found on VirusTotal"
		})
		return true, response, HTTP_INTERNAL_SERVER_ERROR
	end

	local response = encode({
		status = "success",
		message = "VirusTotal API is operational"
	})
	return true, response, HTTP_OK
end

-- ============================================================================
-- MAIN API HANDLER
-- ============================================================================

-- Route API requests to appropriate handler based on endpoint
--- @param plugin table Plugin instance
--- @return boolean success Success flag
--- @return string message Status message
--- @return number|string|nil status HTTP status code or response content
function api.handle_request(plugin)
	local uri = plugin.ctx.bw.uri
	local method = plugin.ctx.bw.request_method

	-- ClamAV connectivity test
	if uri == "/malware-scan/ping" and method == "POST" then
		return api.clamav_ping(plugin)
	end

	-- ClamAV EICAR test
	if uri == "/malware-scan/test-eicar" and method == "POST" then
		return api.clamav_test_eicar(plugin)
	end

	-- VirusTotal connectivity test
	if uri == "/malware-scan/virustotal-ping" and method == "POST" then
		return api.virustotal_ping(plugin)
	end

	-- MalwareBazaar statistics
	if uri == "/malware-scan/malwarebazaar-stats" and method == "POST" then
		return api.malwarebazaar_stats(plugin)
	end

	-- ClamAV statistics
	if uri == "/malware-scan/clamav-stats" and method == "POST" then
		return api.clamav_stats(plugin)
	end

	-- Discord webhook test
	if uri == "/malware-scan/test-discord" and method == "POST" then
		return api.test_discord(plugin)
	end

	-- Teams webhook test
	if uri == "/malware-scan/test-teams" and method == "POST" then
		return api.test_teams(plugin)
	end

	-- Download full hash database
	if uri == "/malware-scan/download-full-db" and method == "GET" then
		return api.download_hash_db(plugin, "full")
	end

	-- Download recent hash database
	if uri == "/malware-scan/download-recent-db" and method == "GET" then
		return api.download_hash_db(plugin, "recent")
	end

	-- Not an API endpoint we handle
	return false, "success", nil
end

-- Download hash database file (full or recent)
--- @param plugin table Plugin instance
--- @param db_type string Database type ("full" or "recent")
--- @return boolean success Success flag
--- @return string status Status message
--- @return string|nil response JSON response or nil
function api.download_hash_db(plugin, db_type)
	local file_path
	if db_type == "full" then
		file_path = "/var/cache/bunkerweb/malware-scan/hashes_full.zip"
	elseif db_type == "recent" then
		file_path = "/var/cache/bunkerweb/malware-scan/hashes_recent.zip"
	else
		return true, "error", cjson.encode({status = "error", message = "Invalid database type"})
	end

	-- Check if file exists
	local file = io.open(file_path, "rb")
	if not file then
		logger.log_error( string.format("[v%s] [DOWNLOAD] Hash database file not found: %s", api.VERSION, file_path))
		return true, "error", cjson.encode({status = "error", message = "Hash database file not found"})
	end

	-- Read file contents
	local content = file:read("*all")
	file:close()

	if not content or #content == 0 then
		logger.log_error( string.format("[v%s] [DOWNLOAD] Hash database file is empty: %s", api.VERSION, file_path))
		return true, "error", cjson.encode({status = "error", message = "Hash database file is empty"})
	end

	-- Set response headers for file download
	local filename = db_type == "full" and "malwarebazaar_full_split.zip" or "malwarebazaar_recent_split.zip"
	ngx.header["Content-Type"] = "application/zip"
	ngx.header["Content-Disposition"] = string.format('attachment; filename="%s"', filename)
	ngx.header["Content-Length"] = #content
	ngx.header["Cache-Control"] = "no-cache, no-store, must-revalidate"
	ngx.header["Pragma"] = "no-cache"
	ngx.header["Expires"] = "0"

	logger.log_notice( string.format("[v%s] [DOWNLOAD] Serving %s hash database: %s (%d bytes)", api.VERSION, db_type, file_path, #content))

	-- Send file content
	ngx.print(content)
	return true, "success", nil
end

return api
