#!/usr/bin/env python3

"""
BunkerWeb Malware-Scan Cache Cleanup Job

Purpose:
    Explicit cache cleanup job that runs once at manager startup.
    Removes stale cache entries from Redis cache.
    Runs BEFORE hash download/update jobs to ensure clean state.

Usage:
    Called automatically by BunkerWeb scheduler as "malware-scan-cache-cleanup" job.
    Configured to run once at startup with "every": "once".

Job Configuration:
    Name: malware-scan-cache-cleanup
    Trigger: once (at startup)
    Reload: false
    Async: true

Behavior:
    When USE_MALWARE_SCANNER != "yes" (disabled):
        - Force cleanup of ALL caches to free Redis memory
        - Deletes hash databases (32 keys), metadata/tracking (42 keys), scanner caches (7 patterns)
        - Total: 74 fixed keys + variable scanner cache keys
        - Ignores individual cleanup flags
    When USE_MALWARE_SCANNER == "yes" (enabled):
        - Check cleanup flags to determine what to clean
        - Only delete caches for enabled cleanup flags

    Cleanup Process:
        1. Check scanner status and cleanup flags
        2. Connect to Redis and scan for matching patterns
        3. Delete keys matching enabled cache patterns
        4. Log cleanup statistics

Environment:
    USE_MALWARE_SCANNER: Controls cleanup behavior
        - "yes" = Respect cleanup flags (selective cleanup)
        - != "yes" = Force full cleanup (free Redis memory)
    MALWARE_SCAN_USE_SHARED_DATABASE: Must be "yes" for Redis cleanup
    MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ALL: Optional, default "no" (only when scanner enabled)
    MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_*: Individual cleanup flags (only when scanner enabled)

Returns:
    0 if no cleanup needed or cleanup completed successfully
    1 if cleanup was performed (with changes)
    2 if error occurred
"""

from sys import exit as sys_exit, path as sys_path
from os import getenv, sep
from os.path import join
from logging import getLogger, StreamHandler, Formatter, DEBUG, INFO
import traceback
import time

# Add BunkerWeb dependencies to path
for deps_path in [join(sep, "usr", "share", "bunkerweb", *paths) for paths in (("deps", "python"), ("utils",), ("db",))]:
    if deps_path not in sys_path:
        sys_path.append(deps_path)

# Setup logging
LOGGER = getLogger("MALWARE-SCAN-CLEANUP")
handler = StreamHandler()
formatter = Formatter("[MALWARE-SCAN-CLEANUP] [%(levelname)s] - %(message)s")
handler.setFormatter(formatter)
LOGGER.addHandler(handler)
LOGGER.setLevel(DEBUG if getenv("LOG_LEVEL") == "debug" else INFO)

try:
    # Add startup delay to prevent overlapping with update job during scheduler restart
    LOGGER.info("Waiting 11 seconds before starting cache cleanup to prevent job overlap...")
    time.sleep(11)
    LOGGER.info("Starting cache cleanup job")

    # Check if malware scanning is enabled
    scanner_enabled = getenv("USE_MALWARE_SCANNER", "no") == "yes"

    if not scanner_enabled:
        # Scanner disabled - force cleanup of ALL caches to free Redis memory
        LOGGER.info("Malware scan disabled, forcing cleanup to free Redis memory")
        cleanup_all = True
        cleanup_clamav = True
        cleanup_virustotal = True
        cleanup_sentinelone = True
        cleanup_malwarebazaar = True
        cleanup_attacker_ipv4 = True
        cleanup_attacker_ipv6 = True
        cleanup_enabled = True
    else:
        # Scanner enabled - check cleanup flags
        cleanup_all = getenv("MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ALL", "no") == "yes"
        cleanup_clamav = getenv("MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_CLAMAV", "no") == "yes"
        cleanup_virustotal = getenv("MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_VIRUSTOTAL", "no") == "yes"
        cleanup_sentinelone = getenv("MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_SENTINELONE", "no") == "yes"
        cleanup_malwarebazaar = getenv("MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_MALWAREBAZAAR", "no") == "yes"
        cleanup_attacker_ipv4 = getenv("MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV4", "no") == "yes"
        cleanup_attacker_ipv6 = getenv("MALWARE_SCAN_CACHE_CLEANUP_ON_RESTART_ATTACKER_IPV6", "no") == "yes"

        cleanup_enabled = (
            cleanup_all
            or cleanup_clamav
            or cleanup_virustotal
            or cleanup_sentinelone
            or cleanup_malwarebazaar
            or cleanup_attacker_ipv4
            or cleanup_attacker_ipv6
        )

        if not cleanup_enabled:
            LOGGER.info("Malware scan enabled but no cleanup flags set, skipping cleanup")
            sys_exit(0)

    # Try to import Redis
    try:
        import redis
    except ImportError:
        LOGGER.error("Redis module not available")
        sys_exit(2)

    # Get Redis connection configuration
    try:
        sentinel_hosts_str = getenv("REDIS_SENTINEL_HOSTS", "").strip()
        if sentinel_hosts_str:
            # Redis Sentinel configuration
            sentinel_master = getenv("REDIS_SENTINEL_MASTER", "bw-master").strip()
            sentinel_username = getenv("REDIS_SENTINEL_USERNAME", "").strip() or None
            sentinel_password = getenv("REDIS_SENTINEL_PASSWORD", "").strip() or None
            redis_db_str = getenv("REDIS_DATABASE", "").strip() or "0"
            redis_username = getenv("REDIS_USERNAME", "").strip() or None
            redis_password = getenv("REDIS_PASSWORD", "").strip() or None
            redis_ssl = getenv("REDIS_SSL", "no").strip() == "yes"

            try:
                redis_db = int(redis_db_str)
            except ValueError:
                redis_db = 0

            # Parse sentinel hosts: convert port strings to integers
            # Format: "host1:port1 host2:port2 ..." (space-separated, not comma-separated)
            sentinel_hosts = []
            for h in sentinel_hosts_str.split():
                h = h.strip()
                if ":" in h:
                    host, port = h.rsplit(":", 1)
                    sentinel_hosts.append((host.strip(), int(port.strip())))
                else:
                    sentinel_hosts.append((h, 26379))  # Default sentinel port

            sentinel = redis.Sentinel(
                sentinel_hosts,
                username=sentinel_username,
                password=sentinel_password,
                ssl=redis_ssl,
                socket_connect_timeout=10,
                socket_timeout=10,
            )
            redis_conn = sentinel.master_for(
                sentinel_master,
                socket_connect_timeout=10,
                socket_timeout=10,
                db=redis_db,
                username=redis_username,
                password=redis_password,
                ssl=redis_ssl,
                decode_responses=True,
            )
        else:
            # Direct Redis configuration
            redis_host = getenv("REDIS_HOST", "localhost").strip()
            redis_port = int(getenv("REDIS_PORT", "6379").strip())
            redis_db_str = getenv("REDIS_DATABASE", "").strip() or "0"
            redis_username = getenv("REDIS_USERNAME", "").strip() or None
            redis_password = getenv("REDIS_PASSWORD", "").strip() or None
            redis_ssl = getenv("REDIS_SSL", "no").strip() == "yes"

            try:
                redis_db = int(redis_db_str)
            except ValueError:
                redis_db = 0

            redis_conn = redis.Redis(
                host=redis_host,
                port=redis_port,
                db=redis_db,
                username=redis_username,
                password=redis_password,
                ssl=redis_ssl,
                decode_responses=True,
                socket_connect_timeout=10,
                socket_timeout=10,
            )

        # Test connection
        redis_conn.ping()

        # Log connection success
        if sentinel_hosts_str:
            LOGGER.info(f"Connected to Redis Sentinel master '{sentinel_master}' via sentinels {sentinel_hosts} db={redis_db}")
        else:
            LOGGER.info(f"Connected to Redis at {redis_host}:{redis_port} db={redis_db}")

    except Exception as e:
        LOGGER.error(f"Failed to connect to Redis: {e}")
        sys_exit(2)

    # Build pattern list based on enabled flags
    patterns_to_delete = []

    if cleanup_all or cleanup_clamav:
        patterns_to_delete.append("plugin_malware_scan_clamav_*")
    if cleanup_all or cleanup_virustotal:
        patterns_to_delete.append("plugin_malware_scan_virustotal_*")
    if cleanup_all or cleanup_sentinelone:
        patterns_to_delete.append("plugin_malware_scan_sentinelone_*")
    if cleanup_all or cleanup_malwarebazaar:
        patterns_to_delete.append("plugin_malware_scan_malwarebazaar_*")
    if cleanup_all or cleanup_attacker_ipv4:
        patterns_to_delete.append("plugin_malware_scan_attacker_ipv4_*")
    if cleanup_all or cleanup_attacker_ipv6:
        patterns_to_delete.append("plugin_malware_scan_attacker_ipv6_*")

    # Always clean composite results cache if any scanner is being cleaned
    if patterns_to_delete:
        patterns_to_delete.append("plugin_malware_scan_results_*")

    # When scanner is disabled, also clean MalwareBazaar hash databases (16 bucketed keys)
    if not scanner_enabled:
        # Add full hash table buckets: malware_scan:hashes:0 through F
        for i in range(16):
            patterns_to_delete.append(f"malware_scan:hashes:{i:X}")
        # Add recent cache buckets: malware_scan:hashes:recent:0 through F
        for i in range(16):
            patterns_to_delete.append(f"malware_scan:hashes:recent:{i:X}")

        # Add metadata and tracking keys (exact keys, not patterns)
        # State keys
        patterns_to_delete.append("malware-scan:hashes:state:full")
        patterns_to_delete.append("malware-scan:hashes:state:recent")
        # Import tracking
        patterns_to_delete.append("malware-scan:hashes:import_state")
        patterns_to_delete.append("malware-scan:hashes:import_lock")
        patterns_to_delete.append("malware-scan:hashes:import_start_time:full")
        patterns_to_delete.append("malware-scan:hashes:import_start_time:recent")
        patterns_to_delete.append("malware-scan:hashes:import_end_time:full")
        patterns_to_delete.append("malware-scan:hashes:import_end_time:recent")
        # Progress tracking
        patterns_to_delete.append("malware-scan:hashes:import_total:full")
        patterns_to_delete.append("malware-scan:hashes:import_total:recent")
        # Per-bucket progress counters (32 total: 16 for full, 16 for recent)
        for i in range(16):
            patterns_to_delete.append(f"malware-scan:hashes:import_processed:full:bucket_{i:X}")
            patterns_to_delete.append(f"malware-scan:hashes:import_processed:recent:bucket_{i:X}")

    if not patterns_to_delete:
        LOGGER.info("No patterns to delete")
        sys_exit(0)

    # Separate exact keys from patterns for efficient deletion
    exact_keys = []
    pattern_keys = []

    for item in patterns_to_delete:
        # Patterns have wildcards (*), exact keys don't
        if "*" in item:
            pattern_keys.append(item)
        else:
            exact_keys.append(item)

    LOGGER.info(f"Starting Redis cache cleanup - {len(pattern_keys)} patterns + {len(exact_keys)} exact keys")

    # Delete keys matching patterns
    total_deleted = 0
    pattern_details = {}

    # Handle pattern-based deletion (SCAN + UNLINK)
    for pattern in pattern_keys:
        pattern_deleted = 0
        cursor = 0
        safe_prefixes = ["plugin_malware_scan_", "malware_scan:hashes:", "malware-scan:hashes:"]

        # Validate pattern prefix for safety
        if not any(pattern.startswith(prefix) for prefix in safe_prefixes):
            LOGGER.error(f"Safety error: Pattern '{pattern}' does not start with expected prefixes {safe_prefixes}")
            sys_exit(2)

        try:
            while True:
                cursor, keys = redis_conn.scan(cursor, match=pattern, count=100)
                if keys:
                    pattern_deleted += redis_conn.unlink(*keys)
                if cursor == 0:
                    break

            pattern_details[pattern] = pattern_deleted
            total_deleted += pattern_deleted
            if pattern_deleted > 0:
                LOGGER.info(f"Deleted {pattern_deleted} keys matching pattern '{pattern}'")

        except Exception as e:
            LOGGER.error(f"Error deleting pattern '{pattern}': {e}")
            sys_exit(2)

    # Handle exact key deletion (direct UNLINK)
    if exact_keys:
        # Validate all exact keys for safety
        safe_prefixes = ["plugin_malware_scan_", "malware_scan:hashes:", "malware-scan:hashes:"]
        for key in exact_keys:
            if not any(key.startswith(prefix) for prefix in safe_prefixes):
                LOGGER.error(f"Safety error: Key '{key}' does not start with expected prefixes {safe_prefixes}")
                sys_exit(2)

        try:
            # UNLINK multiple exact keys at once (non-blocking batch delete)
            exact_deleted = redis_conn.unlink(*exact_keys)
            total_deleted += exact_deleted
            if exact_deleted > 0:
                LOGGER.info(f"Deleted {exact_deleted} exact keys (metadata and tracking)")
            pattern_details["exact_keys"] = exact_deleted
        except Exception as e:
            LOGGER.error(f"Error deleting exact keys: {e}")
            sys_exit(2)

    LOGGER.info(f"âœ… Cache cleanup completed - Total keys deleted: {total_deleted}")
    for pattern, count in pattern_details.items():
        LOGGER.debug(f"  {pattern}: {count} keys")

    sys_exit(1 if total_deleted > 0 else 0)

except Exception as e:
    LOGGER.error(f"Cache cleanup job failed with exception: {e}")
    LOGGER.error(traceback.format_exc())
    sys_exit(2)
