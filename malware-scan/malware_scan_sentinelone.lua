-- BunkerWeb Malware Scan - SentinelOne Scanner Module
-- Handles all SentinelOne API integration for threat hash lookups

local cjson = require("cjson")
local http = require("resty.http")

local logger = require("malware_scan_logger")
local ngx = ngx
local decode = cjson.decode
local encode = cjson.encode
local http_new = http.new
local tostring = tostring
local string = string

-- Module table
local sentinelone = {}

-- Cache module reference (will be set when module is loaded)
local cache = nil

-- Module version
sentinelone.VERSION = "0.8.0"

-- Plugin version for User-Agent identification
local VERSION = "0.8.0"
local USER_AGENT = "bunkerweb - https://github.com/bunkerity/bunkerweb - malware-scan module v" .. VERSION

-- Set cache module reference (called during initialization)
function sentinelone.set_cache_module(cache_module)
	cache = cache_module
end

-- ============================================================================
-- SENTINELONE THREAT LOOKUP
-- ============================================================================

-- Check SHA256 hash against SentinelOne threat database (standard hash_check interface).
-- This is the standard interface for hash-only lookups used by multipart scanning.
-- Returns success boolean and result string ("clean" or threat info).
--
--- @param plugin Plugin Plugin instance
--- @param checksum string SHA256 hash to check
--- @param file_size number|nil Optional file size for cache verification
--- @return boolean success True if check succeeded (even if clean)
--- @return string result "clean", "api_error", "api_circuit_breaker", or threat info
function sentinelone.hash_check(plugin, checksum, file_size)
	return sentinelone.check_sentinelone(plugin, checksum, file_size)
end

-- Check file hash against SentinelOne threat database.
-- Takes SHA256 checksum and optional file_size, returns success boolean and result.
-- Returns "clean" if not found, or threat info string if found.
--- @return boolean success True if check succeeded (even if clean)
--- @return string result "clean", "api_error", "api_circuit_breaker", or threat info
function sentinelone.check_sentinelone(plugin, checksum, file_size)
	-- Check if SentinelOne is enabled
	if plugin.variables["MALWARE_SCAN_API_USE_SENTINELONE"] ~= "yes" then
		return true, "clean"
	end

	-- Check API error circuit breaker (prevents repeated failed calls)
	if cache then
		local should_skip, error_type, remaining = cache.api_error_should_skip(plugin, "sentinelone")
		if should_skip then
			logger.log_error( string.format(
				"SentinelOne API temporarily disabled due to previous error: %s (retry in %ds)",
				error_type or "unknown", remaining
			))
			return true, "api_circuit_breaker"
		end
	end

	-- Check cache and acquire lock if available (atomic locking to prevent duplicate API calls)
	local should_query = true
	local lock_acquired = false
	local result = "clean"

	if cache then
		-- Step 1: Check if result already cached
		local ok, cached, cached_size = cache.sentinelone_check(plugin, checksum, file_size)
		if ok and cached then
			logger.log_error( "file checksum " .. checksum .. " found in SentinelOne cache: " .. cached)
			return true, cached
		end

		-- Step 2: Try to acquire lock atomically
		lock_acquired = cache.sentinelone_try_lock(plugin, checksum)

		if not lock_acquired then
			-- Another request is querying SentinelOne - wait for result
			plugin:log_debug("[v" .. VERSION .. "] [CACHE_LOCK] Another request querying SentinelOne, waiting for result...")
			local wait_ok, wait_result, wait_size = cache.sentinelone_wait_for_result(plugin, checksum, file_size)

			if wait_ok then
				-- Got result from concurrent query
				logger.log_error( string.format(
					"[CACHE_LOCK] Got SentinelOne result from concurrent query: %s", wait_result))
				return true, wait_result
			else
				-- Timeout - fall back to querying independently
				logger.log_warn( "[CACHE_LOCK] Timeout waiting for SentinelOne result - querying independently")
				lock_acquired = cache.sentinelone_try_lock(plugin, checksum)
				should_query = true
			end
		end
	end

	if should_query then
		-- Request from SentinelOne API
		logger.log_error( "sending request to SentinelOne API for checksum: " .. checksum)
		local found, threat_info
		local ok, found, threat_info, error_type = sentinelone.api_request(plugin, checksum)
		if not ok then
			logger.log_error( "SentinelOne API request failed: " .. found)

			-- Record API error in circuit breaker if it's a persistent error
			-- Circuit break on: 4xx client errors (auth, config), 5xx server errors
			if cache and error_type then
				local should_circuit_break = (
					error_type == "invalid_token" or error_type == "invalid_url" or
					error_type:match("^http_4%d%d$") or  -- Match any 4xx error (401, 403, 429, etc.)
					error_type:match("^http_5%d%d$")     -- Match any 5xx error (500, 502, 503, etc.)
				)
				if should_circuit_break then
					cache.api_error_failure(plugin, "sentinelone", error_type)
				end
			end

			-- Release lock before returning on error
			if lock_acquired and cache then
				cache.sentinelone_release_lock(plugin, checksum)
			end

			return true, "api_error"
		end

		-- API call succeeded, reset circuit breaker
		if cache then
			cache.api_error_success(plugin, "sentinelone")
		end

		result = "clean"
		if found then
			logger.log_error( "file hash found in SentinelOne threat database")
			result = threat_info
			logger.log_error( "SentinelOne result: " .. result)
		else
			logger.log_error( "file checksum " .. checksum .. " not found in SentinelOne")
		end

		-- Add to cache if cache module is available
		if cache then
			local ok, err = cache.sentinelone_add(plugin, checksum, result, file_size)
			if not ok then
				logger.log_error( "can't cache SentinelOne result: " .. err)
			end
		end

		-- Track new result for composite Redis write
		if plugin.ctx.bw.new_scan_results then
			plugin.ctx.bw.new_scan_results.sentinelone = result
		end
	end

	-- Release lock after query completes (all paths: success, error, clean)
	if lock_acquired and cache then
		cache.sentinelone_release_lock(plugin, checksum)
	end

	return true, result
end

-- ============================================================================
-- SENTINELONE API REQUEST
-- ============================================================================

-- Make HTTP request to SentinelOne API (standard api_request interface).
-- Takes hash (SHA256), returns success boolean, found boolean, threat info, and error_type.
-- This is the standard interface for API requests following domain_action pattern.
--- @return boolean success True if API call succeeded
--- @return boolean|string found_or_error Boolean when success=true (found/not found), error message when success=false
--- @return string|nil threat_info Threat information when found=true, nil otherwise
--- @return string|nil error_type Error type when success=false, nil otherwise
function sentinelone.api_request(plugin, hash)
	-- Get HTTP client
	local httpc, err = http_new()
	if not httpc then
		return false, err, nil, "http_error"
	end

	-- Get API token and management URL (required for SentinelOne) and check for default values
	local api_token = plugin.variables["MALWARE_SCAN_API_SENTINELONE_TOKEN"]
	if not api_token or api_token == "" or api_token == "your_api_key" or api_token == "your_token" then
		return false, "SentinelOne API token is required but not configured or using default value", nil, "invalid_token"
	end

	local mgmt_url = plugin.variables["MALWARE_SCAN_API_SENTINELONE_URL"]
	if not mgmt_url or mgmt_url == "" or mgmt_url == "https://your-console.example.com" then
		return false, "SentinelOne Management URL is required but not configured or using default value", nil, "invalid_url"
	end

	-- Remove trailing slash from management URL if present
	mgmt_url = mgmt_url:gsub("/$", "")

	-- Build API endpoint for threat lookup by hash
	-- Using /web/api/v2.1/threats endpoint with contentHash filter
	local api_url = mgmt_url .. "/web/api/v2.1/threats"

	-- Send request with contentHashes filter
	local res
	res, err = httpc:request_uri(api_url, {
		method = "GET",
		headers = {
			["Authorization"] = "ApiToken " .. api_token,
			["Content-Type"] = "application/json",
			["accept"] = "application/json",
			["User-Agent"] = USER_AGENT,
		},
		query = {
			contentHashes = hash,
			limit = "1"
		}
	})

	if not res then
		return false, err, nil, "http_error"
	end

	-- Check status
	if res.status ~= 200 then
		err = "received status " .. tostring(res.status) .. " from SentinelOne API"
		local error_type = "http_" .. tostring(res.status)
		local decode_ok, data = pcall(decode, res.body)
		if decode_ok and data then
			err = err .. " with data " .. encode(data)
		end
		return false, err, nil, error_type
	end

	-- Parse JSON response
	local decode_ok, data = pcall(decode, res.body)
	if not decode_ok then
		return false, "failed to decode JSON: " .. data, nil, "json_error"
	end

	-- Check if threats were found
	if not data.data or #data.data == 0 then
		-- Hash not found in SentinelOne
		return true, false, nil, nil
	end

	-- Extract threat information from first result
	local threat = data.data[1]
	local threat_name = threat.threatName or threat.maliciousProcessArguments or "unknown threat"
	local classification = threat.classification or "unknown"
	local confidence_level = threat.confidenceLevel or "unknown"

	-- Build threat info string
	local threat_info = string.format(
		"%s (Classification: %s, Confidence: %s)",
		threat_name,
		classification,
		confidence_level
	)

	return true, true, threat_info, nil
end

-- Return module
return sentinelone
