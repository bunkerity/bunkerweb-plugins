-- BunkerWeb Malware Scan - SentinelOne Scanner Module
-- Handles all SentinelOne API integration for threat hash lookups

local cjson = require("cjson")
local http = require("resty.http")

local ngx = ngx
local ERR = ngx.ERR
local decode = cjson.decode
local encode = cjson.encode
local http_new = http.new
local tostring = tostring
local string = string

-- Module table
local sentinelone = {}

-- Cache module reference (will be set when module is loaded)
local cache = nil

-- Plugin version for User-Agent identification
local VERSION = "0.3.0"
local USER_AGENT = "bunkerweb - https://github.com/bunkerity/bunkerweb - malware-scan module v" .. VERSION

-- Set cache module reference (called during initialization)
function sentinelone.set_cache_module(cache_module)
	cache = cache_module
end

-- ============================================================================
-- SENTINELONE THREAT LOOKUP
-- ============================================================================

-- Check file hash against SentinelOne threat database.
-- Takes SHA256 checksum and optional file_size, returns success boolean and result.
-- Returns "clean" if not found, or threat info string if found.
function sentinelone.check_sentinelone(plugin, checksum, file_size)
	-- Check if SentinelOne is enabled
	if plugin.variables["MALWARE_SCAN_API_USE_SENTINELONE"] ~= "yes" then
		return true, "clean"
	end

	-- Check cache first if cache module is available
	if cache then
		local ok, cached, cached_size = cache.is_in_sentinelone_cache(plugin, checksum, file_size)
		if ok and cached then
			plugin.logger:log(ERR, "file checksum " .. checksum .. " found in SentinelOne cache: " .. cached)
			return true, cached
		end
	end

	-- Request from SentinelOne API
	plugin.logger:log(ERR, "sending request to SentinelOne API for checksum: " .. checksum)
	local found, threat_info
	local ok, found, threat_info = sentinelone.sentinelone_request(plugin, checksum)
	if not ok then
		plugin.logger:log(ERR, "SentinelOne API request failed: " .. found)
		return true, "clean"
	end

	local result = "clean"
	if found then
		plugin.logger:log(ERR, "file hash found in SentinelOne threat database")
		result = threat_info
		plugin.logger:log(ERR, "SentinelOne result: " .. result)
	else
		plugin.logger:log(ERR, "file checksum " .. checksum .. " not found in SentinelOne")
	end

	-- Add to cache if cache module is available
	if cache then
		local ok, err = cache.add_to_sentinelone_cache(plugin, checksum, result, file_size)
		if not ok then
			plugin.logger:log(ERR, "can't cache SentinelOne result: " .. err)
		end
	end

	-- Track new result for composite Redis write
	if plugin.ctx.bw.new_scan_results then
		plugin.ctx.bw.new_scan_results.sentinelone = result
	end

	return true, result
end

-- ============================================================================
-- SENTINELONE API REQUEST
-- ============================================================================

-- Make HTTP request to SentinelOne API.
-- Takes hash (SHA256), returns success boolean, found boolean, and threat info.
function sentinelone.sentinelone_request(plugin, hash)
	-- Get HTTP client
	local httpc, err = http_new()
	if not httpc then
		return false, err
	end

	-- Get API token and management URL (required for SentinelOne) and check for default values
	local api_token = plugin.variables["MALWARE_SCAN_API_SENTINELONE_TOKEN"]
	if not api_token or api_token == "" or api_token == "your_api_key" or api_token == "your_token" then
		return false, "SentinelOne API token is required but not configured or using default value"
	end

	local mgmt_url = plugin.variables["MALWARE_SCAN_API_SENTINELONE_URL"]
	if not mgmt_url or mgmt_url == "" or mgmt_url == "https://your-console.example.com" then
		return false, "SentinelOne Management URL is required but not configured or using default value"
	end

	-- Remove trailing slash from management URL if present
	mgmt_url = mgmt_url:gsub("/$", "")

	-- Build API endpoint for threat lookup by hash
	-- Using /web/api/v2.1/threats endpoint with contentHash filter
	local api_url = mgmt_url .. "/web/api/v2.1/threats"

	-- Send request with contentHashes filter
	local res
	res, err = httpc:request_uri(api_url, {
		method = "GET",
		headers = {
			["Authorization"] = "ApiToken " .. api_token,
			["Content-Type"] = "application/json",
			["accept"] = "application/json",
			["User-Agent"] = USER_AGENT,
		},
		query = {
			contentHashes = hash,
			limit = "1"
		}
	})

	if not res then
		return false, err
	end

	-- Check status
	if res.status ~= 200 then
		err = "received status " .. tostring(res.status) .. " from SentinelOne API"
		local decode_ok, data = pcall(decode, res.body)
		if decode_ok and data then
			err = err .. " with data " .. encode(data)
		end
		return false, err
	end

	-- Parse JSON response
	local decode_ok, data = pcall(decode, res.body)
	if not decode_ok then
		return false, "failed to decode JSON: " .. data
	end

	-- Check if threats were found
	if not data.data or #data.data == 0 then
		-- Hash not found in SentinelOne
		return true, false
	end

	-- Extract threat information from first result
	local threat = data.data[1]
	local threat_name = threat.threatName or threat.maliciousProcessArguments or "unknown threat"
	local classification = threat.classification or "unknown"
	local confidence_level = threat.confidenceLevel or "unknown"

	-- Build threat info string
	local threat_info = string.format(
		"%s (Classification: %s, Confidence: %s)",
		threat_name,
		classification,
		confidence_level
	)

	return true, true, threat_info
end

-- Return module
return sentinelone
