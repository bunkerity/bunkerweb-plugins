-- BunkerWeb Malware Scan - VirusTotal Scanner Module
-- Handles all VirusTotal API integration for file hash lookups, uploads, and voting

local cjson = require("cjson")
local http = require("resty.http")

local logger = require("malware_scan_logger")
local ngx = ngx
local decode = cjson.decode
local encode = cjson.encode
local http_new = http.new
local tonumber = tonumber
local tostring = tostring

-- Module table
local virustotal = {}

-- Cache module reference (will be set when module is loaded)
local cache = nil

-- File operations module reference (will be set when module is loaded)
local file_ops = nil

-- Module version
virustotal.VERSION = "0.8.0"

-- Plugin version for User-Agent identification
local VERSION = "0.8.0"
local USER_AGENT = "bunkerweb - https://github.com/bunkerity/bunkerweb - malware-scan module v" .. VERSION

-- Set cache module reference (called during initialization)
function virustotal.set_cache_module(cache_module)
	cache = cache_module
end

-- Set file operations module reference (called during initialization)
function virustotal.set_file_ops_module(file_ops_module)
	file_ops = file_ops_module
end

-- ============================================================================
-- VIRUSTOTAL HASH LOOKUP (MULTIPART-COMPATIBLE)
-- ============================================================================

-- Check SHA256 hash against VirusTotal database (no file path required).
-- This is the standard interface for hash-only lookups used by multipart scanning.
-- Returns success boolean and result string ("clean" or detection info).
--
--- @param plugin Plugin Plugin instance
--- @param checksum string SHA256 hash to check
--- @param file_size number|nil Optional file size for cache verification
--- @return boolean success True if check succeeded (even if clean)
--- @return string result "clean", "api_error", "api_circuit_breaker", or detection info
function virustotal.hash_check(plugin, checksum, file_size)
	-- Check if VirusTotal is enabled
	if plugin.variables["MALWARE_SCAN_API_USE_VIRUSTOTAL"] ~= "yes" then
		return true, "clean"
	end

	-- Check if API key is configured
	local api_key = plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_KEY"]
	if not api_key or api_key == "" or api_key == "your_api_key" or api_key == "your_token" then
		logger.log_error( "VirusTotal enabled but API key not configured")
		return true, "clean"
	end

	-- Check API error circuit breaker (prevents repeated failed calls)
	if cache then
		local should_skip, error_type, remaining = cache.api_error_should_skip(plugin, "virustotal")
		if should_skip then
			logger.log_error( string.format(
				"VirusTotal API temporarily disabled due to previous error: %s (retry in %ds)",
				error_type or "unknown", remaining
			))
			return true, "api_circuit_breaker"
		end
	end

	-- Check cache and acquire lock if available (atomic locking to prevent duplicate API calls)
	local should_query = true
	local lock_acquired = false
	local result = "clean"

	if cache then
		-- Step 1: Check if result already cached
		local ok, cached, cached_size = cache.virustotal_check(plugin, checksum, file_size)
		if ok and cached then
			logger.log_error( "file checksum " .. checksum .. " found in VT cache: " .. cached)
			return true, cached
		end

		-- Step 2: Try to acquire lock atomically
		lock_acquired = cache.virustotal_try_lock(plugin, checksum)

		if not lock_acquired then
			-- Another request is querying VirusTotal - wait for result
			plugin:log_debug("[v" .. VERSION .. "] [CACHE_LOCK] Another request querying VirusTotal, waiting for result...")
			local wait_ok, wait_result, wait_size = cache.virustotal_wait_for_result(plugin, checksum, file_size)

			if wait_ok then
				-- Got result from concurrent query
				logger.log_error( string.format(
					"[CACHE_LOCK] Got VirusTotal result from concurrent query: %s", wait_result))
				return true, wait_result
			else
				-- Timeout - fall back to querying independently
				logger.log_warn( "[CACHE_LOCK] Timeout waiting for VirusTotal result - querying independently")
				lock_acquired = cache.virustotal_try_lock(plugin, checksum)
				should_query = true
			end
		end
	end

	if should_query then
		-- Request from VirusTotal API
		logger.log_error( "sending request to VirusTotal API for checksum: " .. checksum)
		local ok, found, response, error_type = virustotal.api_request(plugin, "/files/" .. checksum)
		if not ok then
			logger.log_error( "VirusTotal API request failed: " .. found)

			-- Record API error in circuit breaker if it's a persistent error
			-- Circuit break on: VT error codes (quota, auth, transient), 4xx client errors, 5xx server errors
			if cache and error_type then
				local should_circuit_break = (
					error_type == "QuotaExceededError" or
					error_type == "TooManyRequestsError" or
					error_type == "WrongCredentialsError" or
					error_type == "ForbiddenError" or
					error_type == "TransientError" or
					error_type:match("^http_4%d%d$") or  -- Match any 4xx error (401, 403, 429, etc.)
					error_type:match("^http_5%d%d$")     -- Match any 5xx error (500, 502, 503, etc.)
				)
				if should_circuit_break then
					cache.api_error_failure(plugin, "virustotal", error_type)
				end
			end

			-- Release lock before returning on error
			if lock_acquired and cache then
				cache.virustotal_release_lock(plugin, checksum)
			end

			return true, "api_error"
		end

		-- API call succeeded, reset circuit breaker
		if cache then
			cache.api_error_success(plugin, "virustotal")
		end

		result = "clean"
		if found then
			logger.log_error( "file found on VirusTotal, analyzing results")
			result = virustotal.result_parse(plugin, response)
			logger.log_error( "VirusTotal result: " .. result)
		else
			logger.log_error( "file checksum " .. checksum .. " not found on VirusTotal (new file)")
		end

		-- Add to cache if available
		if cache then
			local ok, err = cache.virustotal_add(plugin, checksum, result, file_size)
			if not ok then
				logger.log_error( "can't cache VT result: " .. err)
			end
		end

		-- Track new result for composite Redis write
		if plugin.ctx.bw.new_scan_results then
			plugin.ctx.bw.new_scan_results.vt = result
		end
	end

	-- Release lock after query completes (all paths: success, error, clean)
	if lock_acquired and cache then
		cache.virustotal_release_lock(plugin, checksum)
	end

	return true, result
end

-- ============================================================================
-- VIRUSTOTAL FILE LOOKUP
-- ============================================================================

-- Check file hash against VirusTotal database.
-- Takes file path and SHA256 checksum, returns success boolean, result, and found boolean.
-- Returns ("clean", false) if file not found on VT, or (verdict, true) if found.
function virustotal.check_virustotal(plugin, file_path, checksum)
	-- Check if VirusTotal is enabled
	if plugin.variables["MALWARE_SCAN_API_USE_VIRUSTOTAL"] ~= "yes" then
		return true, "clean", false
	end

	-- Check if API key is configured and not a default value
	local api_key = plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_KEY"]
	if not api_key or api_key == "" or api_key == "your_api_key" or api_key == "your_token" then
		logger.log_error( "VirusTotal enabled but API key not configured or using default value")
		return true, "clean", false
	end

	-- Check API error circuit breaker (prevents repeated failed calls)
	if cache then
		local should_skip, error_type, remaining = cache.api_error_should_skip(plugin, "virustotal")
		if should_skip then
			logger.log_error( string.format(
				"VirusTotal API temporarily disabled due to previous error: %s (retry in %ds)",
				error_type or "unknown", remaining
			))
			return true, "api_circuit_breaker", false
		end
	end

	-- Get file size for cache verification
	local file_size = file_ops and file_ops.file_get_size(plugin, file_path) or nil

	-- Check cache if cache module is available
	if cache then
		local ok, cached, cached_size = cache.virustotal_check(plugin, checksum, file_size)
		if ok and cached then
			logger.log_error( "file checksum " .. checksum .. " found in VT cache: " .. cached)
			-- Assume if it's in cache, it was found before
			return true, cached, true
		end
	end

	-- Request from VirusTotal API
	logger.log_error( "sending request to VirusTotal API for checksum: " .. checksum)
	local found, response
	local ok, found, response, error_type = virustotal.api_request(plugin, "/files/" .. checksum)
	if not ok then
		logger.log_error( "VirusTotal API request failed: " .. found)

		-- Record API error in circuit breaker if it's a persistent error
		-- Circuit break on: VT error codes (quota, auth, transient), 4xx client errors, 5xx server errors
		if cache and error_type then
			local should_circuit_break = (
				error_type == "QuotaExceededError" or
				error_type == "TooManyRequestsError" or
				error_type == "WrongCredentialsError" or
				error_type == "ForbiddenError" or
				error_type == "TransientError" or
				error_type:match("^http_4%d%d$") or  -- Match any 4xx error (401, 403, 429, etc.)
				error_type:match("^http_5%d%d$")     -- Match any 5xx error (500, 502, 503, etc.)
			)
			if should_circuit_break then
				cache.api_error_failure(plugin, "virustotal", error_type)
			end
		end

		return true, "api_error", false
	end

	-- API call succeeded, reset circuit breaker
	if cache then
		cache.api_error_success(plugin, "virustotal")
	end

	local result = "clean"
	if found then
		logger.log_error( "file found on VirusTotal, analyzing results")
		result = virustotal.result_parse(plugin, response)
		logger.log_error( "VirusTotal result: " .. result)
	else
		logger.log_error( "file checksum " .. checksum .. " not found on VirusTotal (new file)")
	end

	-- Add to cache if cache module is available
	if cache then
		local ok, err = cache.virustotal_add(plugin, checksum, result, file_size)
		if not ok then
			logger.log_error( "can't cache VT result: " .. err)
		end
	end

	-- Track new result for composite Redis write
	if plugin.ctx.bw.new_scan_results then
		plugin.ctx.bw.new_scan_results.vt = result
	end

	return true, result, found
end

-- ============================================================================
-- VIRUSTOTAL API REQUEST
-- ============================================================================

-- Make HTTP request to VirusTotal API (standard api_request interface).
-- Takes API endpoint URL, returns success boolean, found boolean, and response data.
-- This is the standard interface for API requests following domain_action pattern.
function virustotal.api_request(plugin, url)
	-- Get HTTP client
	local httpc, err = http_new()
	if not httpc then
		return false, err, nil, "http_error"
	end

	-- Send request
	local res
	res, err = httpc:request_uri("https://www.virustotal.com/api/v3" .. url, {
		headers = {
			["x-apikey"] = plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_KEY"],
			["accept"] = "application/json",
			["User-Agent"] = USER_AGENT,
		},
	})
	if not res then
		return false, err, nil, "http_error"
	end

	-- Check status
	if res.status == 404 then
		return true, false, nil, nil
	end
	if res.status ~= 200 then
		err = "received status " .. tostring(res.status) .. " from VirusTotal API"
		local error_type = "http_" .. tostring(res.status)

		-- Try to parse error response to extract VirusTotal error code
		local ok, data = pcall(decode, res.body)
		if ok and data and data.error and data.error.code then
			error_type = tostring(data.error.code)
			err = err .. " (error: " .. error_type .. ")"
			if data.error.message then
				err = err .. " - " .. data.error.message
			end
		else
			err = err .. " with data " .. (ok and encode(data) or "unknown")
		end
		return false, err, nil, error_type
	end

	-- Parse JSON response
	local ok, data = pcall(decode, res.body)
	if not ok then
		return false, "failed to decode JSON: " .. data, nil, "json_error"
	end
	if not data.data or not data.data.attributes or not data.data.attributes.last_analysis_stats then
		return false, "malformed JSON response from VirusTotal", nil, "json_error"
	end

	return true, true, data.data.attributes.last_analysis_stats, nil
end

-- ============================================================================
-- VIRUSTOTAL RESULT PROCESSING
-- ============================================================================

-- Process VirusTotal analysis stats and determine if file is malicious (standard result_parse interface).
-- Takes response stats, returns result string ("clean" or description of detections).
-- This is the standard interface for result parsing following domain_action pattern.
function virustotal.result_parse(plugin, response)
	local suspicious = response["suspicious"] or 0
	local malicious = response["malicious"] or 0

	local suspicious_threshold = tonumber(plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_SUSPICIOUS"]) or 5
	local malicious_threshold = tonumber(plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_MALICIOUS"]) or 3

	if suspicious > suspicious_threshold or malicious > malicious_threshold then
		return tostring(suspicious) .. " suspicious and " .. tostring(malicious) .. " malicious"
	end

	return "clean"
end

-- ============================================================================
-- VIRUSTOTAL FILE UPLOAD
-- ============================================================================

-- Upload file to VirusTotal for analysis (standard file_upload interface).
-- Takes file path, returns success boolean, analysis ID or error message, and file size.
-- Only uploads files smaller than the configured max size (default 32MB).
-- This is the standard interface for file uploads following domain_action pattern.
function virustotal.file_upload(plugin, file_path)
	logger.log_error( "preparing to upload file to VirusTotal")

	-- Extract file content from multipart body
	if not file_ops then
		return false, "file_ops module not loaded - cannot upload file"
	end

	local ok, file_content = file_ops.content_extract(plugin, file_path)
	if not ok then
		return false, "failed to extract file content: " .. file_content
	end

	local file_size = #file_content
	plugin:log_debug("extracted file size: " .. file_size .. " bytes")

	-- Check file size against max upload size
	local max_size = tonumber(plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_MAX_UPLOAD_SIZE"]) or 33554432
	if file_size > max_size then
		logger.log_error( "file too large for VirusTotal upload: " .. file_size .. " bytes (max: " .. max_size .. " bytes)")
		return false, "file too large for upload (max " .. max_size .. " bytes)"
	end

	logger.log_error( "uploading file to VirusTotal (" .. file_size .. " bytes)")

	-- Get HTTP client
	local httpc, err = http_new()
	if not httpc then
		return false, err
	end

	-- Create multipart/form-data boundary
	local boundary = "----WebKitFormBoundary" .. ngx.time()

	-- Build multipart body
	local body_parts = {}
	table.insert(body_parts, "--" .. boundary .. "\r\n")
	table.insert(body_parts, 'Content-Disposition: form-data; name="file"; filename="upload"\r\n')
	table.insert(body_parts, "Content-Type: application/octet-stream\r\n\r\n")
	table.insert(body_parts, file_content)
	table.insert(body_parts, "\r\n--" .. boundary .. "--\r\n")

	local upload_body = table.concat(body_parts)

	-- Send upload request
	local res
	res, err = httpc:request_uri("https://www.virustotal.com/api/v3/files", {
		method = "POST",
		headers = {
			["x-apikey"] = plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_KEY"],
			["accept"] = "application/json",
			["Content-Type"] = "multipart/form-data; boundary=" .. boundary,
			["Content-Length"] = tostring(#upload_body),
			["User-Agent"] = USER_AGENT,
		},
		body = upload_body,
	})

	if not res then
		return false, err
	end

	-- Check status
	if res.status ~= 200 then
		err = "received status " .. tostring(res.status) .. " from VirusTotal upload API"
		local decode_ok, data = pcall(decode, res.body)
		if decode_ok and data then
			err = err .. " with data " .. encode(data)
		end
		return false, err
	end

	-- Parse JSON response
	local decode_ok, data = pcall(decode, res.body)
	if not decode_ok then
		return false, "failed to decode JSON: " .. data
	end

	-- Extract analysis ID from response
	local analysis_id = nil
	if data.data and data.data.id then
		analysis_id = data.data.id
		logger.log_error( "file uploaded to VirusTotal successfully, analysis ID: " .. analysis_id)
	else
		logger.log_error( "file uploaded but no analysis ID returned")
	end

	return true, analysis_id, file_size
end

-- ============================================================================
-- VIRUSTOTAL VOTING
-- ============================================================================

-- Vote on a file in VirusTotal (standard file_vote interface).
-- Takes SHA256 checksum and verdict ("harmless" or "malicious").
-- Returns success boolean and error message if failed.
-- This is the standard interface for file voting following domain_action pattern.
function virustotal.file_vote(plugin, checksum, verdict)
	logger.log_error( "voting on VirusTotal file " .. checksum .. " as " .. verdict)

	-- Validate verdict
	if verdict ~= "harmless" and verdict ~= "malicious" then
		return false, "invalid verdict: " .. verdict .. " (must be 'harmless' or 'malicious')"
	end

	-- Get HTTP client
	local httpc, err = http_new()
	if not httpc then
		return false, err
	end

	-- Build vote request body
	local vote_data = {
		data = {
			type = "vote",
			attributes = {
				verdict = verdict
			}
		}
	}

	local body = encode(vote_data)

	-- Send vote request
	local res
	res, err = httpc:request_uri("https://www.virustotal.com/api/v3/files/" .. checksum .. "/votes", {
		method = "POST",
		headers = {
			["x-apikey"] = plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_KEY"],
			["accept"] = "application/json",
			["Content-Type"] = "application/json",
			["Content-Length"] = tostring(#body),
			["User-Agent"] = USER_AGENT,
		},
		body = body,
	})

	if not res then
		return false, err
	end

	-- Check status (200 or 201 are success)
	if res.status ~= 200 and res.status ~= 201 then
		err = "received status " .. tostring(res.status) .. " from VirusTotal vote API"
		local decode_ok, data = pcall(decode, res.body)
		if decode_ok and data then
			err = err .. " with data " .. encode(data)
		end
		return false, err
	end

	logger.log_error( "vote submitted successfully to VirusTotal")
	return true
end

-- Return module
return virustotal
