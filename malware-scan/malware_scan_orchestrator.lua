-- BunkerWeb Malware Scan - Scanner Orchestrator Module
-- Centralized scanner coordination and detection handling
-- Eliminates code duplication for cache checks, webhooks, and cleanup

local logger = require("malware_scan_logger")
local utils = require("malware_scan_utils")

-- OpenResty log level constants (with fallback values for module load time)
local ERR = ngx and ngx.ERR or 3
local WARN = ngx and ngx.WARN or 4
local NOTICE = ngx and ngx.NOTICE or 5
local INFO = ngx and ngx.INFO or 6
local DEBUG = ngx and ngx.DEBUG or 7

-- Try to load UI metrics module (optional)
local ui_metrics
local ui_metrics_ok = pcall(function()
	ui_metrics = require("malware_scan_ui_metrics")
end)

-- Module table
local orchestrator = {}

-- Module version
orchestrator.VERSION = "0.8.0"

-- ============================================================================
-- SCANNER STATE MANAGEMENT
-- ============================================================================

--- @class ScannerState
--- @field clamav boolean Whether ClamAV scanner is enabled
--- @field virustotal boolean Whether VirusTotal API is enabled
--- @field sentinelone boolean Whether SentinelOne API is enabled
--- @field malwarebazaar boolean Whether MalwareBazaar hash lookup is enabled
--- @field resume_on_hit boolean Whether to resume scan on first detection

--- @class ScanContext
--- @field scanner_state ScannerState Scanner state from scanner_get_state()
--- @field body_file string Path to uploaded file
--- @field checksum string|nil SHA256 checksum (may be nil initially)
--- @field checksum_ok boolean Whether checksum calculation succeeded
--- @field file_size number File size in bytes
--- @field detections table Table of detections found

--- @class ScanLimits
--- @field scanner_state ScannerState Scanner state with enabled flags
--- @field scanner_state_for_files ScannerState Original scanner state for file scanning (saved before body scan disable)
--- @field clamav_skipped_reason string|nil Reason ClamAV was skipped (if applicable)
--- @field skip_full_body_scan boolean Whether to skip full body scan

--- @class ScanResult
--- @field detected string|nil Detection result ("clean" or signature)
--- @field checksum string|nil Final SHA256 checksum after scanning
--- @field checksum_ok boolean Whether checksum is valid
--- @field clamav_actually_scanned boolean Whether ClamAV performed a scan

-- Create scanner state tracker.
-- Tracks which scanners are enabled and provides unified interface.
--
--- @param plugin Plugin The plugin instance
--- @return ScannerState state Scanner state table with enabled flags
function orchestrator.scanner_get_state(plugin)
	return {
		clamav = plugin.variables["USE_MALWARE_SCANNER"] == "yes",
		virustotal = plugin.variables["MALWARE_SCAN_API_USE_VIRUSTOTAL"] == "yes",
		sentinelone = plugin.variables["MALWARE_SCAN_API_USE_SENTINELONE"] == "yes",
		malwarebazaar = plugin.variables["MALWARE_SCAN_MALWAREBAZAAR_HASH_LOOKUP"] == "yes",
		resume_on_hit = plugin.variables["MALWARE_SCAN_RESUME_SCAN_ON_FIRST_HIT"] == "yes"
	}
end

-- Check if any scanner is enabled.
--
--- @param state ScannerState Scanner state from scanner_get_state()
--- @return boolean any_enabled True if any scanner is enabled, false otherwise
function orchestrator.scanner_any_enabled(state)
	return state.clamav or state.virustotal or state.sentinelone or state.malwarebazaar
end

-- Check if a scanner result indicates malware detection.
-- Returns false for "clean", "api_error", "api_circuit_breaker" (fail-open).
-- Returns true for any other value (malware detection).
--
--- @param result Scanner result string
--- @return boolean is_malware True if malware detected, false if clean or API error
function orchestrator.result_is_malware(result)
	if not result then
		return false
	end

	-- Non-blocking statuses (fail-open for availability)
	if result == "clean" or result == "api_error" or result == "api_circuit_breaker" then
		return false
	end

	-- Any other result is a malware detection
	return true
end

-- Get list of enabled scanner names.
--
--- @param state ScannerState Scanner state from scanner_get_state()
--- @return table scanners Array of enabled scanner names
function orchestrator.scanner_get_enabled(state)
	local scanners = {}
	if state.malwarebazaar then table.insert(scanners, "MalwareBazaar") end
	if state.clamav then table.insert(scanners, "ClamAV") end
	if state.virustotal then table.insert(scanners, "VirusTotal") end
	if state.sentinelone then table.insert(scanners, "SentinelOne") end
	return scanners
end

-- ============================================================================
-- DETECTION HANDLING
-- ============================================================================

-- Handle malware detection (webhook, cleanup, blocking).
-- Centralized detection handling to eliminate code duplication.
--
-- This function:
-- 1. Sends webhook notification if configured
-- 2. Cleans up uploaded file if enabled
-- 3. Returns blocking response with detection details
--
--- @param plugin Plugin The plugin instance
--- @param checksum string|nil File SHA256 checksum
--- @param detections table Table of detections (scanner_name => detection_string)
--- @param body_file string Path to uploaded file
--- @param scanner_name string Name of scanner that detected malware
--- @param detection string Detection signature/result
--- @param webhook table|nil Webhook module (or nil if not loaded)
--- @param file_ops table|nil File operations module (or nil if not loaded)
--- @param get_deny_status function Function to get deny status code
--- @return table result plugin:ret() result for blocking the request
function orchestrator.detection_handle(plugin, checksum, detections, body_file, scanner_name, detection, webhook, file_ops, get_deny_status)
	local ERR = ngx and ngx.ERR or 3  -- Fallback for tests

	-- Send webhook notification with all detections (centralized error handling)
	if webhook then
		webhook.notify(webhook, plugin, checksum, detections)
	end

	-- Track malware detection metrics
	if ui_metrics_ok and ui_metrics then
		ui_metrics.track_detection_complete(plugin, scanner_name, detection, checksum, detections)
	end

	-- Cleanup uploaded file if enabled
	local cleanup_enabled = plugin.variables["MALWARE_SCAN_CLEANUP_FILES"]
	if cleanup_enabled ~= "no" then
		local cleanup_ok, cleanup_err
		if file_ops then
			cleanup_ok, cleanup_err = file_ops.file_cleanup(plugin, body_file)
		else
			cleanup_ok, cleanup_err = true, nil
		end
		if not cleanup_ok then
			logger.log_error( "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
		end
	end

	-- Return blocking response with detection details
	return plugin:ret(
		true,
		"malware detected by " .. scanner_name .. " (SHA256: " .. checksum .. "): " .. detection,
		get_deny_status(),
		nil,
		{
			id = "malware_detected_" .. scanner_name:lower():gsub("[^a-z0-9]", "_"),
			file = body_file,
			checksum = checksum,
			detection = detection,
			scanner = scanner_name
		}
	)
end

-- ============================================================================
-- CACHE CHECKING
-- ============================================================================

-- Check scanner cache for malware detection.
-- Unified cache checking logic for all scanners.
--
-- Returns:
-- - cache_hit: true if cache was checked successfully
-- - result: "clean", "malicious", or nil (cache miss/error)
-- - detection: detection string if malicious, nil otherwise
--
--- @param plugin Plugin The plugin instance
--- @param cache table|nil Cache module (or nil if not loaded)
--- @param scanner_name string Scanner name ("clamav", "virustotal", "sentinelone")
--- @param checksum string File SHA256 checksum
--- @param file_size number File size in bytes
--- @return boolean cache_hit True if cache was checked successfully
--- @return string|nil result "clean", "malicious", or nil (cache miss/error)
--- @return string|nil detection Detection string if malicious, nil otherwise
function orchestrator.cache_check(plugin, cache, scanner_name, checksum, file_size)
	if not cache then
		return true, nil, nil  -- No cache module - treat as cache miss
	end

	-- Map scanner name to cache function
	local cache_functions = {
		clamav = cache.clamav_check,
		virustotal = cache.virustotal_check,
		sentinelone = cache.sentinelone_check
	}

	local cache_fn = cache_functions[scanner_name]
	if not cache_fn then
		return true, nil, nil  -- Unknown scanner - treat as cache miss
	end

	-- Check cache
	local cache_ok, cached, cached_size = cache_fn(plugin, checksum, file_size)

	if not cache_ok then
		return false, nil, nil  -- Cache check failed
	end

	if not cached then
		return true, nil, nil  -- Cache miss
	end

	if cached == "clean" then
		return true, "clean", nil  -- Clean file
	else
		return true, "malicious", cached  -- Malicious file with detection
	end
end

-- ============================================================================
-- ORCHESTRATION
-- ============================================================================

-- Check all scanner caches and handle detections.
-- Centralized orchestration to eliminate code duplication.
--
-- This function checks caches for all enabled scanners and handles:
-- - Cache hits (clean or malicious)
-- - Detection logging
-- - Webhook notifications
-- - Resume mode logic
-- - Immediate blocking or continued scanning
--
-- Returns:
-- - blocked: true if request was blocked, false if should continue
-- - detections: table of all detections found
-- - clamav_can_skip: true if ClamAV can be skipped (malicious cache hit)
-- - scanners_to_disable: table of scanners that found cache hits
--
--- @param plugin Plugin The plugin instance
--- @param state ScannerState Scanner state from scanner_get_state()
--- @param checksum string File SHA256 checksum
--- @param file_size number File size in bytes
--- @param body_file string Path to uploaded file
--- @param cache table|nil Cache module (or nil if not loaded)
--- @param webhook table|nil Webhook module (or nil if not loaded)
--- @param file_ops table|nil File operations module (or nil if not loaded)
--- @param get_deny_status function Function to get deny status code
--- @return boolean blocked True if request was blocked
--- @return table detections Table of all detections found
--- @return boolean clamav_can_skip True if ClamAV can be skipped
--- @return table scanners_to_disable Table of scanners that found cache hits
--- @return table|nil block_result Blocking result from detection_handle if blocked
function orchestrator.cache_check_all(plugin, state, checksum, file_size, body_file, cache, webhook, file_ops, get_deny_status)
	local ERR = ngx and ngx.ERR or 3
	local detections = {}
	local clamav_can_skip = false
	local scanners_to_disable = {}

	-- Scanner cache check configuration
	local scanners_to_check = {
		{name = "clamav", display = "ClamAV", enabled = state.clamav},
		{name = "virustotal", display = "VirusTotal", enabled = state.virustotal},
		{name = "sentinelone", display = "SentinelOne", enabled = state.sentinelone}
	}

	-- Check each scanner's cache
	for _, scanner in ipairs(scanners_to_check) do
		if scanner.enabled then
			local cache_hit, result, detection = orchestrator.cache_check(
				plugin, cache, scanner.name, checksum, file_size
			)

			if cache_hit and result then
				if result == "clean" then
					-- Cache shows clean - skip this scanner
					logger.log_error( "[CACHE_HIT] " .. scanner.display .. " cache shows clean - skipping scan")
					scanners_to_disable[scanner.name] = true
				elseif result == "malicious" and detection then
					-- Cache shows malicious - log detection
					logger.log_error( "[CACHE_HIT] " .. scanner.display .. " cache shows malicious")
					logger.log_error( "MALWARE DETECTED BY " .. scanner.display:upper() .. " (cached)")
					logger.log_error( scanner.display .. " detection: " .. plugin:sanitize_external_data(detection) .. " (SHA256: " .. checksum .. ")")

					detections[scanner.display .. " (cached)"] = detection
					clamav_can_skip = true  -- Can skip ClamAV since we know it's malicious

					-- Check if we should block immediately or continue scanning
					if not state.resume_on_hit then
						-- Default behavior: block immediately
						return true, detections, clamav_can_skip, scanners_to_disable,
							orchestrator.detection_handle(
								plugin, checksum, detections, body_file,
								scanner.display .. " (cached)", detection,
								webhook, file_ops, get_deny_status
							)
					else
						-- Resume mode: continue to other scanners
						logger.log_error( "[RESUME_MODE] Malware detected by " .. scanner.display .. " cache, continuing to other scanners")
					end
				end
			end
		end
	end

	-- No blocking detection found or resume mode active
	return false, detections, clamav_can_skip, scanners_to_disable, nil
end

-- Handle detection with custom message and data structure
-- Provides the same webhook + cleanup + return pattern as detection_handle(),
-- but allows custom message and return data for complex multi-scanner scenarios.
--
-- Use this for:
-- - Multi-scanner detections (e.g., both ClamAV and VirusTotal detected)
-- - Special case messages (e.g., "ClamAV detected, VirusTotal clean")
-- - Custom data structures with scanner-specific field names
--
--- @param plugin Plugin The plugin instance
--- @param checksum string|nil File SHA256 checksum (for webhook, may be nil if not yet calculated)
--- @param detections table Table of all detections (for webhook)
--- @param body_file string Path to uploaded file (for cleanup)
--- @param message string Custom message string for return
--- @param return_data table Custom data table for return (must include: id, file, and scanner-specific fields)
--- @param webhook table|nil Webhook module (or nil if not loaded)
--- @param file_ops table|nil File operations module (or nil if not loaded)
--- @param get_deny_status function Function to get deny status code
--- @return table result plugin:ret() result (5 values: blocked, message, status, nil, data)
function orchestrator.detection_handle_custom(plugin, checksum, detections, body_file,
                                               message, return_data,
                                               webhook, file_ops, get_deny_status)
	local ERR = ngx and ngx.ERR or 3

	-- Send webhook notification (centralized error handling)
	if webhook then
		webhook.notify(webhook, plugin, checksum, detections)
	end

	-- Cleanup uploaded file if enabled
	local cleanup_enabled = plugin.variables["MALWARE_SCAN_CLEANUP_FILES"]
	if cleanup_enabled ~= "no" then
		local cleanup_ok, cleanup_err
		if file_ops then
			cleanup_ok, cleanup_err = file_ops.file_cleanup(plugin, body_file)
		else
			cleanup_ok, cleanup_err = true, nil
		end
		if not cleanup_ok then
			logger.log_error( "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
		end
	end

	-- Return blocking response with custom message and data
	return plugin:ret(
		true,
		message,
		get_deny_status(),
		nil,
		return_data
	)
end

-- ============================================================================
-- SCANNER INVOCATION ORCHESTRATION
-- ============================================================================

-- Orchestrate body file scanning across all enabled scanners.
-- Handles MalwareBazaar, ClamAV, VirusTotal, and SentinelOne scanning with proper
-- cache management, detection sharing, and resume mode logic.
--
-- This function centralizes the complex scanner invocation flow that was previously
-- scattered across ~500 lines in the main access() function.
--
--- @param plugin Plugin The plugin instance
--- @param body_file string Path to uploaded file
--- @param checksum string|nil File SHA256 checksum (or nil if not calculated yet)
--- @param checksum_ok boolean Whether checksum calculation succeeded
--- @param file_size number File size in bytes
--- @param scanner_state ScannerState Scanner state table from scanner_get_state()
--- @param detections table Table of existing detections (updated in-place)
--- @param clamav table|nil ClamAV module (or nil)
--- @param virustotal table|nil VirusTotal module (or nil)
--- @param sentinelone table|nil SentinelOne module (or nil)
--- @param malwarebazaar table|nil MalwareBazaar module (or nil)
--- @param cache table|nil Cache module (or nil)
--- @param webhook table|nil Webhook module (or nil)
--- @param file_ops table|nil File operations module (or nil)
--- @param get_deny_status function Function to get HTTP deny status code
--
--- @return table|nil blocking_result plugin:ret() result OR nil if clean/continue
--- @return string detected ClamAV detection result ("clean" or signature)
--- @return table scan_info Table with scan metadata
function orchestrator.body_scan(plugin, body_file, checksum, checksum_ok, file_size,
                                scanner_state, detections,
                                clamav, virustotal, sentinelone, malwarebazaar,
                                cache, webhook, file_ops, get_deny_status)
	local ERR = ngx and ngx.ERR or 3

	-- Extract scanner states for readability
	local clamav_enabled = scanner_state.clamav
	local virustotal_enabled = scanner_state.virustotal
	local sentinelone_enabled = scanner_state.sentinelone
	local malwarebazaar_enabled = scanner_state.malwarebazaar
	local resume_on_hit = scanner_state.resume_on_hit

	-- Tracking variables
	local clamav_actually_scanned = false
	local clamav_skipped_reason = nil
	local detected = "clean"
	local vt_detected = "clean"

	-- ========================================================================
	-- FILE TYPE DETECTION (GDPR Protection)
	-- ========================================================================

	-- Detect file type for GDPR compliance
	-- Only executable malware should be uploaded to public databases
	-- Files containing user data (documents, images, databases) must NOT be uploaded
	local file_type = "unknown"
	local file_type_error = nil
	if file_ops then
		file_type, file_type_error = file_ops.file_get_type(plugin, body_file)
		if file_type then
			plugin:log_debug("File type detected: " .. file_type)
		else
			logger.log_error( "Could not detect file type: " .. (file_type_error or "unknown error"))
			file_type = "unknown"
		end
	end

	-- ========================================================================
	-- CLAMAV SCANNER (with atomic locking to prevent duplicate scans)
	-- ========================================================================

	if clamav_enabled then
		-- Try to acquire lock for this file (prevents concurrent duplicate scans)
		local should_scan = true
		local lock_acquired = false

		if checksum_ok and checksum and checksum ~= "empty_file" and cache then
			lock_acquired = cache.clamav_try_lock(plugin, checksum)

			if not lock_acquired then
				-- Another request is scanning this file - wait for result
				plugin:log_debug("[v" .. orchestrator.VERSION .. "] [CACHE_LOCK] Another request is scanning, waiting for result...")
				local wait_ok, wait_result, wait_size, wait_error = cache.clamav_wait_for_result(plugin, checksum, file_size)

				if wait_ok then
					-- Got result from concurrent scan
					plugin:log_debug(string.format("[v" .. orchestrator.VERSION .. "] [CACHE_LOCK] Got result from concurrent scan: %s", wait_result))
					detected = wait_result
					should_scan = false  -- Don't scan, use cached result

					-- Handle the waited result (same logic as if we scanned)
					if wait_result == "error" then
						-- Concurrent scan failed
						logger.log_error( "Concurrent ClamAV scan failed: " .. (wait_error or "unknown"))
						detected = "clean"  -- Continue to other scanners
					elseif orchestrator.result_is_malware(wait_result) then
						-- Concurrent scan found malware
						clamav_actually_scanned = false  -- We didn't scan, but got result
						-- Will be handled in malware detection logic below
					else
						-- Concurrent scan found clean
						clamav_actually_scanned = false  -- We didn't scan, but got result
					end
				else
					-- Timeout waiting - fall back to scanning ourselves
					logger.log_warn( "[CACHE_LOCK] Timeout waiting for result - scanning independently")
					-- Try to acquire lock again (might be available now)
					lock_acquired = cache.clamav_try_lock(plugin, checksum)
					should_scan = true
				end
			end
		end

		local ok = false
		if should_scan then
			clamav_actually_scanned = true
			plugin:log_debug("Calling scan_file() with: " .. body_file)

			if clamav then
				ok, detected = clamav.scan_file_instream(plugin, body_file)
			else
				logger.log_error( "ClamAV module not loaded")
				ok, detected = false, "ClamAV module not loaded"
			end

			plugin:log_debug("scan_file returned - ok: " .. tostring(ok) .. ", detected: " .. tostring(detected))
		end

		if not ok then
			-- Check if the error is due to file size limit
			if detected and detected:match("size limit") then
				logger.log_error( "ClamAV scan failed due to size limit: " .. detected)
				clamav_skipped_reason = "size limit exceeded"
				clamav_actually_scanned = false
			else
				logger.log_error( "ClamAV scan failed: " .. detected)
				-- Cache the error to prevent repeated failed scans (negative caching)
				if checksum_ok and checksum and checksum ~= "empty_file" and cache then
					cache.clamav_add(plugin, checksum, detected or "scan failed", file_size, true)  -- is_error = true
					plugin:log_debug("[v" .. orchestrator.VERSION .. "] [CACHE] Cached ClamAV error to prevent repeated failures")
				end
			end
			-- Don't fail the request, continue to hash-based scanners if enabled
			detected = "clean"
		elseif detected and orchestrator.result_is_malware(detected) then
			-- ClamAV detected malware
			logger.log_error( "MALWARE DETECTED BY CLAMAV")
			logger.log_error( "ClamAV signature: " .. plugin:sanitize_external_data(detected) .. " in file: " .. plugin:sanitize_external_data(body_file))

			-- Cache the ClamAV detection result
			if checksum_ok and checksum and checksum ~= "empty_file" and cache then
				cache.clamav_add(plugin, checksum, detected, file_size)
			end

			-- Export malware sample to local directory for forensic analysis (if enabled)
			if file_ops and checksum_ok and checksum and checksum ~= "empty_file" then
				local export_ok, export_err = file_ops.virusfile_export(
					plugin,
					body_file,
					checksum,
					"ClamAV",
					detected,
					file_type
				)
				if not export_ok and export_err then
					plugin:log_debug("[v" .. orchestrator.VERSION .. "] [EXPORT] Failed to export malware sample: " .. export_err)
				end
			end

			-- Check if we should skip cloud scanners and block immediately
			local skip_others = plugin.variables["MALWARE_SCAN_SKIP_OTHERS_ON_CLAMAV_DETECT"]
			local any_cloud_enabled = virustotal_enabled or sentinelone_enabled
			if (skip_others == "yes" or not any_cloud_enabled) and not resume_on_hit then
				-- Block immediately (default behavior)
				logger.log_error( "BLOCKING REQUEST - skipping cloud scanner checks (faster response)")
				if detected and orchestrator.result_is_malware(detected) then
					detections["ClamAV"] = detected
				end

				-- Use orchestrator detection handler
				local deny_status = get_deny_status()
				plugin:log_debug("Returning block status: " .. tostring(deny_status))

				local blocking_result = orchestrator.detection_handle(
					plugin, checksum, detections, body_file,
					"ClamAV", detected,
					webhook, file_ops, get_deny_status
				)

				-- Release lock before returning
				if lock_acquired and checksum_ok and checksum and checksum ~= "empty_file" and cache then
					cache.clamav_release_lock(plugin, checksum)
				end

				return blocking_result, detected, {
					clamav_actually_scanned = clamav_actually_scanned,
					clamav_skipped_reason = clamav_skipped_reason,
					vt_detected = vt_detected,
					checksum = checksum,
					checksum_ok = checksum_ok
				}
			else
				-- Continue to cloud scanners for additional analysis
				if resume_on_hit then
					logger.log_error( "[RESUME_MODE] ClamAV detected malware, continuing to all remaining scanners")
				else
					logger.log_error( "ClamAV detected malware, continuing to cloud scanners for additional analysis")
				end
				-- Add ClamAV detection to detections table
				if detected and orchestrator.result_is_malware(detected) then
					detections["ClamAV"] = detected
				end
				-- Keep detected value, will be used in final decision
			end
		else
			-- ClamAV reported clean - cache this result too
			logger.log_error( "ClamAV scan: file is clean")
			if checksum_ok and checksum and checksum ~= "empty_file" and cache then
				cache.clamav_add(plugin, checksum, "clean", file_size)
			end
		end

		-- Release lock after scan completes (success, error, or clean)
		if lock_acquired and checksum_ok and checksum and checksum ~= "empty_file" and cache then
			cache.clamav_release_lock(plugin, checksum)
		end
	else
		logger.log_error( "ClamAV scanning disabled, skipping to VirusTotal")
	end

	-- ========================================================================
	-- HASH-BASED SCANNERS (MalwareBazaar, VirusTotal, SentinelOne)
	-- ========================================================================

	if malwarebazaar_enabled or virustotal_enabled or sentinelone_enabled then
		-- Reuse checksum from early cache check if available, otherwise calculate now
		if not checksum_ok or not checksum then
			-- Check file size before calculating SHA256
			local file_size_for_hash = file_ops and file_ops.file_get_size(plugin, body_file) or nil

			-- Validate hash_max_size from config (ensure it's a positive number, default 64MB, max 10GB)
			local hash_max_size = utils.validate_file_size(
				tonumber(plugin.variables["MALWARE_SCAN_HASH_MAX_SIZE"]),
				10 * 1024 * 1024 * 1024  -- Max 10GB
			)
			if hash_max_size == 0 then
				hash_max_size = 67108864  -- Fallback to 64MB if validation failed
			end

			-- Validate file_size_for_hash
			if file_size_for_hash then
				file_size_for_hash = utils.validate_file_size(file_size_for_hash, 10 * 1024 * 1024 * 1024)
			end

			if file_size_for_hash and file_size_for_hash > 0 and file_size_for_hash > hash_max_size then
				logger.log_error( "[SIZE_LIMIT] File size " .. file_size_for_hash .. " bytes exceeds hash scan limit " .. hash_max_size .. " bytes - skipping hash-based scanners")
				checksum_ok = false
				checksum = nil
			else
				logger.log_error( "Hash-based scanning enabled, calculating SHA256 checksum")
				if file_ops then
					checksum_ok, checksum = file_ops.hash_calculate(plugin, body_file)
				else
					checksum_ok, checksum = false, nil
				end
			end
		else
			logger.log_error( "Hash-based scanning enabled, reusing previously calculated SHA256")
		end

		if checksum_ok then
			logger.log_error( "file SHA256: " .. checksum)

			-- Check if file is empty (0 bytes)
			if checksum == "empty_file" then
				logger.log_error( "file is 0 bytes, skipping hash-based checks")
				vt_detected = "clean"
			else
				-- ============================================================
				-- MALWAREBAZAAR HASH LOOKUP (check first - fastest: <1ms Redis lookup)
				-- ============================================================

				if malwarebazaar_enabled then
					logger.log_error( "checking file against MalwareBazaar hash database (1M+ known malware hashes)")
					local mbz_ok, mbz_result
					if malwarebazaar then
						mbz_ok, mbz_result = malwarebazaar.hash_check(plugin, checksum, file_size)
					else
						mbz_ok, mbz_result = true, "clean"
					end

					if mbz_ok and orchestrator.result_is_malware(mbz_result) then
						logger.log_error( "MALWARE DETECTED BY MALWAREBAZAAR")
						logger.log_error( "MalwareBazaar detection: " .. plugin:sanitize_external_data(mbz_result) .. " (SHA256: " .. checksum .. ")")
						detections["MalwareBazaar"] = mbz_result

						-- Share file with threat intelligence platforms if enabled
						local share_ok, share_err = plugin:detection_share(body_file, checksum, "MalwareBazaar", virustotal, file_type)
						if not share_ok then
							logger.log_error( "[SHARE] Failed to share file: " .. share_err)
						end

						-- Check if we should block immediately or continue scanning
						if not resume_on_hit then
							-- Default behavior: block immediately
							logger.log_error( "BLOCKING REQUEST")

							-- Use orchestrator detection handler
							local blocking_result = orchestrator.detection_handle(
								plugin, checksum, detections, body_file,
								"MalwareBazaar", mbz_result,
								webhook, file_ops, get_deny_status
							)

							return blocking_result, detected, {
								clamav_actually_scanned = clamav_actually_scanned,
								clamav_skipped_reason = clamav_skipped_reason,
								vt_detected = vt_detected,
								checksum = checksum,
								checksum_ok = checksum_ok
							}
						else
							-- Resume mode: continue to remaining scanners
							logger.log_error( "[RESUME_MODE] Malware detected by MalwareBazaar, continuing to remaining scanners")
						end
					else
						logger.log_error( "MalwareBazaar hash database: hash not found (clean or unknown)")
					end
				end

				-- ============================================================
				-- VIRUSTOTAL SCANNER
				-- ============================================================

				if virustotal_enabled then
					logger.log_error( "checking file against VirusTotal API")
					local vt_ok, vt_result, vt_found
					if virustotal then
						vt_ok, vt_result, vt_found = virustotal.check_virustotal(plugin, body_file, checksum)
					else
						vt_ok, vt_result, vt_found = true, "clean", false
					end
					if vt_ok then
						vt_detected = vt_result

						-- Check if we should upload unknown malware to VT
						if not vt_found and detected and orchestrator.result_is_malware(detected) then
							-- ClamAV detected malware, but VT doesn't have the file
							if plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_UPLOAD_UNKNOWN"] == "yes" then
								-- **GDPR PROTECTION**: Only upload executables, NEVER upload user data files
								-- Check if file type is known AND safe to upload (not user data)
								-- CRITICAL: Unknown types are NOT uploaded (GDPR-safe default)
								local filetypes = require("malware_scan_filetypes")
								local is_safe_to_upload = file_type and file_type ~= "unknown" and not filetypes.contains_user_data(file_type)

								if not file_type or file_type == "unknown" then
									-- Unknown file type - DO NOT UPLOAD (GDPR-safe default)
									logger.log_error( "ClamAV detected malware but file type unknown - GDPR protection: NOT uploading to VirusTotal (cannot verify if file contains personal data)")
								elseif filetypes.contains_user_data(file_type) then
									-- File may contain personal data - DO NOT UPLOAD
									logger.log_error( string.format(
										"ClamAV detected malware but file may contain user data (type: %s) - GDPR protection: NOT uploading to VirusTotal",
										file_type
									))
									logger.log_error( "File type categories: documents, images, databases, archives may contain personal data and will not be uploaded")
								elseif is_safe_to_upload and virustotal then
									-- File is known executable/script - SAFE TO UPLOAD
									logger.log_error( string.format(
										"ClamAV detected malware but VT doesn't have file (type: %s) - uploading to VirusTotal",
										file_type
									))
									local upload_ok, analysis_id, uploaded_size = virustotal.file_upload(plugin, body_file)
									if upload_ok then
										logger.log_error( "file uploaded successfully (" .. uploaded_size .. " bytes), analysis ID: " .. tostring(analysis_id))

										-- Check if we should auto-vote
										if plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_AUTO_VOTE"] == "yes" then
											logger.log_error( "auto-voting file as malicious on VirusTotal")
											local vote_ok, vote_err = virustotal.file_vote(plugin, checksum, "malicious")
											if vote_ok then
												logger.log_error( "malicious vote submitted successfully")
											else
												logger.log_error( "failed to submit vote: " .. vote_err)
											end
										end
									else
										logger.log_error( "failed to upload file to VirusTotal: " .. analysis_id)
									end
								end
							else
								logger.log_error( "ClamAV detected malware but VT doesn't have file (upload disabled)")
							end
						end

						if orchestrator.result_is_malware(detected) then
							logger.log_error( "MALWARE DETECTED BY VIRUSTOTAL")
							logger.log_error( "VirusTotal detection: " .. plugin:sanitize_external_data(vt_detected) .. " (SHA256: " .. checksum .. ")")
							detections["VirusTotal"] = vt_detected

							-- Check if we should block immediately or continue scanning
							if not resume_on_hit then
								-- Default behavior: block immediately
								logger.log_error( "BLOCKING REQUEST")

								-- Use orchestrator detection handler
								local blocking_result = orchestrator.detection_handle(
									plugin, checksum, detections, body_file,
									"VirusTotal", vt_detected,
									webhook, file_ops, get_deny_status
								)

								return blocking_result, detected, {
									clamav_actually_scanned = clamav_actually_scanned,
									clamav_skipped_reason = clamav_skipped_reason,
									vt_detected = vt_detected,
									checksum = checksum,
									checksum_ok = checksum_ok
								}
							else
								-- Resume mode: continue to remaining scanners
								logger.log_error( "[RESUME_MODE] Malware detected by VirusTotal, continuing to remaining scanners")
							end
						else
							logger.log_error( "VirusTotal scan: file is clean")
						end
					else
						logger.log_error( "VirusTotal check failed: " .. vt_result)
					end
				end

				-- ============================================================
				-- SENTINELONE SCANNER
				-- ============================================================

				if sentinelone_enabled then
					logger.log_error( "checking file against SentinelOne API")
					local s1_ok, s1_result
					if sentinelone then
						s1_ok, s1_result = sentinelone.check_sentinelone(plugin, checksum, file_size)
					else
						s1_ok, s1_result = true, "clean"
					end
					if s1_ok then
						local sentinelone_detected = s1_result
						if orchestrator.result_is_malware(detected) then
							logger.log_error( "MALWARE DETECTED BY SENTINELONE")
							logger.log_error( "SentinelOne detection: " .. plugin:sanitize_external_data(sentinelone_detected) .. " (SHA256: " .. checksum .. ")")
							detections["SentinelOne"] = sentinelone_detected

							-- Share file with threat intelligence platforms if enabled
							local share_ok, share_err = plugin:detection_share(body_file, checksum, "SentinelOne", virustotal, file_type)
							if not share_ok then
								logger.log_error( "[SHARE] Failed to share file: " .. share_err)
							end

							-- Check if we should block immediately or continue scanning
							if not resume_on_hit then
								-- Default behavior: block immediately
								logger.log_error( "BLOCKING REQUEST")

								-- Use orchestrator detection handler
								local blocking_result = orchestrator.detection_handle(
									plugin, checksum, detections, body_file,
									"SentinelOne", sentinelone_detected,
									webhook, file_ops, get_deny_status
								)

								return blocking_result, detected, {
									clamav_actually_scanned = clamav_actually_scanned,
									clamav_skipped_reason = clamav_skipped_reason,
									vt_detected = vt_detected,
									checksum = checksum,
									checksum_ok = checksum_ok
								}
							else
								-- Resume mode: continue (all scanners complete)
								logger.log_error( "[RESUME_MODE] Malware detected by SentinelOne")
							end
						else
							logger.log_error( "SentinelOne scan: file is clean")
						end
					else
						logger.log_error( "SentinelOne check failed: " .. s1_result)
					end
				end
			end
		else
			logger.log_error( "failed to calculate SHA256: " .. tostring(checksum))
		end
	end

	-- ========================================================================
	-- POST-SCAN PROCESSING
	-- ========================================================================

	-- Return scan info for caller to handle post-processing
	-- Caller will handle:
	-- - Webhook notification
	-- - File cleanup
	-- - Resume mode final block
	-- - Multi-scanner comparison
	-- - Success message building
	return nil, detected, {
		clamav_actually_scanned = clamav_actually_scanned,
		clamav_skipped_reason = clamav_skipped_reason,
		vt_detected = vt_detected,
		checksum = checksum,
		checksum_ok = checksum_ok
	}
end

-- Handle resume mode final blocking with all collected detections.
-- Called after all scanners complete in resume mode when at least one detection exists.
--
--- @param plugin Plugin The plugin instance
--- @param checksum string|nil File SHA256 checksum (may be nil if not yet calculated)
--- @param detections table Table of all detections from all scanners
--- @param body_file string Path to uploaded file
--- @param webhook table|nil Webhook module (or nil)
--- @param file_ops table|nil File operations module (or nil)
--- @param get_deny_status function Function to get HTTP deny status code
--- @return boolean|string|number|table result Plugin return values (5 values via plugin:ret)
function orchestrator.detection_handle_resume_mode(plugin, checksum, detections, body_file,
                                                    webhook, file_ops, get_deny_status)
	local ERR = ngx and ngx.ERR or 3

	-- Build scanner list from all detections
	local scanner_list = {}
	for scanner, detection in pairs(detections) do
		table.insert(scanner_list, scanner)
	end

	logger.log_error( "[RESUME_MODE] All scanners complete - MALWARE DETECTED BY: " .. table.concat(scanner_list, ", "))
	logger.log_error( "[RESUME_MODE] Blocking request with comprehensive detection data")

	-- Send webhook notification (single webhook, not double)
	if webhook then
		webhook.notify(webhook, plugin, checksum, detections)
	end

	-- Cleanup uploaded file if enabled
	local cleanup_enabled = plugin.variables["MALWARE_SCAN_CLEANUP_FILES"]
	if cleanup_enabled ~= "no" then
		local cleanup_ok, cleanup_err
		if file_ops then
			cleanup_ok, cleanup_err = file_ops.file_cleanup(plugin, body_file)
		else
			cleanup_ok, cleanup_err = true, nil
		end
		if not cleanup_ok then
			logger.log_error( "failed to cleanup temp file " .. body_file .. ": " .. cleanup_err)
		end
	end

	-- Return blocking response with resume mode data
	return plugin:ret(
		true,
		"malware detected (resume mode - collected " .. #scanner_list .. " detections)",
		get_deny_status(),
		nil,
		{
			id = "malware_detected_resume_mode",
			file = body_file,
			checksum = checksum,
			detections = detections,
			scanner_count = #scanner_list
		}
	)
end

-- ============================================================================
-- PRE-SCAN VALIDATION
-- ============================================================================

-- Perform pre-scan validation and initialization.
-- Handles scanner state setup, body file retrieval, and SHA256 calculation.
-- Returns scan context object with all necessary information for scanning.
--
--- @param plugin Plugin instance
--- @param file_ops table|nil File operations module
--- @param ui_metrics_module table|nil UI metrics module (optional)
--- @param webhook table|nil Webhook module (optional)
--- @param get_deny_status function Function to get deny status code
--- @return table|nil scan_ctx Scan context object, or nil on error
--- @return table|nil result Plugin return value if early exit needed
function orchestrator.pre_scan_validate(plugin, file_ops, ui_metrics_module, webhook, get_deny_status)
	-- Get scanner state
	local scanner_state = orchestrator.scanner_get_state(plugin)

	-- Extract scanner states for compatibility
	local clamav_enabled = scanner_state.clamav
	local virustotal_enabled = scanner_state.virustotal
	local sentinelone_enabled = scanner_state.sentinelone
	local malwarebazaar_enabled = scanner_state.malwarebazaar
	local resume_on_hit = scanner_state.resume_on_hit

	-- Table to collect all detections for single webhook notification
	local detections = {}

	-- Log resume mode if enabled
	if resume_on_hit then
		logger.log_error( "[RESUME_MODE] Resume scan on first hit enabled - will collect all scanner results before blocking")
	end

	-- Check if webhooks are configured
	local teams_url = plugin.variables["MALWARE_SCAN_TEAMS_WEBHOOK_URL"]
	local discord_url = plugin.variables["MALWARE_SCAN_DISCORD_WEBHOOK_URL"]
	local webhook_enabled = webhook and
	                        ((teams_url and teams_url ~= "" and teams_url ~= "your_webhook_url") or
	                         (discord_url and discord_url ~= "" and discord_url ~= "your_webhook_url"))

	plugin:log_debug("[WEBHOOK_DEBUG] webhook_enabled=" .. tostring(webhook_enabled) ..
	                 ", teams_url=" .. plugin:mask_sensitive(teams_url or "") ..
	                 ", discord_url=" .. plugin:mask_sensitive(discord_url or ""))

	-- Check if any scanner is enabled
	local any_scanner_enabled = clamav_enabled or virustotal_enabled or sentinelone_enabled or malwarebazaar_enabled
	if not any_scanner_enabled then
		logger.log_error( "MALWARE SCANNING NOT ENABLED - all scanners disabled")
		return nil, plugin:ret(true, "malware scanning not enabled")
	end

	-- Build scanner list message
	local scanners = orchestrator.scanner_get_enabled(scanner_state)

	if #scanners > 1 then
		logger.log_error( "Multi-layer scanning enabled (" .. table.concat(scanners, " + ") .. ")")
	else
		logger.log_error( scanners[1] .. "-only scanning enabled")
	end

	logger.log_error( "file upload detected, scanning for malware")

	-- Track file scan metric
	if ui_metrics_module then
		ui_metrics_module.track_file_scanned(plugin)
	end

	-- Read request body
	ngx.req.read_body()
	local body_file = ngx.req.get_body_file()

	plugin:log_debug("body_file = " .. tostring(body_file))

	-- Validate body file availability
	if not body_file then
		logger.log_error(
			"upload body in memory, not in file - increase client_body_buffer_size " ..
			"or decrease it to force file buffering for virus scanning"
		)

		if plugin.variables["MALWARE_SCAN_BLOCK_MEMORY_UPLOADS"] == "yes" then
			logger.log_error( "BLOCKING UPLOAD - cannot scan files in memory (need file buffering)")
			return nil, plugin:ret(
				true,
				"upload in memory blocked - cannot scan (increase client_body_buffer_size)",
				get_deny_status(),
				nil,
				{
					id = "unscannable_memory",
					reason = "body in memory, not file"
				}
			)
		else
			return nil, plugin:ret(true, "upload in memory, skipping scan (WARNING)")
		end
	end

	-- Calculate SHA256 checksum (used for webhooks, logging, and hash-based scanners)
	local checksum, checksum_ok
	local file_size = file_ops and file_ops.file_get_size(plugin, body_file) or nil
	local hash_max_size = tonumber(plugin.variables["MALWARE_SCAN_HASH_MAX_SIZE"]) or 67108864  -- default 64MB

	if file_size and file_size > hash_max_size then
		logger.log_error( "[SIZE_LIMIT] File size " .. file_size .. " bytes exceeds hash scan limit " .. hash_max_size .. " bytes - skipping SHA256 calculation")
		checksum_ok = false
		checksum = nil
	else
		-- Always calculate checksum for webhooks and logging, even in ClamAV-only mode
		if file_ops then
			checksum_ok, checksum = file_ops.hash_calculate(plugin, body_file)
		else
			checksum_ok, checksum = false, nil
		end
		if checksum_ok and checksum ~= "empty_file" then
			logger.log_error( "file SHA256: " .. checksum)
		end
	end

	-- Return scan context
	return {
		success = true,
		body_file = body_file,
		checksum = checksum,
		checksum_ok = checksum_ok,
		file_size = file_size,
		scanner_state = scanner_state,
		detections = detections,
		webhook_enabled = webhook_enabled
	}, nil
end

-- ============================================================================
-- COMPREHENSIVE CACHE CHECKING
-- ============================================================================

-- Perform comprehensive cache checking for all scanners.
-- Checks both ClamAV cache and hash-based scanner caches.
-- Returns updated scanner state and detection results.
--
--- @param plugin Plugin instance
--- @param scan_ctx table Scan context from pre_scan_validate()
--- @param cache table Cache module
--- @param webhook table|nil Webhook module (optional)
--- @param file_ops table|nil File operations module
--- @param ui_metrics_module table|nil UI metrics module (optional)
--- @param get_deny_status function Function to get deny status code
--- @return table result Table with {blocked, detections, scanner_state, block_result}
function orchestrator.cache_check_comprehensive(plugin, scan_ctx, cache, webhook, file_ops, ui_metrics_module, get_deny_status)
	local scanner_state = scan_ctx.scanner_state
	local checksum = scan_ctx.checksum
	local checksum_ok = scan_ctx.checksum_ok
	local file_size = scan_ctx.file_size
	local body_file = scan_ctx.body_file
	local detections = scan_ctx.detections

	-- Extract scanner states
	local clamav_enabled = scanner_state.clamav
	local virustotal_enabled = scanner_state.virustotal
	local sentinelone_enabled = scanner_state.sentinelone
	local malwarebazaar_enabled = scanner_state.malwarebazaar
	local resume_on_hit = scanner_state.resume_on_hit

	-- Get hash max size
	local hash_max_size = tonumber(plugin.variables["MALWARE_SCAN_HASH_MAX_SIZE"]) or 67108864  -- default 64MB

	-- Check ClamAV cache first (works even in ClamAV-only mode)
	if clamav_enabled and checksum_ok and checksum and checksum ~= "empty_file" then
		local clamav_cache_ok, clamav_cached, _, error_msg
		if cache then
			clamav_cache_ok, clamav_cached, _, error_msg = cache.clamav_check(plugin, checksum, file_size)
		else
			clamav_cache_ok, clamav_cached, _, error_msg = true, nil, nil, nil
		end

		if clamav_cache_ok and clamav_cached == "error" then
			-- Cached error - skip ClamAV scan to avoid repeated failures
			clamav_enabled = false  -- Disable ClamAV scan since we have cached error
			logger.log_error( "[CACHE_HIT] ClamAV previously failed for this file - skipping scan: " .. (error_msg or "unknown error"))
			plugin:log_debug("[CACHE_HIT] File scan previously failed, continuing to hash-based scanners")
		elseif clamav_cache_ok and clamav_cached and clamav_cached ~= "clean" then
			-- Cached result is MALICIOUS
			clamav_enabled = false  -- Disable ClamAV scan since we have cached result
			logger.log_error( "[CACHE_HIT] ClamAV cache shows malicious - skipping ClamAV scan")
			logger.log_error( "MALWARE DETECTED BY CLAMAV (cached)")
			logger.log_error( "ClamAV signature: " .. plugin:sanitize_external_data(clamav_cached) .. " (SHA256: " .. checksum .. ")")
			detections["ClamAV (cached)"] = clamav_cached

			-- Track cache hit and malware detection
			if ui_metrics_module then
				ui_metrics_module.track_cache_hit(plugin, "clamav")
				ui_metrics_module.track_detection_complete(plugin, "ClamAV (cached)", clamav_cached, checksum, detections)
			end

			-- Check if we should block immediately or continue scanning
			if not resume_on_hit then
				-- Default behavior: block immediately
				local block_result = orchestrator.detection_handle(
					plugin, checksum, detections, body_file,
					"ClamAV (cached)", clamav_cached,
					webhook, file_ops, get_deny_status
				)
				return {
					blocked = true,
					detections = detections,
					scanner_state = {
						clamav = clamav_enabled,
						virustotal = virustotal_enabled,
						sentinelone = sentinelone_enabled,
						malwarebazaar = malwarebazaar_enabled,
						resume_on_hit = resume_on_hit
					},
					block_result = block_result
				}
			else
				-- Resume mode: continue to other scanners for comprehensive intelligence
				logger.log_error( "[RESUME_MODE] Malware detected by ClamAV cache, continuing to other scanners")
			end
		elseif clamav_cache_ok and clamav_cached and clamav_cached == "clean" then
			-- Cached result is CLEAN - skip ClamAV scan, allow file
			clamav_enabled = false  -- Disable ClamAV scan for this request
			logger.log_error( "[CACHE_HIT] ClamAV cache shows clean - skipping ClamAV scan")
			plugin:log_debug("[CACHE_HIT] File is known clean from cache, allowing upload without scan")

			-- Track cache hit
			if ui_metrics_module then
				ui_metrics_module.track_cache_hit(plugin, "clamav")
			end
		end
	end

	-- OPTIMIZATION: Check hash-based caches BEFORE ClamAV to avoid wasting resources
	-- If we already know the file is malicious from cache, skip ClamAV scan entirely
	local clamav_can_skip = false
	if virustotal_enabled or sentinelone_enabled or malwarebazaar_enabled then
		if file_size and file_size > hash_max_size then
			logger.log_error( "[SIZE_LIMIT] Skipping hash-based scanners for oversized file")
		elseif checksum_ok and checksum and checksum ~= "empty_file" then
			logger.log_error( "[CACHE_CHECK] Checking hash-based caches before ClamAV scan")

			-- Check all hash-based scanner caches
			local blocked, cache_detections, skip_clamav, scanners_disabled, block_result =
				orchestrator.cache_check_all(
					plugin, scanner_state, checksum, file_size, body_file,
					cache, webhook, file_ops, get_deny_status
				)

			-- Merge cache detections into main detections table
			for scanner, detection in pairs(cache_detections) do
				detections[scanner] = detection
			end

			-- Update clamav_can_skip flag
			if skip_clamav then
				clamav_can_skip = true
			end

			-- Disable scanners that found cache hits
			if scanners_disabled.virustotal then virustotal_enabled = false end
			if scanners_disabled.sentinelone then sentinelone_enabled = false end
			if scanners_disabled.malwarebazaar then malwarebazaar_enabled = false end

			-- If blocked, return immediately
			if blocked and block_result then
				return {
					blocked = true,
					detections = detections,
					scanner_state = {
						clamav = clamav_enabled,
						virustotal = virustotal_enabled,
						sentinelone = sentinelone_enabled,
						malwarebazaar = malwarebazaar_enabled,
						resume_on_hit = resume_on_hit
					},
					block_result = block_result
				}
			end
		end
	end

	-- Return updated state (not blocked)
	return {
		blocked = false,
		detections = detections,
		scanner_state = {
			clamav = clamav_enabled,
			virustotal = virustotal_enabled,
			sentinelone = sentinelone_enabled,
			malwarebazaar = malwarebazaar_enabled,
			resume_on_hit = resume_on_hit
		},
		clamav_can_skip = clamav_can_skip,
		block_result = nil
	}
end

-- Configure scan limits and determine which scanners to use.
-- Handles multipart body skip logic and file size limit checks.
-- Returns updated scanner configuration for body scan and file extraction.
--
--- @param plugin Plugin instance
--- @param scan_ctx ScanContext Scan context from pre_scan_validate()
--- @return table config Table with scan configuration
function orchestrator.configure_scan_limits(plugin, scan_ctx)
	local scanner_state = scan_ctx.scanner_state
	local file_size = scan_ctx.file_size

	-- Extract current scanner states
	local clamav_enabled = scanner_state.clamav
	local virustotal_enabled = scanner_state.virustotal
	local sentinelone_enabled = scanner_state.sentinelone
	local malwarebazaar_enabled = scanner_state.malwarebazaar

	-- Check if we should skip full multipart body scan
	-- For multipart uploads, the body SHA256 changes on every upload due to random HTTP boundaries,
	-- making caching ineffective and wasting ClamAV resources. Individual file extraction always occurs.
	local skip_full_body_scan = false
	local is_multipart = plugin.ctx.bw.http_content_type and plugin.ctx.bw.http_content_type:match("multipart/form%-data")
	local scan_full_body = plugin.variables["MALWARE_SCAN_SCAN_FULL_MULTIPART_BODY"]

	-- Save original scanner enabled states before potentially disabling for body scan
	local clamav_enabled_for_files = clamav_enabled
	local virustotal_enabled_for_files = virustotal_enabled
	local sentinelone_enabled_for_files = sentinelone_enabled
	local malwarebazaar_enabled_for_files = malwarebazaar_enabled

	if is_multipart and (scan_full_body == nil or scan_full_body == "" or scan_full_body == "no") then
		skip_full_body_scan = true
		plugin.logger:log(ERR, "[MULTIPART] Skipping full body scan (random boundaries prevent caching) - will extract and scan individual files")
		-- Skip both ClamAV and external API scanners for the body
		-- Individual files will be scanned in multipart_full_scan module
		clamav_enabled = false
		virustotal_enabled = false
		sentinelone_enabled = false
		malwarebazaar_enabled = false
	end

	-- Check file size for ClamAV scan limit
	local clamav_skipped_reason = nil
	if clamav_enabled and file_size then
		local max_size = tonumber(plugin.variables["MALWARE_SCAN_CLAMAV_MAX_SIZE"]) or 26214400
		if file_size > max_size then
			plugin.logger:log(
				ERR,
				"file too large for ClamAV INSTREAM scan: " .. file_size .. " bytes (max: " .. max_size .. " bytes), skipping ClamAV scan"
			)
			clamav_skipped_reason = "file too large (" .. file_size .. " bytes)"
			clamav_enabled = false  -- Skip ClamAV scan, continue with hash-based scanners
		end
	end

	-- Return updated configuration
	return {
		skip_full_body_scan = skip_full_body_scan,
		scanner_state = {
			clamav = clamav_enabled,
			virustotal = virustotal_enabled,
			sentinelone = sentinelone_enabled,
			malwarebazaar = malwarebazaar_enabled,
			resume_on_hit = scanner_state.resume_on_hit
		},
		scanner_state_for_files = {
			clamav = clamav_enabled_for_files,
			virustotal = virustotal_enabled_for_files,
			sentinelone = sentinelone_enabled_for_files,
			malwarebazaar = malwarebazaar_enabled_for_files,
			resume_on_hit = scanner_state.resume_on_hit
		},
		clamav_skipped_reason = clamav_skipped_reason
	}
end

-- Handle post-scan processing including notifications, cleanup, and multipart scanning.
-- Processes scan results, handles resume mode, and performs final cleanup.
-- Returns plugin result (success/blocked).
--
--- @param plugin Plugin instance
--- @param scan_ctx ScanContext Scan context with file information
--- @param scan_limits ScanLimits Scan limits from configure_scan_limits()
--- @param scan_result ScanResult Result from body_scan() {detected, checksum, checksum_ok, clamav_actually_scanned}
--- @param webhook table|nil Webhook module
--- @param file_ops table|nil File operations module
--- @param multipart_full_scan table|nil Multipart full scan module (optional)
--- @param multipart_full_scan_load_ok boolean Module load status
--- @param get_deny_status function Function to get deny status code
--- @return boolean|string|number|table result Plugin return value (multiple values via plugin:ret)
function orchestrator.post_scan_complete(plugin, scan_ctx, scan_limits, scan_result, webhook, file_ops, multipart_full_scan, multipart_full_scan_load_ok, get_deny_status)
	local body_file = scan_ctx.body_file
	local checksum = scan_result.checksum or scan_ctx.checksum
	local detections = scan_ctx.detections
	local scanner_state = scan_limits.scanner_state
	local resume_on_hit = scanner_state.resume_on_hit
	local skip_full_body_scan = scan_limits.skip_full_body_scan
	local detected = scan_result.detected
	local clamav_actually_scanned = scan_result.clamav_actually_scanned
	local clamav_skipped_reason = scan_limits.clamav_skipped_reason

	-- Send webhook notification with all detections (centralized error handling)
	if webhook then
		webhook.notify(webhook, plugin, checksum, detections)
	end

	-- Clean up temp file after all scans complete (unless resume mode needs it for multipart parsing)
	local cleanup_enabled = plugin.variables["MALWARE_SCAN_CLEANUP_FILES"]
	if cleanup_enabled ~= "no" and not resume_on_hit then
		local cleanup_ok = false
		local cleanup_err = nil
		if file_ops then
			cleanup_ok, cleanup_err = file_ops.file_cleanup(plugin, body_file)
		end
		if not cleanup_ok then
			plugin.logger:log(
				ERR,
				"failed to cleanup temp file " .. body_file .. ": " .. cleanup_err
			)
		end
	elseif resume_on_hit then
		plugin:log_debug("[v" .. orchestrator.VERSION .. "] [RESUME_MODE] Preserving body file for multipart per-file scanning")
	end

	-- If resume mode is enabled and any detections exist, block now with all collected intelligence
	if resume_on_hit and next(detections) ~= nil then
		-- Use orchestrator resume mode handler (fixes duplicate webhook bug)
		return orchestrator.detection_handle_resume_mode(
			plugin, checksum, detections, body_file,
			webhook, file_ops, get_deny_status
		)
	end

	-- If we reach here and ClamAV detected, build comprehensive multi-scanner response
	if detected and detected ~= "clean" then
		-- Add ClamAV to detections table if not already there
		if not detections["ClamAV"] then
			detections["ClamAV"] = detected
		end

		-- Build list of ALL scanners that detected malware
		local scanner_list = {}
		local scanner_details = {}

		-- Guaranteed: ClamAV detected (we're in this block)
		table.insert(scanner_list, "ClamAV")
		scanner_details["clamav_signature"] = detected

		-- Check other scanners from detections table
		if detections["VirusTotal"] then
			table.insert(scanner_list, "VirusTotal")
			scanner_details["virustotal_detection"] = detections["VirusTotal"]
		end
		if detections["SentinelOne"] then
			table.insert(scanner_list, "SentinelOne")
			scanner_details["sentinelone_detection"] = detections["SentinelOne"]
		end

		-- Build comprehensive log message
		local scanner_count = #scanner_list
		if scanner_count == 1 then
			plugin.logger:log(ERR, "MALWARE DETECTED BY CLAMAV - BLOCKING REQUEST")
			plugin.logger:log(ERR, "ClamAV: " .. plugin:sanitize_external_data(detected))
		else
			plugin.logger:log(ERR, "MALWARE DETECTED BY " .. table.concat(scanner_list, ", "):upper() .. " - BLOCKING REQUEST")
			-- Log individual scanner results
			for scanner, detection in pairs(detections) do
				plugin.logger:log(ERR, scanner .. ": " .. plugin:sanitize_external_data(detection))
			end
		end

		-- Build message for return
		local message
		if scanner_count == 1 then
			message = "malware detected by ClamAV (" .. detected .. ")"
		elseif scanner_count == 2 then
			message = "malware detected by " .. scanner_list[1] .. " and " .. scanner_list[2]
		else
			-- 3+ scanners: "MalwareBazaar, ClamAV, and VirusTotal"
			local last_scanner = table.remove(scanner_list)
			message = "malware detected by " .. table.concat(scanner_list, ", ") .. ", and " .. last_scanner
		end

		-- Build return data structure with all scanner details
		local return_data = {
			id = scanner_count == 1 and "malware_detected_clamav" or "malware_detected_multi",
			file = body_file,
			checksum = checksum,
			scanner = table.concat(scanner_list, "+"),
			scanner_count = scanner_count
		}

		-- Add scanner-specific fields
		for field, value in pairs(scanner_details) do
			return_data[field] = value
		end

		-- Use orchestrator custom detection handler (handles any scanner combination)
		return orchestrator.detection_handle_custom(
			plugin, checksum, detections, body_file,
			message,
			return_data,
			webhook, file_ops, get_deny_status
		)
	end

	-- ============================================================================
	-- MULTIPART FULL SCAN: PER-FILE SCANNING
	-- ============================================================================
	-- If we reach here, whole-body scan is complete (either clean or resume mode).
	-- When resume mode is enabled OR full body scan was skipped, parse multipart upload and scan each file individually.

	if (resume_on_hit or skip_full_body_scan) and multipart_full_scan_load_ok and multipart_full_scan then
		-- Build enabled scanners table for multipart full scan module
		-- Always use saved states (before body scan disable) for individual file scanning
		local enabled_scanners = {
			clamav = scan_limits.scanner_state_for_files.clamav or clamav_actually_scanned,
			virustotal = scan_limits.scanner_state_for_files.virustotal,
			sentinelone = scan_limits.scanner_state_for_files.sentinelone,
			malwarebazaar = scan_limits.scanner_state_for_files.malwarebazaar
		}

		-- DEBUG: Log enabled scanners for multipart scanning
		local VERSION = orchestrator.VERSION
		plugin.logger:log(ERR, string.format("[v%s] [MULTIPART_DEBUG] enabled_scanners: clamav=%s, virustotal=%s, sentinelone=%s, malwarebazaar=%s",
			VERSION, tostring(enabled_scanners.clamav), tostring(enabled_scanners.virustotal),
			tostring(enabled_scanners.sentinelone), tostring(enabled_scanners.malwarebazaar)))
		plugin.logger:log(ERR, string.format("[v%s] [MULTIPART_DEBUG] skip_full_body_scan=%s",
			VERSION, tostring(skip_full_body_scan)))

		-- Call multipart full scan module (parses multipart and scans each file)
		local success, message, status, data = multipart_full_scan.scan_multipart_files(
			plugin,
			body_file,
			checksum,
			detections,
			enabled_scanners
		)

		-- If per-file scanning found malware, block immediately
		if not success then
			-- Cleanup body file before blocking
			local cleanup_enabled = plugin.variables["MALWARE_SCAN_CLEANUP_FILES"]
			if cleanup_enabled ~= "no" and file_ops then
				local cleanup_ok, cleanup_err = file_ops.file_cleanup(plugin, body_file)
				if not cleanup_ok then
					plugin.logger:log(ERR, "failed to cleanup temp file after multipart scan: " .. cleanup_err)
				end
			end
			return plugin:ret(true, message, status, nil, data)
		end
	elseif (resume_on_hit or skip_full_body_scan) and not multipart_full_scan_load_ok then
		plugin.logger:log(ERR, "[MULTIPART_FULL_SCAN] Resume mode or multipart extraction enabled but multipart_full_scan module failed to load")
	end

	-- Build success message based on what was scanned
	local scan_message
	local active_scanners = {}
	if clamav_actually_scanned then table.insert(active_scanners, "ClamAV") end
	if scanner_state.virustotal then table.insert(active_scanners, "VirusTotal") end
	if scanner_state.sentinelone then table.insert(active_scanners, "SentinelOne") end
	if scanner_state.malwarebazaar then table.insert(active_scanners, "MalwareBazaar") end

	if #active_scanners > 0 then
		local scanners_str = table.concat(active_scanners, " + ")
		scan_message = "file scanned by " .. scanners_str .. ", no malware detected"
		if clamav_skipped_reason then
			scan_message = scan_message .. " (ClamAV skipped: " .. clamav_skipped_reason .. ")"
		end
		plugin.logger:log(ERR, "SCAN COMPLETE - file is clean (" .. scanners_str .. ")")
		if clamav_skipped_reason then
			plugin.logger:log(ERR, "Note: ClamAV scan was skipped - " .. clamav_skipped_reason)
		end
	else
		scan_message = "no scanning performed"
	end

	-- Cleanup body file if resume mode was enabled (file preserved for multipart scanning)
	if resume_on_hit then
		local cleanup_enabled = plugin.variables["MALWARE_SCAN_CLEANUP_FILES"]
		if cleanup_enabled ~= "no" and file_ops then
			local cleanup_ok, cleanup_err = file_ops.file_cleanup(plugin, body_file)
			if not cleanup_ok then
				plugin.logger:log(ERR, "failed to cleanup temp file after successful scan: " .. cleanup_err)
			else
				local VERSION = orchestrator.VERSION
				plugin:log_debug("[v" .. VERSION .. "] [RESUME_MODE] Cleaned up body file after multipart scanning")
			end
		end
	end

	return plugin:ret(true, scan_message)
end

-- Return module
return orchestrator
