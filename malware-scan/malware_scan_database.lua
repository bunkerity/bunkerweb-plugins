-- BunkerWeb Malware Scan - Database Module
-- Centralized Redis/database operations with circuit breaker and connection management
-- Provides high-level API for all Redis operations across the plugin

local logger = require("malware_scan_logger")

local ngx = ngx
local tonumber = tonumber
local tostring = tostring

-- Module table
local database = {}

-- Module version
database.VERSION = "0.8.0"

-- ============================================================================
-- TYPE ALIASES (for documentation and LuaLS type checking)
-- ============================================================================

---@alias Redis string Redis key name
---@alias Value string Value to store in Redis
---@alias Time-to-live number TTL in seconds
---@alias Hash string Redis hash key
---@alias Field string Redis hash field name
---@alias Scan string Scan cursor position
---@alias Pipeline table Redis pipeline object

-- ============================================================================
-- CONNECTION MANAGEMENT
-- ============================================================================

-- Initialize Redis connection for malware hash lookups.
-- Sets up plugin.redisdb from the clusterstore's Redis client.
-- This is required for MalwareBazaar hash lookups during request handling.
--
--- @param plugin Plugin instance with clusterstore
--- @return boolean success True if connection successful
--- @return string|nil error Error message if failed
function database.connect(plugin)
	-- Check if Redis is enabled
	if not plugin.use_redis then
		logger.log_error( "Redis not enabled (USE_REDIS != yes)")
		return false, "Redis not enabled"
	end

	-- Check if clusterstore is available
	if not plugin.clusterstore then
		logger.log_error( "Clusterstore not available")
		return false, "Clusterstore not available"
	end

	-- Connect to Redis via clusterstore
	local ok, err = plugin.clusterstore:connect()
	if not ok then
		logger.log_error( "Failed to connect to Redis: " .. (err or "unknown error"))
		return false, "Failed to connect to Redis: " .. (err or "unknown error")
	end

	-- Assign redis_client to plugin.redisdb for malware hash lookups
	plugin.redisdb = plugin.clusterstore.redis_client

	if not plugin.redisdb then
		logger.log_error( "Redis client not available after connection")
		return false, "Redis client not available"
	end

	logger.log_error( "Redis initialized successfully for malware hash lookups")
	return true, nil
end

-- Check if Redis is enabled and available.
-- Returns true if both USE_REDIS and MALWARE_SCAN_USE_SHARED_DATABASE are enabled.
--
--- @param plugin Plugin instance
--- @return boolean enabled True if both shared database and Redis are enabled
function database.is_enabled(plugin)
	local use_shared = plugin.variables["MALWARE_SCAN_USE_SHARED_DATABASE"] == "yes"
	local use_redis = plugin.variables["USE_REDIS"] == "yes"
	return use_shared and use_redis
end

-- Check if Redis client is available.
-- Returns true if plugin.redisdb exists.
--
--- @param plugin Plugin instance
--- @return boolean available True if Redis client is available
function database.is_available(plugin)
	return plugin.redisdb ~= nil
end

-- ============================================================================
-- CIRCUIT BREAKER FUNCTIONS
-- Protects against Redis failures with exponential backoff
-- ============================================================================

-- Get Redis circuit breaker state from local cache.
-- Returns failure_count and last_failure_time.
--
--- @param plugin Plugin instance
--- @return number failure_count Number of consecutive failures
--- @return number last_failure_time Unix timestamp of last failure
function database.breaker_get(plugin)
	local cb_key = "plugin_malware_scan_redis_circuit_breaker"
	local ok, data = plugin.cachestore:get(cb_key)
	if not ok or not data then
		return 0, 0  -- No failures recorded
	end

	-- Data format: "failure_count:last_failure_time"
	local count, time = data:match("^(%d+):(%d+)$")
	if not count or not time then
		return 0, 0
	end

	return tonumber(count) or 0, tonumber(time) or 0
end

-- Update Redis circuit breaker state in local cache.
-- Sets failure_count and last_failure_time.
--
--- @param plugin Plugin instance
--- @param failure_count number Number of consecutive failures
--- @param last_failure_time number Unix timestamp of last failure
function database.breaker_set(plugin, failure_count, last_failure_time)
	-- Validate numeric inputs to prevent corruption (Medium severity issue #11)
	failure_count = tonumber(failure_count) or 0
	last_failure_time = tonumber(last_failure_time) or 0

	-- Bounds checking: prevent negative values and excessive counts
	if failure_count < 0 or failure_count > 1000000 then
		logger.log_warn("[DATABASE] Invalid failure_count (" .. tostring(failure_count) .. "), resetting to 0")
		failure_count = 0
	end

	if last_failure_time < 0 then
		logger.log_warn("[DATABASE] Invalid last_failure_time (" .. tostring(last_failure_time) .. "), resetting to 0")
		last_failure_time = 0
	end

	local cb_key = "plugin_malware_scan_redis_circuit_breaker"
	local data = tostring(failure_count) .. ":" .. tostring(last_failure_time)
	-- Store for 60 seconds (longer than max backoff of 8s default)
	plugin.cachestore:set(cb_key, data, 60)
end

-- Check if Redis should be skipped based on circuit breaker state.
-- Returns true if Redis should be skipped, false otherwise.
-- Implements exponential backoff: 1ms, 2ms, 4ms, 8ms, 16ms, 32ms, 64ms, 128ms, 256ms, 512ms, 1s, 2s, 4s, up to max (default 8s).
--
--- @param plugin Plugin instance
--- @return boolean should_skip True if Redis should be skipped
function database.should_skip(plugin)
	local failure_count, last_failure_time = database.breaker_get(plugin)

	if failure_count == 0 then
		return false  -- No failures, try Redis
	end

	local now = ngx.time()
	local max_backoff = tonumber(plugin.variables["MALWARE_SCAN_REDIS_CIRCUIT_BREAKER_MAX_BACKOFF"]) or 8
	-- Cap failure_count to prevent integer overflow in exponential backoff (Medium severity issue #12)
	local capped_failure_count = math.min(failure_count, 20)
	-- Start at 1ms (0.001s) and double each time: 0.001 * 2^failure_count
	local backoff_seconds = math.min(0.001 * (2 ^ capped_failure_count), max_backoff)
	local time_since_failure = now - last_failure_time

	if time_since_failure >= backoff_seconds then
		return false  -- Backoff period expired, try Redis again
	end

	-- Still in backoff period
	plugin:log_debug(string.format(
		"[DATABASE] Skipping Redis (circuit breaker): %d consecutive failures, backoff %.3fs, %.3fs remaining",
		failure_count, backoff_seconds, backoff_seconds - time_since_failure
	))
	return true
end

-- Record a successful Redis operation (resets circuit breaker).
--
--- @param plugin Plugin instance
function database.success_record(plugin)
	database.breaker_set(plugin, 0, 0)
	plugin:log_debug("[v" .. database.VERSION .. "] [DATABASE] Redis operation successful, circuit breaker reset")
end

-- Record a failed Redis operation (increments circuit breaker).
--
--- @param plugin Plugin instance
function database.failure_record(plugin)
	local failure_count, last_failure_time = database.breaker_get(plugin)
	local now = ngx.time()
	failure_count = failure_count + 1

	database.breaker_set(plugin, failure_count, now)

	local max_backoff = tonumber(plugin.variables["MALWARE_SCAN_REDIS_CIRCUIT_BREAKER_MAX_BACKOFF"]) or 8
	local backoff_seconds = math.min(0.001 * (2 ^ failure_count), max_backoff)

	-- Implement log throttling to prevent log flooding (Low severity issue #22)
	-- Only log if: first failure, every 5th failure, or 60+ seconds since last log
	local should_log = (failure_count == 1) or
	                   (failure_count % 5 == 0) or
	                   (last_failure_time > 0 and (now - last_failure_time) >= 60)

	if should_log then
		-- Format backoff time appropriately (ms for small values, s for large)
		local backoff_str
		if backoff_seconds < 1 then
			backoff_str = string.format("%.0fms", backoff_seconds * 1000)
		else
			backoff_str = string.format("%.1fs", backoff_seconds)
		end

		logger.log_error( string.format(
			"[DATABASE] Redis failure #%d recorded, backing off for %s",
			failure_count, backoff_str
		))
	end
end

-- ============================================================================
-- KEY-VALUE OPERATIONS (via plugin.datastore with circuit breaker)
-- ============================================================================

-- Get value from Redis with circuit breaker protection.
-- Uses plugin.datastore for key-value operations.
--
--- @param plugin Plugin instance
--- @param key string Redis key
--- @return boolean success True if operation successful
--- @return any value Value from Redis (nil if not found or error)
--- @return string|nil error Error message if failed
function database.get(plugin, key)
	if not database.is_enabled(plugin) then
		return false, nil, "shared cache disabled"
	end

	-- Check circuit breaker before attempting Redis
	if database.should_skip(plugin) then
		return false, nil, "circuit breaker open"
	end

	local ok, data = plugin.datastore:get(key)
	if not ok then
		database.failure_record(plugin)
		return false, nil, "redis get failed"
	end

	database.success_record(plugin)
	return true, data, nil
end

-- Set value in Redis with circuit breaker protection.
-- Uses plugin.datastore for key-value operations.
--
--- @param plugin Plugin instance
--- @param key string Redis key
--- @param value string Value to store
--- @param ttl number|nil Time-to-live in seconds (optional)
--- @return boolean success True if operation successful
--- @return string|nil error Error message if failed
function database.set(plugin, key, value, ttl)
	if not database.is_enabled(plugin) then
		return true  -- Not an error, just disabled
	end

	-- Skip if circuit breaker is open
	if database.should_skip(plugin) then
		return true  -- Not a fatal error
	end

	local ok, err = plugin.datastore:set(key, value, ttl)
	if not ok then
		database.failure_record(plugin)
		return false, err
	end

	database.success_record(plugin)
	return true, nil
end

-- Delete key from Redis with circuit breaker protection.
-- Uses plugin.datastore for key-value operations.
-- Note: This uses the datastore's delete method which may use DEL internally.
--
--- @param plugin Plugin instance
--- @param key string Redis key
--- @return boolean success True if operation successful
--- @return string|nil error Error message if failed
function database.delete(plugin, key)
	if not database.is_enabled(plugin) then
		return true  -- Not an error, just disabled
	end

	-- Skip if circuit breaker is open
	if database.should_skip(plugin) then
		return true  -- Not a fatal error
	end

	local ok, err = plugin.datastore:delete(key)
	if not ok then
		database.failure_record(plugin)
		return false, err
	end

	database.success_record(plugin)
	return true, nil
end

-- ============================================================================
-- HASH OPERATIONS (via plugin.redisdb - direct Redis client access)
-- ============================================================================

-- Get hash field value from Redis.
-- Direct access to Redis client for hash operations with auto-reconnect.
-- Always gets a fresh connection from the pool to avoid stale connection issues.
--
--- @param plugin Plugin instance
--- @param key string Redis hash key
--- @param field string Hash field name
--- @return any value Value from hash field (nil if not found)
function database.hget(plugin, key, field)
	-- Always get a fresh connection from the pool (handles keepalive automatically)
	local conn_ok, conn_err = plugin.clusterstore:connect()
	if not conn_ok then
		logger.log_error("[DATABASE] Failed to get Redis connection for hget: " .. (conn_err or "unknown"))
		return nil
	end

	-- Update redis client reference (may be a different connection from the pool)
	plugin.redisdb = plugin.clusterstore.redis_client

	-- Perform operation
	local result = plugin.redisdb:hget(key, field)

	return result
end

-- Set hash field value in Redis.
-- Direct access to Redis client for hash operations with fresh connection.
--
--- @param plugin Plugin instance
--- @param key string Redis hash key
--- @param field string Hash field name
--- @param value string Field value
--- @return boolean success True if operation successful
function database.hset(plugin, key, field, value)
	-- Always get a fresh connection from the pool
	local conn_ok, conn_err = plugin.clusterstore:connect()
	if not conn_ok then
		logger.log_error("[DATABASE] Failed to get Redis connection for hset: " .. (conn_err or "unknown"))
		return false
	end

	plugin.redisdb = plugin.clusterstore.redis_client
	return plugin.redisdb:hset(key, field, value)
end

-- Check if hash field exists in Redis.
-- Direct access to Redis client for hash operations with fresh connection.
--
--- @param plugin Plugin instance
--- @param key string Redis hash key
--- @param field string Hash field name
--- @return number exists 1 if exists, 0 if not
function database.hexists(plugin, key, field)
	-- Always get a fresh connection from the pool
	local conn_ok, conn_err = plugin.clusterstore:connect()
	if not conn_ok then
		logger.log_error("[DATABASE] Failed to get Redis connection for hexists: " .. (conn_err or "unknown"))
		return 0
	end

	plugin.redisdb = plugin.clusterstore.redis_client
	return plugin.redisdb:hexists(key, field) or 0
end

-- Get hash length (number of fields) from Redis.
-- Direct access to Redis client for hash operations with fresh connection.
--
--- @param plugin Plugin instance
--- @param key string Redis hash key
--- @return number count Number of fields in hash
function database.hlen(plugin, key)
	-- Always get a fresh connection from the pool
	local conn_ok, conn_err = plugin.clusterstore:connect()
	if not conn_ok then
		logger.log_error("[DATABASE] Failed to get Redis connection for hlen: " .. (conn_err or "unknown"))
		return 0
	end

	plugin.redisdb = plugin.clusterstore.redis_client
	return plugin.redisdb:hlen(key) or 0
end

-- Scan hash fields from Redis.
-- Direct access to Redis client for hash operations with fresh connection.
--
--- @param plugin Plugin instance
--- @param key string Redis hash key
--- @param cursor number Scan cursor (0 to start)
--- @return table|nil result Scan result {cursor, data} or nil on error
function database.hscan(plugin, key, cursor)
	-- Always get a fresh connection from the pool
	local conn_ok, conn_err = plugin.clusterstore:connect()
	if not conn_ok then
		logger.log_error("[DATABASE] Failed to get Redis connection for hscan: " .. (conn_err or "unknown"))
		return nil
	end

	plugin.redisdb = plugin.clusterstore.redis_client
	return plugin.redisdb:hscan(key, cursor)
end

-- Create Redis pipeline for batch operations.
-- Direct access to Redis client for pipeline operations with fresh connection.
--
--- @param plugin Plugin instance
--- @param size Pipeline size (number of commands)
--- @return table|nil pipeline Pipeline object or nil on error
function database.pipeline(plugin, size)
	-- Always get a fresh connection from the pool
	local conn_ok, conn_err = plugin.clusterstore:connect()
	if not conn_ok then
		logger.log_error("[DATABASE] Failed to get Redis connection for pipeline: " .. (conn_err or "unknown"))
		return nil
	end

	plugin.redisdb = plugin.clusterstore.redis_client
	return plugin.redisdb:pipeline(size)
end

-- ============================================================================
-- SIMPLE KEY OPERATIONS (via plugin.redisdb)
-- ============================================================================

-- Check if key exists in Redis.
-- Direct access to Redis client with fresh connection.
--
--- @param plugin Plugin instance
--- @param key Redis key
--- @return number exists 1 if exists, 0 if not
function database.exists(plugin, key)
	-- Always get a fresh connection from the pool
	local conn_ok, conn_err = plugin.clusterstore:connect()
	if not conn_ok then
		logger.log_error("[DATABASE] Failed to get Redis connection for exists: " .. (conn_err or "unknown"))
		return 0
	end

	plugin.redisdb = plugin.clusterstore.redis_client
	return plugin.redisdb:exists(key) or 0
end

-- Set key with expiry in Redis.
-- Direct access to Redis client with fresh connection.
--
--- @param plugin Plugin instance
--- @param key string Redis key
--- @param ttl number Time-to-live in seconds
--- @param value string Value to store
--- @return boolean success True if operation successful
function database.setex(plugin, key, ttl, value)
	-- Always get a fresh connection from the pool
	local conn_ok, conn_err = plugin.clusterstore:connect()
	if not conn_ok then
		logger.log_error("[DATABASE] Failed to get Redis connection for setex: " .. (conn_err or "unknown"))
		return false
	end

	plugin.redisdb = plugin.clusterstore.redis_client
	return plugin.redisdb:setex(key, ttl, value) or true
end

-- Delete key from Redis using UNLINK (non-blocking).
-- UNLINK performs asynchronous deletion in the background, avoiding blocking.
-- Direct access to Redis client with fresh connection.
--
--- @param plugin Plugin instance
--- @param key Redis key (can be single key or array of keys)
--- @return number count Number of keys unlinked
function database.unlink(plugin, key)
	-- Always get a fresh connection from the pool
	local conn_ok, conn_err = plugin.clusterstore:connect()
	if not conn_ok then
		logger.log_error("[DATABASE] Failed to get Redis connection for unlink: " .. (conn_err or "unknown"))
		return 0
	end

	plugin.redisdb = plugin.clusterstore.redis_client
	return plugin.redisdb:unlink(key) or 0
end

-- Get key value from Redis (simple operation).
-- Direct access to Redis client with fresh connection.
--
--- @param plugin Plugin instance
--- @param key Redis key
--- @return any value Value from Redis (nil if not found)
function database.redis_get(plugin, key)
	-- Always get a fresh connection from the pool
	local conn_ok, conn_err = plugin.clusterstore:connect()
	if not conn_ok then
		logger.log_error("[DATABASE] Failed to get Redis connection for get: " .. (conn_err or "unknown"))
		return nil
	end

	plugin.redisdb = plugin.clusterstore.redis_client
	return plugin.redisdb:get(key)
end

-- Return module
return database
