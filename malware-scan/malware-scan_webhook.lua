-- Webhook Notification Module
-- Handles sending malware detection alerts to Microsoft Teams and Discord via webhooks
-- Supports Teams Incoming Webhooks, Power Automate workflows, and Discord webhooks

local _M = {}

local cjson = require("cjson.safe")
local http = require("resty.http")

-- Parse webhook URL into components for manual HTTP connection
-- This avoids issues with resty.http's request_uri() parsing complex URLs
-- @param url string The webhook URL to parse
-- @return table URL components (scheme, host, port, path, ssl) or nil, error
local function parse_url(url)
	local scheme, host, port, path = url:match("^(https?)://([^/:]+):?(%d*)(.*)$")

	if not scheme or not host then
		return nil, "invalid URL format"
	end

	-- Set default ports
	if port == "" then
		port = (scheme == "https") and "443" or "80"
	end

	-- Ensure path starts with /
	if path == "" then
		path = "/"
	end

	return {
		scheme = scheme,
		host = host,
		port = tonumber(port),
		path = path,
		ssl = (scheme == "https")
	}
end

-- Clean webhook URL by removing quotes, brackets, and whitespace
-- @param webhook_url string The raw webhook URL
-- @param plugin table Plugin instance for logging
-- @return string Cleaned webhook URL
local function clean_webhook_url(webhook_url, plugin)
	if not webhook_url then
		return nil
	end

	-- Strip leading/trailing whitespace
	webhook_url = webhook_url:gsub("^%s*(.-)%s*$", "%1")

	if plugin:is_debug() then
		plugin:log_debug("Before cleaning: " .. webhook_url)
	end

	-- Remove surrounding quotes (single or double)
	webhook_url = webhook_url:gsub("^['\"](.+)['\"]$", "%1")

	-- Remove surrounding brackets/angle brackets
	webhook_url = webhook_url:gsub("^[%[<](.+)[%]>]$", "%1")

	if plugin:is_debug() then
		plugin:log_debug("After quote/bracket stripping: " .. webhook_url)
	end

	return webhook_url
end

-- Build JSON payload for webhook notification
-- Detects webhook type (Discord, Power Automate, or Teams Incoming Webhook) and formats accordingly
-- @param webhook_url string The webhook URL (used for type detection)
-- @param checksum string SHA256 hash of the malicious file
-- @param detections table Scanner names and detection details
-- @param client_ip string Client IP address
-- @param server_name string Destination domain
-- @param request_uri string Request URI
-- @return string JSON payload
local function build_json_payload(webhook_url, checksum, detections, client_ip, server_name, request_uri)
	-- Build detection summary
	local detection_list = {}
	local scanners_detected = {}

	for scanner, detection in pairs(detections or {}) do
		table.insert(scanners_detected, scanner)
		table.insert(detection_list, "**" .. scanner .. "**: " .. detection)
	end

	local hit_rate = table.concat(scanners_detected, ", ")
	if hit_rate == "" then
		hit_rate = "unknown"
	end

	-- Detect webhook type (Discord, Power Automate, or Teams Incoming Webhook)
	local is_discord = webhook_url:find("discord%.com/api/webhooks") or webhook_url:find("discordapp%.com/api/webhooks")
	local is_power_automate = webhook_url:find("powerplatform%.com") or webhook_url:find("powerautomate")

	local card

	if is_discord then
		-- Discord expects embed format
		local fields = {
			{
				name = "Client IP",
				value = client_ip,
				inline = true
			},
			{
				name = "Destination Domain",
				value = server_name,
				inline = true
			},
			{
				name = "Request URI",
				value = request_uri,
				inline = false
			},
			{
				name = "SHA256 Checksum",
				value = checksum or "not available",
				inline = false
			},
			{
				name = "Detected By",
				value = hit_rate,
				inline = false
			}
		}

		-- Add detection details as separate fields
		if #detection_list > 0 then
			for scanner, detection in pairs(detections or {}) do
				table.insert(fields, {
					name = scanner,
					value = detection,
					inline = false
				})
			end
		end

		card = {
			embeds = {
				{
					title = "ðŸ›¡ï¸ MALWARE DETECTED",
					description = "BunkerWeb Malware Scanner Alert",
					color = 16711680,  -- Red color in decimal
					fields = fields,
					timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
				}
			}
		}
	elseif is_power_automate then
		-- Power Automate expects simpler JSON structure
		card = {
			title = "MALWARE DETECTED",
			summary = "BunkerWeb Malware Scanner Alert",
			client_ip = client_ip,
			destination_domain = server_name,
			request_uri = request_uri,
			sha256_checksum = checksum or "not available",
			detected_by = hit_rate,
			detection_details = table.concat(detection_list, "\n\n")
		}
	else
		-- Teams Incoming Webhook expects MessageCard format
		card = {
			["@type"] = "MessageCard",
			["@context"] = "https://schema.org/extensions",
			themeColor = "FF0000",  -- Red color for alerts
			summary = "Malware Detected",
			sections = {
				{
					activityTitle = "ðŸ›¡ï¸ MALWARE DETECTED",
					activitySubtitle = "BunkerWeb Malware Scanner Alert",
					facts = {
						{
							name = "Client IP",
							value = client_ip
						},
						{
							name = "Destination Domain",
							value = server_name
						},
						{
							name = "Request URI",
							value = request_uri
						},
						{
							name = "SHA256 Checksum",
							value = checksum or "not available"
						},
						{
							name = "Detected By",
							value = hit_rate
						}
					},
					markdown = true
				}
			}
		}

		-- Add detection details if available
		if #detection_list > 0 then
			table.insert(card.sections, {
				title = "Detection Details",
				text = table.concat(detection_list, "\n\n")
			})
		end
	end

	return cjson.encode(card)
end

-- Send HTTP POST request to webhook URL with retry logic
-- Uses manual HTTP connection to handle complex Power Automate URLs
-- @param url_parts table Parsed URL components
-- @param json_body string JSON payload
-- @param plugin table Plugin instance for logging
-- @param webhook_type string Webhook type for logging (e.g., "Teams", "Discord")
-- @return boolean Success status
local function send_webhook_request(url_parts, json_body, plugin, webhook_type)
	-- Retry configuration
	local max_retries = 3
	local base_delay = 1  -- 1 second base delay
	local max_delay = 20  -- 20 seconds max delay

	-- Transient error status codes that should be retried
	local transient_errors = {
		[412] = true,  -- Precondition Failed
		[429] = true,  -- Too Many Requests (rate limit)
		[502] = true,  -- Bad Gateway
		[504] = true,  -- Gateway Timeout
	}

	-- Retry loop with exponential backoff
	for attempt = 1, max_retries do
		local httpc = http.new()
		httpc:set_timeout(5000)  -- 5 second timeout

		-- Connect to host
		local ok, err = httpc:connect(url_parts.host, url_parts.port)
		if not ok then
			plugin.logger:log(ngx.ERR, webhook_type .. " webhook connection failed (attempt " .. attempt .. "): " .. tostring(err))

			if attempt < max_retries then
				local delay = math.min(math.pow(2, attempt - 1) * base_delay, max_delay)
				local jitter = delay * 0.2 * (math.random() * 2 - 1)
				delay = delay + jitter
				plugin.logger:log(ngx.NOTICE, webhook_type .. " webhook backing off for " .. string.format("%.2f", delay) .. " seconds")
				ngx.sleep(delay)
			end

			goto continue
		end

		-- Perform SSL handshake if HTTPS
		if url_parts.ssl then
			local session, err = httpc:ssl_handshake(nil, url_parts.host, false)
			if not session then
				plugin.logger:log(ngx.ERR, webhook_type .. " webhook SSL handshake failed (attempt " .. attempt .. "): " .. tostring(err))
				httpc:close()

				if attempt < max_retries then
					local delay = math.min(math.pow(2, attempt - 1) * base_delay, max_delay)
					local jitter = delay * 0.2 * (math.random() * 2 - 1)
					delay = delay + jitter
					plugin.logger:log(ngx.NOTICE, webhook_type .. " webhook backing off for " .. string.format("%.2f", delay) .. " seconds")
					ngx.sleep(delay)
				end

				goto continue
			end
		end

		-- Send request
		local res, err = httpc:request({
			method = "POST",
			path = url_parts.path,
			headers = {
				["Host"] = url_parts.host,
				["Content-Type"] = "application/json",
				["Content-Length"] = tostring(#json_body)
			},
			body = json_body
		})

		if not res then
			plugin.logger:log(ngx.ERR, webhook_type .. " webhook request failed (attempt " .. attempt .. "): " .. tostring(err))
			httpc:close()

			if attempt < max_retries then
				local delay = math.min(math.pow(2, attempt - 1) * base_delay, max_delay)
				local jitter = delay * 0.2 * (math.random() * 2 - 1)
				delay = delay + jitter
				plugin.logger:log(ngx.NOTICE, webhook_type .. " webhook backing off for " .. string.format("%.2f", delay) .. " seconds")
				ngx.sleep(delay)
			end

			goto continue
		else
			-- Read response body
			local body = res:read_body()

			-- Close connection
			httpc:close()
		end

		-- Success case
		if res and res.status >= 200 and res.status < 300 then
			if attempt > 1 then
				plugin.logger:log(ngx.NOTICE, webhook_type .. " webhook notification sent successfully after " .. attempt .. " attempts")
			else
				plugin.logger:log(ngx.NOTICE, webhook_type .. " webhook notification sent successfully")
			end
			return true
		end

		-- Determine if error is transient and should be retried
		local should_retry = false
		local error_msg = ""

		if transient_errors[res.status] then
			-- Transient HTTP error
			should_retry = (attempt < max_retries)
			error_msg = "HTTP " .. res.status .. ": " .. (res.body or "no body")
		else
			-- Non-retryable error (4xx other than 412/429, or 5xx other than 502/504)
			should_retry = false
			error_msg = "HTTP " .. res.status .. ": " .. (res.body or "no body")
		end

		-- Log the error
		if should_retry then
			plugin.logger:log(ngx.NOTICE, webhook_type .. " webhook attempt " .. attempt .. "/" .. max_retries .. " failed (" .. error_msg .. "), retrying...")
		else
			plugin.logger:log(ngx.ERR, webhook_type .. " webhook failed: " .. error_msg)
			return false
		end

		-- Calculate exponential backoff delay with jitter (only if retrying)
		if should_retry and attempt < max_retries then
			-- Exponential backoff: 2^(attempt-1) * base_delay
			local delay = math.min(math.pow(2, attempt - 1) * base_delay, max_delay)

			-- Add random jitter (Â±20%)
			local jitter = delay * 0.2 * (math.random() * 2 - 1)
			delay = delay + jitter

			plugin.logger:log(ngx.NOTICE, webhook_type .. " webhook backing off for " .. string.format("%.2f", delay) .. " seconds")
			ngx.sleep(delay)
		end

		::continue::
	end

	-- All retries exhausted
	plugin.logger:log(ngx.ERR, webhook_type .. " webhook failed after " .. max_retries .. " attempts")
	return false
end

-- Send notification to webhook (Teams or Discord)
-- Main entry point for the module
-- @param plugin table Plugin instance (for accessing variables, logging, cachestore, ctx)
-- @param checksum string SHA256 hash of the malicious file
-- @param detections table Scanner names as keys and detection details as values
-- @return boolean Success status
function _M.send_notification(plugin, checksum, detections)
	local teams_url = plugin.variables["MALWARE_SCAN_TEAMS_WEBHOOK_URL"]
	local discord_url = plugin.variables["MALWARE_SCAN_DISCORD_WEBHOOK_URL"]

	-- Clean webhook URLs
	if teams_url then
		teams_url = clean_webhook_url(teams_url, plugin)
	end
	if discord_url then
		discord_url = clean_webhook_url(discord_url, plugin)
	end

	-- Validate webhook URLs (skip if not configured or placeholder)
	local teams_configured = teams_url and teams_url ~= "" and teams_url ~= "your_webhook_url"
	local discord_configured = discord_url and discord_url ~= "" and discord_url ~= "your_webhook_url"

	if not teams_configured and not discord_configured then
		return true  -- Not an error, just not configured
	end

	-- Get request information (shared by both webhooks)
	local client_ip = ngx.var.remote_addr or "unknown"
	local server_name = ngx.var.server_name or ngx.var.host or "unknown"
	local request_uri = plugin.ctx.bw.uri or "unknown"

	local success = true

	-- Send Teams webhook if configured
	if teams_configured then
		-- Check rate limit with hard cap at Microsoft Teams' limit
		-- Teams Incoming Webhooks support ~200 messages per minute maximum
		local TEAMS_HARD_LIMIT = 200
		local user_rate_limit = tonumber(plugin.variables["MALWARE_SCAN_TEAMS_WEBHOOK_RATE_LIMIT"]) or 6
		local rate_limit = user_rate_limit

		-- Enforce hard cap based on Microsoft Teams limits
		-- If user sets 0 (unlimited), use Teams max (200)
		-- If user sets >200, cap at Teams max (200) and warn
		if user_rate_limit == 0 then
			rate_limit = TEAMS_HARD_LIMIT
		elseif user_rate_limit > TEAMS_HARD_LIMIT then
			rate_limit = TEAMS_HARD_LIMIT
			plugin.logger:log(ngx.WARN, "Teams webhook rate limit " .. user_rate_limit .. " exceeds Microsoft Teams maximum (" .. TEAMS_HARD_LIMIT .. "/min) - enforcing hard cap")
		end

		-- Apply rate limiting
		local cache_key = "plugin_malware_scan_teams_webhook_count"
		local ok, count = plugin.cachestore:get(cache_key)

		local send_teams = true
		if ok and count then
			count = tonumber(count) or 0
			if count >= rate_limit then
				plugin.logger:log(ngx.NOTICE, "Teams webhook rate limit exceeded (" .. count .. "/" .. rate_limit .. " per minute) - skipping notification")
				send_teams = false
			else
				-- Increment counter
				plugin.cachestore:set(cache_key, count + 1, 60)
			end
		else
			-- Initialize counter with 60 second TTL
			plugin.cachestore:set(cache_key, 1, 60)
		end

		if send_teams then
			-- Debug log the webhook URL before parsing
			if plugin:is_debug() then
				plugin:log_debug("Teams webhook URL to parse: [" .. teams_url .. "]")
			end

			-- Parse webhook URL
			local url_parts, parse_err = parse_url(teams_url)
			if not url_parts then
				plugin.logger:log(ngx.ERR, "Failed to parse Teams webhook URL: " .. parse_err)
				success = false
			else
				if plugin:is_debug() then
					plugin:log_debug("Parsed Teams webhook URL: " .. url_parts.scheme .. "://" .. url_parts.host .. ":" .. url_parts.port .. url_parts.path)
				end

				-- Build JSON payload
				local json_body = build_json_payload(teams_url, checksum, detections, client_ip, server_name, request_uri)

				if not json_body then
					plugin.logger:log(ngx.ERR, "failed to encode Teams webhook JSON")
					success = false
				else
					-- Send webhook request with retry logic
					if not send_webhook_request(url_parts, json_body, plugin, "Teams") then
						success = false
					end
				end
			end
		end
	end

	-- Send Discord webhook if configured
	if discord_configured then
		-- Check rate limit with hard cap at Discord's limit
		-- Discord webhooks support 30 messages per 60 seconds maximum
		local DISCORD_HARD_LIMIT = 30
		local user_rate_limit = tonumber(plugin.variables["MALWARE_SCAN_DISCORD_WEBHOOK_RATE_LIMIT"]) or 5
		local rate_limit = user_rate_limit

		-- Enforce hard cap based on Discord limits
		-- If user sets 0 (unlimited), use Discord max (30)
		-- If user sets >30, cap at Discord max (30) and warn
		if user_rate_limit == 0 then
			rate_limit = DISCORD_HARD_LIMIT
		elseif user_rate_limit > DISCORD_HARD_LIMIT then
			rate_limit = DISCORD_HARD_LIMIT
			plugin.logger:log(ngx.WARN, "Discord webhook rate limit " .. user_rate_limit .. " exceeds Discord maximum (" .. DISCORD_HARD_LIMIT .. " per 60s) - enforcing hard cap")
		end

		-- Apply rate limiting
		local cache_key = "plugin_malware_scan_discord_webhook_count"
		local ok, count = plugin.cachestore:get(cache_key)

		local send_discord = true
		if ok and count then
			count = tonumber(count) or 0
			if count >= rate_limit then
				plugin.logger:log(ngx.NOTICE, "Discord webhook rate limit exceeded (" .. count .. "/" .. rate_limit .. " per 60s) - skipping notification")
				send_discord = false
			else
				-- Increment counter
				plugin.cachestore:set(cache_key, count + 1, 60)
			end
		else
			-- Initialize counter with 60 second TTL
			plugin.cachestore:set(cache_key, 1, 60)
		end

		if send_discord then
			-- Debug log the webhook URL before parsing
			if plugin:is_debug() then
				plugin:log_debug("Discord webhook URL to parse: [" .. discord_url .. "]")
			end

			-- Parse webhook URL
			local url_parts, parse_err = parse_url(discord_url)
			if not url_parts then
				plugin.logger:log(ngx.ERR, "Failed to parse Discord webhook URL: " .. parse_err)
				success = false
			else
				if plugin:is_debug() then
					plugin:log_debug("Parsed Discord webhook URL: " .. url_parts.scheme .. "://" .. url_parts.host .. ":" .. url_parts.port .. url_parts.path)
				end

				-- Build JSON payload
				local json_body = build_json_payload(discord_url, checksum, detections, client_ip, server_name, request_uri)

				if not json_body then
					plugin.logger:log(ngx.ERR, "failed to encode Discord webhook JSON")
					success = false
				else
					-- Send webhook request with retry logic
					if not send_webhook_request(url_parts, json_body, plugin, "Discord") then
						success = false
					end
				end
			end
		end
	end

	return success
end

return _M
