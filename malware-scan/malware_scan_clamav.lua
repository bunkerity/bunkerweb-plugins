-- BunkerWeb Malware Scan - ClamAV Scanner Module
-- Handles all ClamAV-specific scanning operations via INSTREAM protocol

local ngx = ngx
local ERR = ngx.ERR
local NOTICE = ngx.NOTICE
local WARN = ngx.WARN
local socket = ngx.socket
local tonumber = tonumber

-- Module table
local clamav = {}

-- Cache module reference (will be set when module is loaded)
local cache = nil

-- Set cache module reference (called during initialization)
function clamav.set_cache_module(cache_module)
	cache = cache_module
end

-- ============================================================================
-- SOCKET CONNECTION
-- ============================================================================

-- Create TCP socket connection to ClamAV.
-- Returns socket object or false and error message.
function clamav.socket(plugin)
	local tcp_socket = socket.tcp()
	tcp_socket:settimeout(tonumber(plugin.variables["MALWARE_SCAN_CLAMAV_TIMEOUT"]))
	local ok, err = tcp_socket:connect(
		plugin.variables["MALWARE_SCAN_CLAMAV_HOST"],
		tonumber(plugin.variables["MALWARE_SCAN_CLAMAV_PORT"])
	)
	if not ok then
		return false, err
	end
	return tcp_socket
end

-- Send command to ClamAV daemon.
-- Used for PING and other simple commands.
-- Returns success boolean and response data or error.
function clamav.command(plugin, cmd)
	local clamav_socket, err = clamav.socket(plugin)
	if not clamav_socket then
		return false, err
	end

	local bytes
	bytes, err = clamav_socket:send("n" .. cmd .. "\n")
	if not bytes then
		clamav_socket:close()
		return false, err
	end

	local data
	data, err = clamav_socket:receive("*l")
	if not data then
		clamav_socket:close()
		return false, err
	end

	clamav_socket:close()
	return true, data
end

-- ============================================================================
-- FILE SCANNING
-- ============================================================================

-- Scan a file using ClamAV (always uses INSTREAM method).
-- Takes file path, returns success boolean and detection result or error.
function clamav.scan_file(plugin, file_path)
	-- Always use INSTREAM method (bypasses file permissions)
	return clamav.scan_file_instream(plugin, file_path)
end

-- Scan a file using ClamAV's INSTREAM command (stream content over socket).
-- This bypasses file permission issues by reading the file and sending it to ClamAV.
-- Takes file path, returns success boolean and detection result or error.
function clamav.scan_file_instream(plugin, file_path)
	plugin:log_debug("=== INSTREAM: scan_file_instream() called for: " .. file_path .. " ===")

	-- Check cache if cache module is available
	if cache then
		local ok, cached = cache.is_in_cache(plugin, file_path)
		if ok and cached then
			plugin:log_debug("file found in cache: " .. cached)
			return true, cached
		end
	end

	plugin.logger:log(ERR, "scanning file via INSTREAM: " .. file_path)
	plugin:log_debug("INSTREAM: Opening file for reading")

	-- Open file for reading
	local file, err = io.open(file_path, "rb")
	if not file then
		return false, "failed to open file: " .. (err or "unknown")
	end

	plugin:log_debug("INSTREAM: File opened successfully, creating socket")

	local clamav_socket
	clamav_socket, err = clamav.socket(plugin)
	if not clamav_socket then
		plugin.logger:log(ERR, "INSTREAM socket creation failed: " .. tostring(err))
		file:close()
		return false, "socket failed: " .. err
	end

	plugin:log_debug("INSTREAM: Socket created, sending INSTREAM command")

	-- Send INSTREAM command
	local bytes
	bytes, err = clamav_socket:send("zINSTREAM\0")
	if not bytes then
		plugin.logger:log(ERR, "INSTREAM command send failed: " .. tostring(err))
		clamav_socket:close()
		file:close()
		return false, "socket:send(INSTREAM) failed: " .. err
	end

	plugin:log_debug("INSTREAM: Command sent, reading file chunks")

	-- Send file in chunks with length prefix
	local chunk_size = 8192
	local total_bytes = 0
	local chunk_count = 0

	while true do
		local chunk = file:read(chunk_size)
		if not chunk then
			break
		end

		local chunk_len = #chunk
		total_bytes = total_bytes + chunk_len
		chunk_count = chunk_count + 1

		plugin:log_debug("INSTREAM: Read chunk " .. chunk_count .. ", size: " .. chunk_len)

		-- Send 4-byte length in network byte order (big-endian)
		-- Using math operations instead of bit library for compatibility
		local len_bytes = string.char(
			math.floor(chunk_len / 16777216) % 256,  -- byte 1 (most significant)
			math.floor(chunk_len / 65536) % 256,     -- byte 2
			math.floor(chunk_len / 256) % 256,       -- byte 3
			chunk_len % 256                           -- byte 4 (least significant)
		)

		bytes, err = clamav_socket:send(len_bytes .. chunk)
		if not bytes then
			plugin.logger:log(ERR, "INSTREAM failed to send chunk " .. chunk_count .. ": " .. tostring(err))
			clamav_socket:close()
			file:close()
			return false, "socket:send(chunk) failed: " .. err
		end

		plugin:log_debug("INSTREAM: Chunk " .. chunk_count .. " sent successfully")
	end

	file:close()
	plugin:log_debug("INSTREAM: All chunks sent - " .. chunk_count .. " chunks, " .. total_bytes .. " bytes total")

	-- Send 0-length to indicate end of stream
	plugin:log_debug("INSTREAM: Sending EOF marker")
	bytes, err = clamav_socket:send("\0\0\0\0")
	if not bytes then
		plugin.logger:log(ERR, "INSTREAM EOF send failed: " .. tostring(err))
		clamav_socket:close()
		return false, "socket:send(EOF) failed: " .. err
	end

	plugin:log_debug("INSTREAM: EOF sent, waiting for response")

	-- Receive response
	-- ClamAV may close connection quickly, so we need to handle partial reads
	local data, err, partial
	data, err, partial = clamav_socket:receive("*l")

	-- Log what we got for debugging
	plugin:log_debug("INSTREAM receive result - data: " .. tostring(data) .. ", err: " .. tostring(err) .. ", partial: " .. tostring(partial))

	-- If socket was closed, check if we got partial data
	if not data and err == "closed" and partial and partial ~= "" then
		-- We got the response but socket closed before newline
		-- This is normal for ClamAV closing connection after detection
		data = partial
		plugin:log_debug("INSTREAM: Using partial response before socket close")
	end

	-- If still no data, this is an error condition
	if not data or data == "" then
		clamav_socket:close()
		plugin.logger:log(ERR, "socket:receive() failed: " .. (err or "unknown") .. " - no data received")
		return false, "ClamAV connection error: " .. (err or "no response")
	end

	clamav_socket:close()

	-- Debug: Show last few bytes of the response (only in debug mode)
	if plugin:is_debug() then
		local len = #data
		local last_chars = ""
		for i = math.max(1, len - 5), len do
			local byte = string.byte(data, i)
			last_chars = last_chars .. string.format(" %d(0x%02X)", byte, byte)
		end
		plugin:log_debug("INSTREAM: Last 6 bytes of response:" .. last_chars)
	end

	-- Strip trailing whitespace/newline/null bytes from ClamAV response
	-- ClamAV INSTREAM responses end with null byte
	-- In Lua patterns, %z matches null bytes
	data = data:gsub("[%z\r\n\t ]+$", "")
	plugin:log_debug("INSTREAM: After trimming - data: [" .. data .. "], length: " .. #data)

	local detected = "clean"

	-- Parse response (format: "stream: OK" or "stream: Virus.Name FOUND")
	plugin:log_debug("INSTREAM: Parsing response: [" .. data .. "]")
	if data:match(" OK$") then
		detected = "clean"
		plugin:log_debug("INSTREAM result: CLEAN")
	elseif data:match(" FOUND$") then
		plugin:log_debug("INSTREAM: FOUND pattern matched, extracting virus name")
		-- Extract virus name with non-greedy match and validate (Medium severity issue #14)
		local virus_name = data:match(": ([^%c]+) FOUND$")  -- [^%c]+ excludes control characters
		if virus_name and virus_name ~= "" and #virus_name <= 256 then
			-- Sanitize virus name to prevent log injection
			virus_name = virus_name:gsub("[\r\n\t%z]", "_")
			detected = virus_name
			plugin.logger:log(NOTICE, "INSTREAM: malware detected - " .. virus_name)
		else
			detected = "unknown_virus"
			plugin.logger:log(WARN, "INSTREAM: malware detected but virus name extraction failed or invalid")
		end
	elseif data:match("ERROR") then
		-- Check if it's a size limit error
		if data:match("INSTREAM size limit exceeded") or data:match("size limit") then
			plugin.logger:log(
				ERR,
				"ClamAV INSTREAM size limit exceeded: " .. data .. " - file too large for ClamAV, consider increasing MALWARE_SCAN_CLAMAV_MAX_SIZE"
			)
			return false, "file size exceeds ClamAV StreamMaxLength limit"
		end
		plugin.logger:log(ERR, "ClamAV INSTREAM error: " .. data)
		return false, "ClamAV error: " .. data
	else
		plugin.logger:log(WARN, "unexpected ClamAV INSTREAM response: " .. data)
		detected = "clean"
	end

	-- Cache result if cache module is available
	if cache then
		local ok, err = cache.add_to_cache(plugin, file_path, detected)
		if not ok then
			plugin.logger:log(ERR, "can't cache result: " .. err)
		end
	end

	plugin:log_debug("INSTREAM: Scan completed, returning detected = " .. tostring(detected))
	return true, detected
end

-- ============================================================================
-- CONTENT SCANNING (for testing with EICAR)
-- ============================================================================

-- Scan content directly via ClamAV's INSTREAM command.
-- Takes content as string, returns success boolean and detection result or error.
-- Used for testing ClamAV with EICAR test string.
function clamav.scan_content_instream(plugin, content)
	plugin:log_debug("=== INSTREAM: scan_content_instream() called with " .. #content .. " bytes ===")

	plugin.logger:log(ERR, "scanning content via INSTREAM: " .. #content .. " bytes")

	local clamav_socket, err = clamav.socket(plugin)
	if not clamav_socket then
		plugin.logger:log(ERR, "INSTREAM socket creation failed: " .. tostring(err))
		return false, "socket failed: " .. err
	end

	plugin:log_debug("INSTREAM: Socket created, sending INSTREAM command")

	-- Send INSTREAM command
	local bytes
	bytes, err = clamav_socket:send("zINSTREAM\0")
	if not bytes then
		plugin.logger:log(ERR, "INSTREAM command send failed: " .. tostring(err))
		clamav_socket:close()
		return false, "socket:send(INSTREAM) failed: " .. err
	end

	plugin:log_debug("INSTREAM: Command sent, sending content")

	-- Send content in chunks with length prefix
	local chunk_size = 8192
	local total_bytes = 0
	local chunk_count = 0
	local pos = 1

	while pos <= #content do
		local chunk = content:sub(pos, pos + chunk_size - 1)
		local chunk_len = #chunk
		total_bytes = total_bytes + chunk_len
		chunk_count = chunk_count + 1

		plugin:log_debug("INSTREAM: Sending chunk " .. chunk_count .. ", size: " .. chunk_len)

		-- Send 4-byte length in network byte order (big-endian)
		local len_bytes = string.char(
			math.floor(chunk_len / 16777216) % 256,
			math.floor(chunk_len / 65536) % 256,
			math.floor(chunk_len / 256) % 256,
			chunk_len % 256
		)

		bytes, err = clamav_socket:send(len_bytes .. chunk)
		if not bytes then
			plugin.logger:log(ERR, "INSTREAM failed to send chunk " .. chunk_count .. ": " .. tostring(err))
			clamav_socket:close()
			return false, "socket:send(chunk) failed: " .. err
		end

		pos = pos + chunk_size
	end

	plugin:log_debug("INSTREAM: All chunks sent - " .. chunk_count .. " chunks, " .. total_bytes .. " bytes total")

	-- Send 0-length to indicate end of stream
	plugin:log_debug("INSTREAM: Sending EOF marker")
	bytes, err = clamav_socket:send("\0\0\0\0")
	if not bytes then
		plugin.logger:log(ERR, "INSTREAM EOF send failed: " .. tostring(err))
		clamav_socket:close()
		return false, "socket:send(EOF) failed: " .. err
	end

	plugin:log_debug("INSTREAM: EOF sent, waiting for response")

	-- Receive response
	local data, err, partial
	data, err, partial = clamav_socket:receive("*l")

	plugin:log_debug("INSTREAM receive result - data: " .. tostring(data) .. ", err: " .. tostring(err) .. ", partial: " .. tostring(partial))

	-- If socket was closed, check if we got partial data
	if not data and err == "closed" and partial and partial ~= "" then
		data = partial
		plugin:log_debug("INSTREAM: Using partial response before socket close")
	end

	-- If still no data, this is an error condition
	if not data or data == "" then
		clamav_socket:close()
		plugin.logger:log(ERR, "socket:receive() failed: " .. (err or "unknown") .. " - no data received")
		return false, "ClamAV connection error: " .. (err or "no response")
	end

	clamav_socket:close()

	-- Strip trailing whitespace/newline/null bytes from ClamAV response
	data = data:gsub("[%z\r\n\t ]+$", "")
	plugin:log_debug("INSTREAM: After trimming - data: [" .. data .. "], length: " .. #data)

	local detected = "clean"

	-- Parse response (format: "stream: OK" or "stream: Virus.Name FOUND")
	plugin:log_debug("INSTREAM: Parsing response: [" .. data .. "]")
	if data:match(" OK$") then
		detected = "clean"
		plugin:log_debug("INSTREAM result: CLEAN")
	elseif data:match(" FOUND$") then
		plugin:log_debug("INSTREAM: FOUND pattern matched, extracting virus name")
		-- Extract virus name with non-greedy match and validate (Medium severity issue #14)
		local virus_name = data:match(": ([^%c]+) FOUND$")  -- [^%c]+ excludes control characters
		if virus_name and virus_name ~= "" and #virus_name <= 256 then
			-- Sanitize virus name to prevent log injection
			virus_name = virus_name:gsub("[\r\n\t%z]", "_")
			detected = virus_name
			plugin.logger:log(NOTICE, "INSTREAM: malware detected - " .. virus_name)
		else
			detected = "unknown_virus"
			plugin.logger:log(WARN, "INSTREAM: malware detected but virus name extraction failed or invalid")
		end
	elseif data:match("ERROR") then
		plugin.logger:log(ERR, "ClamAV INSTREAM error: " .. data)
		return false, "ClamAV error: " .. data
	else
		plugin.logger:log(WARN, "unexpected ClamAV INSTREAM response: " .. data)
		detected = "clean"
	end

	plugin:log_debug("INSTREAM: Scan completed, returning detected = " .. tostring(detected))
	return true, detected
end

-- Return module
return clamav
