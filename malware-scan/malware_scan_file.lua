-- BunkerWeb Malware Scan - File Operations Module
-- Handles all file handling, content extraction, validation, and cleanup operations

local sha256 = require("resty.sha256")
local str = require("resty.string")
local utils = require("malware_scan_utils")
local logger = require("malware_scan_logger")

-- Load lfs with fallback if not available
local lfs = nil
local lfs_ok, lfs_err = pcall(function()
	lfs = require("lfs")
end)
if not lfs_ok then
	logger.log_warn("[FILE_OPS] Lua File System (lfs) not available: " .. tostring(lfs_err) .. " - directory operations will be limited")
end

local ngx = ngx
local to_hex = str.to_hex

-- Module table
local file_ops = {}

-- Module version
file_ops.VERSION = "0.8.0"

-- ============================================================================
-- HELPER FUNCTIONS
-- ============================================================================

--- Create directory recursively (like mkdir -p)
--- @param path string Directory path to create
--- @return boolean success True if directory created successfully
--- @return string|nil error Error message if failed
local function mkdir_recursive(path)
	if not path or path == "" then
		return false, "path is empty"
	end

	-- Check if lfs is available
	if not lfs then
		return false, "lfs module not available - cannot create directories"
	end

	-- Check if directory already exists
	local attr = lfs.attributes(path, "mode")
	if attr == "directory" then
		return true, nil
	elseif attr then
		return false, "path exists but is not a directory"
	end

	-- Split path into components
	local components = {}
	for component in path:gmatch("[^/]+") do
		table.insert(components, component)
	end

	-- Build path incrementally
	local current_path = path:sub(1, 1) == "/" and "/" or ""
	for _, component in ipairs(components) do
		current_path = current_path .. component .. "/"

		-- Check if this level exists
		local level_attr = lfs.attributes(current_path, "mode")
		if not level_attr then
			-- Create this directory level
			local ok, err = lfs.mkdir(current_path)
			if not ok then
				return false, "failed to create directory " .. current_path .. ": " .. (err or "unknown error")
			end
		elseif level_attr ~= "directory" then
			return false, "path component exists but is not a directory: " .. current_path
		end
	end

	return true, nil
end

--- Copy file from source to destination (like cp -p)
-- Preserves file modification time
--- @param src string Source file path
--- @param dst string Destination file path
--- @return boolean success True if file copied successfully
--- @return string|nil error Error message if failed
local function file_copy(src, dst)
	if not src or src == "" then
		return false, "source path is empty"
	end
	if not dst or dst == "" then
		return false, "destination path is empty"
	end

	-- Open source file
	local src_file, src_err = io.open(src, "rb")
	if not src_file then
		return false, "failed to open source file: " .. (src_err or "unknown error")
	end

	-- Read source content
	local content = src_file:read("*a")
	src_file:close()

	if not content then
		return false, "failed to read source file"
	end

	-- Open destination file
	local dst_file, dst_err = io.open(dst, "wb")
	if not dst_file then
		return false, "failed to open destination file: " .. (dst_err or "unknown error")
	end

	-- Write to destination
	local write_ok, write_err = dst_file:write(content)
	dst_file:close()

	if not write_ok then
		return false, "failed to write to destination file: " .. (write_err or "unknown error")
	end

	-- Preserve modification time using lfs.touch() (if available)
	if lfs then
		local src_mtime = lfs.attributes(src, "modification")
		if src_mtime then
			lfs.touch(dst, src_mtime)
		end
	end

	return true, nil
end

-- ============================================================================
-- FILE OPERATIONS
-- ============================================================================

-- Get file size in bytes.
-- Returns file size or nil if unable to determine.
--
-- NOTE: This function has a known TOCTOU (Time-of-Check Time-of-Use) race condition
-- where the file could be modified between this size check and subsequent use.
-- This is acceptable because:
-- 1. Files are temporary uploads in a controlled directory (/tmp/bunkerweb/malware-scan/)
-- 2. File size is used primarily for logging and validation, not security decisions
-- 3. Actual file operations use independent file handles with their own error handling
-- (Low severity issue #21 - documented as acceptable)
--- @return number|nil size File size in bytes or nil if unable to determine
function file_ops.file_get_size(plugin, file_path)
	local file, err = io.open(file_path, "rb")
	if not file then
		logger.log_error( "failed to open file for size check: " .. (err or "unknown"))
		return nil
	end

	local size = file:seek("end")
	file:close()

	-- Validate file size (check for negative, NaN, or invalid values)
	if not size then
		return nil
	end

	-- Validate size is a valid non-negative number
	size = utils.validate_file_size(size, 10 * 1024 * 1024 * 1024)  -- Max 10GB

	return size
end

-- Detect file type using the `file` command.
-- Uses the Unix `file` command to identify file type by magic numbers and content analysis.
-- Returns MIME type string or nil if unable to determine.
--
-- Example outputs:
-- - "text/plain; charset=us-ascii"
-- - "application/x-dosexec"
-- - "image/jpeg"
-- - "inode/x-empty; charset=binary"
--
--- @param plugin Plugin instance
--- @param file_path Path to file to analyze
--- @return string|nil file_type MIME type of the file or nil if unable to determine
--- @return string|nil error Error message if failed
function file_ops.file_get_type(plugin, file_path)
	if not file_path or file_path == "" then
		return nil, "invalid file path"
	end

	-- Validate file path to prevent command injection (CWE-78)
	-- Only allow alphanumeric, slash, dash, underscore, and dot
	if file_path:match("[^%w%/%-%_%.]") then
		return nil, "file path contains unsafe characters"
	end

	-- Build command with long-form flags for cross-system compatibility:
	-- --brief: no filename in output
	-- --mime-type: output MIME type instead of human-readable description
	-- --no-dereference: don't follow symlinks (security)
	-- --preserve-date: don't modify file access times
	-- -P bytes=8192: limit to 8KB scan (security, prevent DoS on large files)
	--   Note: File magic bytes are typically in first 16 bytes to a few KB.
	--   8KB is more than sufficient for all file type detection including complex PE/ELF headers.
	local cmd = string.format("/usr/bin/file --brief --mime-type --no-dereference --preserve-date -P bytes=8192 %s 2>&1", utils.shell_escape_path(file_path))

	local handle, err = io.popen(cmd)
	if not handle then
		logger.log_error( "failed to execute file command: " .. (err or "unknown"))
		return nil, "failed to execute file command"
	end

	-- Read output (should be single line)
	local output = handle:read("*l")
	handle:close()

	if not output or output == "" then
		return nil, "no output from file command"
	end

	-- Clean up output (remove trailing whitespace)
	output = output:gsub("%s+$", "")

	plugin:log_debug("file type detected: " .. output)
	return output, nil
end

-- Extract original filename from multipart upload file.
-- Reads the first few KB of the file to find the Content-Disposition header.
-- Returns filename or nil if not found.
--- @return string|nil filename Extracted filename or nil if not found
function file_ops.filename_extract(plugin, file_path)
	local file, err = io.open(file_path, "rb")
	if not file then
		plugin:log_debug("Could not open file to extract filename: " .. tostring(err))
		return nil
	end

	-- Read first 4KB (should contain headers)
	local header_data = file:read(4096)
	file:close()

	if not header_data then
		return nil
	end

	-- Look for Content-Disposition header with filename
	-- Format: Content-Disposition: form-data; name="file"; filename="example.jpg"
	local filename = header_data:match('filename="([^"]+)"')
	if not filename then
		-- Try alternative format without quotes
		filename = header_data:match("filename=([^%s;]+)")
	end

	if not filename then
		return nil
	end

	-- Validate filename to prevent path traversal (CWE-22) and log injection (CWE-117)
	local valid, err = utils.file_validate_name(filename)
	if not valid then
		plugin:log_debug("Invalid filename extracted: " .. utils.log_sanitize(filename) .. " - " .. err)
		return nil
	end

	-- Sanitize filename for safe logging (removes control characters)
	return utils.log_sanitize(filename)
end

-- ============================================================================
-- MULTIPART PARSING
-- ============================================================================

-- Parse multipart/form-data body and extract all uploaded files.
-- Returns success boolean, array of file info tables, and optional attack indicator.
-- Each file info table contains: {filepath, filename, size, content_type}
--
-- Filename injection attack handling (path traversal, null bytes, etc.):
-- Behavior matrix based on BLOCK_ON_FILENAME_INJECTION_ATTACK and RESUME_SCAN_ON_FIRST_HIT:
--
--   BLOCK=yes, RESUME=yes:  Skip file, continue scanning other files, block at end
--   BLOCK=yes, RESUME=no:   Block immediately (default, fastest protection)
--   BLOCK=no,  RESUME=yes:  Log attack, scan file content anyway, continue to other files
--   BLOCK=no,  RESUME=no:   Log attack, scan file content anyway until first virus hit
--
-- When BLOCK=no, files with suspicious filenames are still scanned for actual malware.
-- This is useful for forensics/research to understand what attackers are uploading.
--
-- Returns:
--   - On success: true, files_array, nil
--   - On success with attacks: true, files_array, "filename_attack_detected"
--   - On immediate failure: false, error_message, nil
--- @return boolean success True if parsing succeeded
--- @return table|string files_or_error Array of file info tables on success, error message on failure
--- @return string|nil attack_indicator "filename_attack_detected" if attacks were detected
function file_ops.multipart_parse(plugin, body_file, content_type)
	-- Extract boundary from Content-Type header
	local boundary = content_type:match("boundary=([^;%s]+)")
	if not boundary then
		return false, "no boundary found in Content-Type"
	end

	-- Read the entire multipart body
	local file, err = io.open(body_file, "rb")
	if not file then
		return false, "failed to open body file: " .. (err or "unknown")
	end

	-- Check file size to prevent DoS via large uploads (CWE-770)
	local size = file:seek("end")
	file:seek("set", 0)

	local MAX_MULTIPART_SIZE = 100 * 1024 * 1024  -- 100MB
	if size > MAX_MULTIPART_SIZE then
		file:close()
		return false, "multipart body too large (max 100MB)"
	end

	local body_content = file:read("*a")
	file:close()

	if not body_content or body_content == "" then
		return false, "body file is empty"
	end

	plugin:log_debug("[v" .. file_ops.VERSION .. "] [MULTIPART] Parsing multipart body: " .. #body_content .. " bytes, boundary=" .. boundary)

	-- Split by boundary (format: --boundary)
	-- Escape ALL non-alphanumeric characters to prevent pattern injection (Medium severity issue #13)
	local boundary_pattern = "%-%-" .. boundary:gsub("([^%w])", "%%%1")
	local files = {}
	local created_temp_files = {}  -- Track temp files for cleanup on error
	local part_count = 0
	local filename_attack_detected = false
	local block_on_filename_attack = plugin.variables["MALWARE_SCAN_BLOCK_ON_FILENAME_INJECTION_ATTACK"] == "yes"
	local resume_on_hit = plugin.variables["MALWARE_SCAN_RESUME_SCAN_ON_FIRST_HIT"] == "yes"

	-- Resource limit: maximum files per request (prevents file descriptor exhaustion)
	local max_files = tonumber(plugin.variables["MALWARE_SCAN_MAX_FILES_PER_REQUEST"]) or 100

	-- Find all parts between boundaries
	local pos = 1
	while true do
		-- Find next boundary
		local boundary_start, boundary_end = body_content:find(boundary_pattern, pos)
		if not boundary_start then
			break
		end

		-- Move past the boundary and newline
		pos = boundary_end + 1

		-- Skip CR/LF after boundary
		if body_content:sub(pos, pos) == "\r" then
			pos = pos + 1
		end
		if body_content:sub(pos, pos) == "\n" then
			pos = pos + 1
		end

		-- Find next boundary to get this part's content
		local next_boundary_start = body_content:find(boundary_pattern, pos)
		if not next_boundary_start then
			break
		end

		-- Extract this part (between current position and next boundary)
		local part_content = body_content:sub(pos, next_boundary_start - 1)

		-- Check if this part has a filename (is a file upload)
		local filename = part_content:match('filename="([^"]+)"')
		if not filename then
			-- Try without quotes
			filename = part_content:match("filename=([^%s;]+)")
		end

		if filename then
			-- Sanitize filename once for all logging (prevent log injection)
			local safe_filename = utils.log_sanitize(filename)

			-- Validate filename for security (defense-in-depth)
			local valid, validation_err = utils.file_validate_name(filename)
			if not valid then
				logger.log_error( "[MULTIPART] SECURITY ATTACK DETECTED - Invalid filename: " .. safe_filename)
				logger.log_error( "[MULTIPART] Attack type: " .. validation_err)

				-- Behavior matrix for filename injection attacks:
				-- BLOCK=yes, RESUME=yes:  Log attack, extract file with sanitized name, scan content, block at end
				-- BLOCK=yes, RESUME=no:   Block immediately (fast protection)
				-- BLOCK=no,  RESUME=yes:  Log attack, scan this file anyway, continue to other files
				-- BLOCK=no,  RESUME=no:   Log attack, scan this file anyway until first virus hit
				if block_on_filename_attack then
					if resume_on_hit then
						-- Resume mode: Extract and scan file content even with malicious filename
						-- This allows detecting BOTH filename attack AND content malware
						logger.log_error( "[MULTIPART] BLOCK=yes, RESUME=yes - extracting file with sanitized name to scan content, will block at end")
						filename_attack_detected = true
						-- Sanitize filename for safe disk storage (replace dangerous chars with _)
						-- Keep original filename for reporting but use sanitized version for extraction
						filename = filename:gsub("[%z/\\]", "_")
						-- Fall through to normal file processing
					else
						-- Block immediately - cleanup temp files before returning
						logger.log_error( "[MULTIPART] BLOCK=yes, RESUME=no - blocking immediately")
						for _, temp_path in ipairs(created_temp_files) do
							os.remove(temp_path)
						end
						return false, "malicious filename detected: " .. validation_err .. " (filename: " .. safe_filename .. ")", nil
					end
				else
					-- BLOCK=no: Log the attack but continue processing this file
					-- The file will still be scanned for actual malware content
					logger.log_error( "[MULTIPART] BLOCK=no - logging attack but continuing to scan file content")
					filename_attack_detected = true
					-- Fall through to normal file processing (no skip, no return)
				end
			end

			part_count = part_count + 1
			plugin:log_debug("[v" .. file_ops.VERSION .. "] [MULTIPART] Found file part #" .. part_count .. ": " .. safe_filename)

			-- Extract content-type if present
			local file_content_type = part_content:match("[Cc]ontent%-[Tt]ype:%s*([^%s\r\n]+)")

			-- Find end of headers (double newline)
			local content_start = part_content:find("\r\n\r\n")
			if content_start then
				content_start = content_start + 4
			else
				content_start = part_content:find("\n\n")
				if content_start then
					content_start = content_start + 2
				else
					logger.log_error( "[MULTIPART] Could not find end of headers for file: " .. safe_filename)
					goto continue
				end
			end

			-- Extract file content (trim trailing CR/LF before boundary)
			local file_content = part_content:sub(content_start)
			-- Remove trailing CRLF or LF
			file_content = file_content:gsub("\r\n$", ""):gsub("\n$", "")

			-- Resource limit: check file count before creating temp file (CWE-770: DoS via file descriptor exhaustion)
			if #files >= max_files then
				logger.log_error( "[MULTIPART] RESOURCE LIMIT EXCEEDED - Maximum files per request reached: " .. max_files)
				logger.log_error( "[MULTIPART] Blocked DoS attempt: " .. (#files + 1) .. " files in single request")
				-- Cleanup already created temp files before returning
				for _, temp_path in ipairs(created_temp_files) do
					os.remove(temp_path)
				end
				return false, "too many files in single request (max: " .. max_files .. ")", nil
			end

			-- Write to temporary file
			local temp_path = os.tmpname()
			local temp_file, temp_err = io.open(temp_path, "wb")
			if not temp_file then
				logger.log_error( "[MULTIPART] Failed to create temp file for " .. safe_filename .. ": " .. (temp_err or "unknown"))
				goto continue
			end

			-- Track temp file for cleanup on error
			table.insert(created_temp_files, temp_path)

			temp_file:write(file_content)
			temp_file:close()

			-- Detect file type using `file` command
			local detected_type, type_err = file_ops.file_get_type(plugin, temp_path)
			if not detected_type then
				plugin:log_debug("[v" .. file_ops.VERSION .. "] [MULTIPART] Could not detect file type for " .. safe_filename .. ": " .. (type_err or "unknown"))
				detected_type = "unknown"
			end

			table.insert(files, {
				filepath = temp_path,
				filename = filename,
				size = #file_content,
				content_type = file_content_type or "application/octet-stream",
				file_type = detected_type
			})

			logger.log_error( "[MULTIPART] Extracted file: " .. safe_filename .. " (" .. #file_content .. " bytes, type: " .. detected_type .. ") -> " .. temp_path)
		end

		::continue::
		pos = next_boundary_start
	end

	if #files == 0 and not filename_attack_detected then
		return false, "no file uploads found in multipart body", nil
	end

	logger.log_error( "[MULTIPART] Parsed " .. #files .. " file(s) from multipart body")

	-- Return with attack indicator if filename attacks were detected
	if filename_attack_detected then
		logger.log_error( "[MULTIPART] Filename injection attack(s) detected - will block request after full scan")
		return true, files, "filename_attack_detected"
	end

	return true, files, nil
end

-- ============================================================================
-- FILE CONTENT EXTRACTION
-- ============================================================================

-- Extract actual file content from multipart body.
-- The temp file contains the entire multipart/form-data body including headers.
-- This function extracts just the file content from the part with filename=.
--
-- SECURITY WARNING: This function searches for the filename pattern in the body
-- but does NOT validate the filename itself. Filename validation MUST be done
-- by the caller (see utils.file_validate_name() and multipart_parse()).
-- NEVER trust attacker-provided filenames for filesystem operations!
--
-- Returns success boolean and extracted content or error message.
--- @return boolean success True if extraction succeeded
--- @return string content_or_error Extracted file content on success, error message on failure
function file_ops.content_extract(plugin, file_path)
	local file, err = io.open(file_path, "rb")
	if not file then
		return false, "failed to open file: " .. (err or "unknown")
	end

	-- Read the entire file (should be reasonable size for uploads)
	local content = file:read("*a")
	file:close()

	if not content or content == "" then
		return false, "file is empty"
	end

	-- Find the part that contains filename= (the actual file upload)
	local filename_pos = content:find('filename="')
	if not filename_pos then
		-- Try without quotes
		filename_pos = content:find("filename=")
		if not filename_pos then
			logger.log_error( "could not find filename in multipart body")
			return false, "no file upload found in multipart body"
		end
	end

	-- Find the end of headers for this part (double newline after filename line)
	local content_start = content:find("\r\n\r\n", filename_pos)
	if not content_start then
		-- Try just \n\n (some clients use this)
		content_start = content:find("\n\n", filename_pos)
		if not content_start then
			logger.log_error( "could not find end of file part headers")
			return false, "invalid multipart format"
		end
		content_start = content_start + 2  -- Skip \n\n
	else
		content_start = content_start + 4  -- Skip \r\n\r\n
	end

	-- Find the ending boundary AFTER the file content (starts with --)
	local boundary_pattern = "\r\n%-%-"
	local content_end = content:find(boundary_pattern, content_start)
	if not content_end then
		-- Try just \n--
		boundary_pattern = "\n%-%-"
		content_end = content:find(boundary_pattern, content_start)
		if not content_end then
			logger.log_error( "could not find ending multipart boundary")
			return false, "invalid multipart format"
		end
	end

	-- Extract just the file content (between headers and ending boundary)
	local file_content = content:sub(content_start, content_end - 1)

	plugin:log_debug("Extracted file content: " .. #file_content .. " bytes from " .. #content .. " bytes total")

	return true, file_content
end

-- Calculate SHA256 checksum of a file.
-- Takes file path, returns success boolean and checksum or error message.
-- For multipart uploads, extracts the actual file content first.
-- Returns special value "empty_file" for 0-byte files to skip calculation.
--- @return boolean success True if hash calculation succeeded
--- @return string checksum_or_error SHA256 checksum on success (or "empty_file"), error message on failure
function file_ops.hash_calculate(plugin, file_path)
	-- Extract actual file content from multipart body
	local ok, file_content = file_ops.content_extract(plugin, file_path)
	if not ok then
		logger.log_error( "failed to extract file content: " .. file_content)
		-- Fallback: hash the entire file as-is
		local file, err = io.open(file_path, "rb")
		if not file then
			return false, "failed to open file: " .. (err or "unknown")
		end

		-- Validate file size before reading to prevent DoS (Medium severity issue #17)
		local size = file:seek("end")
		file:seek("set", 0)

		local MAX_FALLBACK_SIZE = 100 * 1024 * 1024  -- 100MB
		if size > MAX_FALLBACK_SIZE then
			file:close()
			return false, "file too large for fallback SHA256 calculation (max 100MB)"
		end

		local sha = sha256:new()
		if not sha then
			file:close()
			return false, "failed to create SHA256 instance"
		end

		while true do
			local chunk = file:read(8192)
			if not chunk then
				break
			end
			sha:update(chunk)
		end

		file:close()
		local checksum = to_hex(sha:final())
		logger.log_error( "calculated SHA256 of entire multipart body (fallback): " .. checksum)
		return true, checksum
	end

	-- Check if file is empty (0 bytes) - skip SHA256 calculation
	if #file_content == 0 then
		logger.log_error( "file is 0 bytes (empty), skipping SHA256 calculation")
		return true, "empty_file"
	end

	-- Calculate SHA256 of extracted file content
	local sha = sha256:new()
	if not sha then
		return false, "failed to create SHA256 instance"
	end

	sha:update(file_content)
	local checksum = to_hex(sha:final())

	logger.log_error( "calculated SHA256 of extracted file content (" .. #file_content .. " bytes): " .. checksum)
	return true, checksum
end

-- ============================================================================
-- FILE CLEANUP OPERATIONS
-- ============================================================================

-- Delete temporary file after scanning.
-- Returns success boolean and error message if failed.
--- @return boolean success True if cleanup succeeded
--- @return string|nil error Error message if failed
function file_ops.file_cleanup(plugin, file_path)
	if not file_path or file_path == "" then
		return false, "invalid file path"
	end

	-- Use EAFP pattern to avoid race condition (Medium severity issue #18)
	-- Try to remove first, handle error if file doesn't exist
	local ok, err = os.remove(file_path)
	if not ok then
		-- Check if error is "file not found" (already cleaned up, possibly by security software)
		if err and (err:match("No such file") or err:match("cannot find") or err:match("not exist")) then
			logger.log_notice( "temp file already removed (possibly by security software): " .. file_path)
			return true
		end
		-- Other error (permissions, etc.)
		return false, err or "unknown error"
	end

	logger.log_notice( "cleaned up temp file: " .. file_path)
	return true
end

-- Clean up orphaned temporary files older than specified age.
-- Scans temp directory and deletes files older than max_age seconds.
-- Returns success boolean and error message if failed.
--- @return boolean success True if cleanup succeeded
--- @return string|nil error Error message if failed
function file_ops.orphan_cleanup(plugin, max_age)
	-- Check if lfs is available (required for directory operations)
	if not lfs then
		logger.log_warn("lfs module not available - orphan cleanup disabled")
		return true  -- Not an error, just can't clean
	end

	-- Validate max_age to prevent invalid values and command injection (CWE-78)
	-- Use validation utility to ensure it's a positive integer <= 86400 (1 day)
	local max_age_num = utils.validate_positive_integer(max_age, 3600, 86400, "max_age")

	-- Double-check after validation
	if max_age_num <= 0 then
		return false, "invalid max_age value (must be positive number <= 86400)"
	end

	-- Use default nginx temp path for BunkerWeb
	local temp_path = "/var/tmp/bunkerweb/client_temp"

	-- Check if directory exists
	local dir_attr = lfs.attributes(temp_path, "mode")
	if not dir_attr or dir_attr ~= "directory" then
		logger.log_warn("Temp directory does not exist: " .. temp_path)
		return true  -- Not an error, just nothing to clean
	end

	local cleaned_count = 0
	local error_count = 0
	local current_time = os.time()

	-- Iterate through directory using lfs.dir (native Lua, non-blocking)
	for filename in lfs.dir(temp_path) do
		-- Skip . and .. entries
		if filename ~= "." and filename ~= ".." then
			local file_path = temp_path .. "/" .. filename

			-- Get file attributes
			local attr = lfs.attributes(file_path)

			-- Only process regular files (skip directories, symlinks, etc.)
			if attr and attr.mode == "file" then
				-- Check if file is older than max_age
				local file_age = current_time - attr.modification
				if file_age > max_age_num then
					-- File is old enough, try to remove it
					local ok, err = os.remove(file_path)
					if ok then
						cleaned_count = cleaned_count + 1
					else
						-- Check if error is "file not found" (already deleted by security software)
						if err and (err:match("No such file") or err:match("cannot find")) then
							-- File already removed, count as cleaned
							cleaned_count = cleaned_count + 1
						else
							-- Actual error
							error_count = error_count + 1
							logger.log_warn(
								"failed to remove orphaned file " .. file_path .. ": " .. (err or "unknown")
							)
						end
					end
				end
			end
		end
	end

	if cleaned_count > 0 then
		logger.log_notice(
			"cleaned up " .. cleaned_count .. " orphaned temp files from " .. temp_path
		)
	end

	return true
end

-- ============================================================================
-- MALWARE SAMPLE SHARING
-- Note: This function has dependencies on VirusTotal module
-- It will be called with virustotal module passed as parameter
-- ============================================================================

-- Share detected malware file with threat intelligence platforms.
-- Uploads unknown malware to VirusTotal for community threat intelligence.
-- Returns success boolean and error message if failed.
--- @return boolean success True if sharing succeeded or was skipped
--- @return string|nil error Error message if failed
function file_ops.detection_share(plugin, file_path, checksum, detector_name, virustotal, file_type)
	-- Check if file sharing is enabled
	if plugin.variables["MALWARE_SCAN_SHARE_FILES"] ~= "yes" then
		plugin:log_debug("File sharing disabled, not uploading detected malware")
		return true
	end

	-- Check if VirusTotal is enabled for sharing
	if plugin.variables["MALWARE_SCAN_API_USE_VIRUSTOTAL"] ~= "yes" then
		logger.log_error( "File sharing enabled but VirusTotal not configured - cannot share detected file")
		return true
	end

	-- Verify virustotal module is provided
	if not virustotal then
		logger.log_error( "[SHARE] VirusTotal module not loaded - cannot share detected file")
		return true
	end

	logger.log_error( "[SHARE] File detected by " .. detector_name .. ", checking if already known to VirusTotal")

	-- Check if file is already known to VirusTotal
	local vt_ok, vt_found, vt_response = virustotal.virustotal_request(plugin, "/files/" .. checksum)
	if not vt_ok then
		logger.log_error( "[SHARE] VirusTotal check failed: " .. vt_found .. " - cannot determine if file should be shared")
		return true
	end

	if vt_found then
		logger.log_error( "[SHARE] File already known to VirusTotal (detected by " .. detector_name .. ") - skipping upload")
		return true
	end

	-- ========================================================================
	-- GDPR PROTECTION: Check file type before uploading
	-- ========================================================================

	-- Load filetypes module for GDPR filtering
	local filetypes = require("malware_scan_filetypes")

	-- Use provided file_type or default to "unknown"
	local detected_type = file_type or "unknown"

	-- Apply same GDPR logic as orchestrator:
	-- Only upload if: file_type is known AND is executable AND NOT user data
	local is_safe_to_upload = detected_type and detected_type ~= "unknown" and not filetypes.contains_user_data(detected_type)

	if not detected_type or detected_type == "unknown" then
		-- Unknown file type - DO NOT UPLOAD (GDPR-safe default)
		logger.log_error( string.format(
			"[SHARE] %s detected malware but file type unknown - GDPR protection: NOT uploading to VirusTotal (cannot verify if file contains personal data)",
			detector_name
		))
		return true
	elseif filetypes.contains_user_data(detected_type) then
		-- File may contain personal data - DO NOT UPLOAD
		logger.log_error( string.format(
			"[SHARE] %s detected malware but file may contain user data (type: %s) - GDPR protection: NOT uploading to VirusTotal",
			detector_name,
			detected_type
		))
		logger.log_error( "[SHARE] File type categories: documents, images, databases, archives may contain personal data and will not be uploaded")
		return true
	elseif not is_safe_to_upload then
		-- Shouldn't reach here, but defensive check
		logger.log_error( string.format(
			"[SHARE] %s detected malware but file failed GDPR check (type: %s) - NOT uploading to VirusTotal",
			detector_name,
			detected_type or "nil"
		))
		return true
	end

	-- File is safe to upload: known executable type without user data
	logger.log_error( string.format(
		"[SHARE] File unknown to VirusTotal and safe to share (type: %s) - uploading for threat intelligence (detected by %s)",
		detected_type,
		detector_name
	))
	local upload_ok, analysis_id, file_size = virustotal.file_upload(plugin, file_path)

	if not upload_ok then
		logger.log_error( "[SHARE] Failed to upload file to VirusTotal: " .. analysis_id)
		return false, analysis_id
	end

	logger.log_error( "[SHARE] File uploaded successfully (" .. file_size .. " bytes), analysis ID: " .. tostring(analysis_id))

	-- Auto-vote if enabled
	if plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_AUTO_VOTE"] == "yes" then
		logger.log_error( "[SHARE] Auto-voting file as malicious on VirusTotal")
		local vote_ok, vote_err = virustotal.virustotal_vote(plugin, checksum, "malicious")
		if vote_ok then
			logger.log_error( "[SHARE] Malicious vote submitted successfully")
		else
			logger.log_error( "[SHARE] Failed to submit vote: " .. vote_err)
		end
	end

	return true
end

-- Check available disk space for a given path.
-- Returns available space in bytes, or nil on error.
-- Uses `df` command to check filesystem space.
--- @param plugin Plugin instance
--- @param path Directory path to check (will check parent if doesn't exist)
--- @return number|nil available_bytes Available space in bytes or nil on error
--- @return string|nil error Error message if failed
function file_ops.disk_space_check(plugin, path)
	if not path or path == "" then
		return nil, "invalid path"
	end

	-- Validate and escape path to prevent command injection (CWE-78)
	local escaped_path, err = utils.validate_and_escape_path(path)
	if not escaped_path then
		return nil, err
	end

	-- Get parent directory if path doesn't exist yet (native Lua, non-blocking)
	local check_path = escaped_path
	local parent_dir = path:match("(.+)/[^/]+$")
	if parent_dir and lfs then
		-- Check if path exists using lfs.attributes
		local dir_attr = lfs.attributes(path, "mode")
		if not dir_attr or dir_attr ~= "directory" then
			-- Directory doesn't exist, use parent directory
			local escaped_parent = utils.validate_and_escape_path(parent_dir)
			if escaped_parent then
				check_path = escaped_parent
				plugin:log_debug("Directory doesn't exist yet, checking parent: " .. parent_dir)
			end
		end
	end

	-- Run df command to check available space
	-- -B1 = output in bytes
	-- Format: Filesystem 1B-blocks Used Available Use% Mounted on
	local cmd = string.format("df -B1 %s 2>&1 | tail -1 | awk '{print $4}'", check_path)

	local handle, err = io.popen(cmd)
	if not handle then
		logger.log_error( "Failed to execute df command: " .. (err or "unknown"))
		return nil, "failed to execute df command"
	end

	local output = handle:read("*l")
	handle:close()

	if not output or output == "" then
		return nil, "no output from df command"
	end

	-- Parse available bytes
	local available_bytes = tonumber(output)
	if not available_bytes then
		logger.log_error( "Failed to parse df output: " .. output)
		return nil, "failed to parse df output"
	end

	-- Validate disk space is a valid non-negative number (not negative, NaN, or infinity)
	available_bytes = utils.validate_disk_space(available_bytes)
	if available_bytes == 0 and output ~= "0" then
		-- Validation failed (was negative or invalid)
		logger.log_error( "Invalid disk space value from df: " .. output)
		return nil, "invalid disk space value"
	end

	plugin:log_debug(string.format("Available disk space: %d bytes (%.2f MB)", available_bytes, available_bytes / 1024 / 1024))
	return available_bytes, nil
end

-- Export detected malware file to local directory for forensic analysis.
-- Saves file with SHA256 hash as filename for easy identification.
-- Also creates a .txt file with detection details (detector, result, timestamp, etc.)
-- Checks disk space before saving to prevent filling the filesystem.
--- @param plugin Plugin instance
--- @param file_path Path to malware file to export
--- @param checksum SHA256 hash of the file
--- @param detector_name Name of scanner that detected the malware (e.g., "ClamAV")
--- @param detection_result Detection result string (e.g., "Win.Trojan.Cerber")
--- @param file_type MIME type of the file (optional)
--- @return boolean success True if export succeeded or was skipped
--- @return string|nil error Error message if failed
function file_ops.virusfile_export(plugin, file_path, checksum, detector_name, detection_result, file_type)
	-- Check if export is enabled
	local export_path = plugin.variables["MALWARE_SCAN_VIRUSFILE_LOCAL_EXPORT_PATH"]
	if not export_path or export_path == "" then
		plugin:log_debug("[v" .. file_ops.VERSION .. "] [EXPORT] Local malware export disabled (MALWARE_SCAN_VIRUSFILE_LOCAL_EXPORT_PATH not set)")
		return true
	end

	-- Validate inputs
	if not file_path or file_path == "" then
		return false, "invalid file path"
	end

	if not checksum or checksum == "" or checksum == "empty_file" then
		logger.log_error( "[EXPORT] Cannot export file without valid checksum")
		return false, "invalid checksum"
	end

	-- Get file size
	local file_size = file_ops.file_get_size(plugin, file_path)
	if not file_size or file_size == 0 then
		logger.log_error( "[EXPORT] Cannot export empty or non-existent file")
		return false, "invalid file size"
	end

	-- Validate file_size is a positive number
	file_size = utils.validate_file_size(file_size, 10 * 1024 * 1024 * 1024)

	-- Check available disk space (require at least 2x file size + 100MB buffer)
	-- Use safe arithmetic to prevent overflow
	local buffer_size = 100 * 1024 * 1024  -- 100MB
	local doubled_size = utils.safe_multiply(file_size, 2, 10 * 1024 * 1024 * 1024)
	local required_space = utils.safe_add(doubled_size, buffer_size, 10 * 1024 * 1024 * 1024)

	local available_space, space_err = file_ops.disk_space_check(plugin, export_path)

	if not available_space then
		logger.log_error( string.format(
			"[EXPORT] Failed to check disk space for %s: %s - skipping export",
			export_path,
			space_err or "unknown error"
		))
		return false, "disk space check failed: " .. (space_err or "unknown")
	end

	if available_space < required_space then
		logger.log_error( string.format(
			"[EXPORT] Insufficient disk space: available %.2f MB, required %.2f MB (file size %.2f MB + 100MB buffer) - skipping export",
			available_space / 1024 / 1024,
			required_space / 1024 / 1024,
			file_size / 1024 / 1024
		))
		return false, string.format("insufficient disk space: %.2f MB available, %.2f MB required",
			available_space / 1024 / 1024,
			required_space / 1024 / 1024)
	end

	-- Validate and escape paths for shell commands (defense-in-depth)
	local escaped_export_path, escape_err = utils.validate_and_escape_path(export_path)
	if not escaped_export_path then
		logger.log_error( string.format("[v" .. file_ops.VERSION .. "] [EXPORT] Export path validation failed: %s", escape_err or "unknown"))
		return false, "export path validation failed: " .. (escape_err or "unknown")
	end

	local escaped_file_path, file_escape_err = utils.validate_and_escape_path(file_path)
	if not escaped_file_path then
		logger.log_error( string.format("[v" .. file_ops.VERSION .. "] [EXPORT] File path validation failed: %s", file_escape_err or "unknown"))
		return false, "file path validation failed: " .. (file_escape_err or "unknown")
	end

	-- Create export directory if it doesn't exist (native Lua, non-blocking)
	local mkdir_ok, mkdir_err = mkdir_recursive(export_path)
	if not mkdir_ok then
		logger.log_error( "[EXPORT] Failed to create export directory: " .. (mkdir_err or "unknown error"))
		return false, "failed to create directory: " .. (mkdir_err or "unknown error")
	end

	-- Build export file path: /export/path/SHA256
	local export_file = string.format("%s/%s", export_path, checksum)
	local escaped_export_file, export_file_err = utils.validate_and_escape_path(export_file)
	if not escaped_export_file then
		logger.log_error( string.format("[v" .. file_ops.VERSION .. "] [EXPORT] Export file path validation failed: %s", export_file_err or "unknown"))
		return false, "export file path validation failed: " .. (export_file_err or "unknown")
	end

	-- Check if file already exists (native Lua, non-blocking) if lfs is available
	if lfs then
		local file_attr = lfs.attributes(export_file, "mode")
		if file_attr == "file" then
			logger.log_error( string.format(
				"[EXPORT] File already exported: %s (detected by %s: %s) - skipping",
				export_file,
				detector_name or "unknown",
				detection_result or "unknown"
			))
			return true  -- Not an error, just already exported
		end
	end

	-- Copy file to export directory (native Lua, non-blocking)
	local cp_ok, cp_err = file_copy(file_path, export_file)
	if not cp_ok then
		logger.log_error( string.format("[v" .. file_ops.VERSION .. "] [EXPORT] Failed to copy file: %s", cp_err or "unknown error"))
		return false, "failed to copy file: " .. (cp_err or "unknown error")
	end

	-- Set restrictive permissions (600 = owner read/write only)
	local chmod_cmd = string.format("chmod 600 %s 2>&1", escaped_export_file)
	local chmod_handle = io.popen(chmod_cmd)
	if chmod_handle then
		local _ = chmod_handle:read("*a")  -- Read and discard output
		chmod_handle:close()
	end

	-- Create detection details text file (SHA256.txt)
	local info_file = export_file .. ".txt"
	local info_handle, info_err = io.open(info_file, "w")
	if info_handle then
		-- Get current timestamp
		local timestamp = os.date("%Y-%m-%d %H:%M:%S UTC", os.time())

		-- Write detection details
		info_handle:write("=============================================================================\n")
		info_handle:write("MALWARE DETECTION REPORT\n")
		info_handle:write("=============================================================================\n\n")
		info_handle:write("Detection Date:     " .. timestamp .. "\n")
		info_handle:write("SHA256 Hash:        " .. checksum .. "\n")
		info_handle:write("File Size:          " .. string.format("%.2f MB (%d bytes)", file_size / 1024 / 1024, file_size) .. "\n")
		info_handle:write("File Type:          " .. (file_type or "unknown") .. "\n")
		info_handle:write("Detected By:        " .. (detector_name or "unknown") .. "\n")
		info_handle:write("Detection Result:   " .. (detection_result or "unknown") .. "\n")
		info_handle:write("\n")
		info_handle:write("-----------------------------------------------------------------------------\n")
		info_handle:write("Original Path:      " .. file_path .. "\n")
		info_handle:write("Export Path:        " .. export_file .. "\n")
		info_handle:write("-----------------------------------------------------------------------------\n\n")
		info_handle:write("This file contains malicious content and should only be analyzed\n")
		info_handle:write("in a secure, isolated environment. Do not execute or open without\n")
		info_handle:write("proper security precautions.\n\n")
		info_handle:write("For analysis assistance, you can upload the sample to:\n")
		info_handle:write("- VirusTotal: https://www.virustotal.com/\n")
		info_handle:write("- MalwareBazaar: https://bazaar.abuse.ch/\n")
		info_handle:write("- Hybrid Analysis: https://www.hybrid-analysis.com/\n\n")
		info_handle:write("=============================================================================\n")
		info_handle:close()

		-- Set restrictive permissions on info file
		local escaped_info_file, info_escape_err = utils.validate_and_escape_path(info_file)
		if escaped_info_file then
			local chmod_info_cmd = string.format("chmod 600 %s 2>&1", escaped_info_file)
			local chmod_info_handle = io.popen(chmod_info_cmd)
			if chmod_info_handle then
				local _ = chmod_info_handle:read("*a")  -- Read and discard output
				chmod_info_handle:close()
			end
		else
			logger.log_warn( string.format("[v" .. file_ops.VERSION .. "] [EXPORT] Could not set permissions on info file: %s", info_escape_err or "unknown"))
		end

		plugin:log_debug(string.format("[v" .. file_ops.VERSION .. "] [EXPORT] Detection details written to: %s", info_file))
	else
		logger.log_warn( string.format(
			"[EXPORT] Failed to create detection details file %s: %s",
			info_file,
			info_err or "unknown"
		))
	end

	-- Log successful export
	logger.log_error( string.format(
		"[EXPORT] Malware sample exported: %s (%.2f MB) - Detected by %s: %s - SHA256: %s",
		export_file,
		file_size / 1024 / 1024,
		detector_name or "unknown",
		detection_result or "unknown",
		checksum
	))

	return true
end

-- ============================================================================
-- ALLOW LIST (FALSE POSITIVE HANDLING)
-- ============================================================================

-- Populate allow list cache from config and file.
-- Loads all hashes into memory cache for fast lookups.
-- Called once on first request (lazy loading).
--- @param plugin table Plugin instance
--- @return boolean success True if population succeeded
--- @return number hash_count Number of hashes loaded
function file_ops.allowlist_populate(plugin)
	local hash_count = 0

	logger.log_error( "[ALLOWLIST] Populating allow list cache from configuration")

	-- Load from comma-separated config variable
	local allowlist_hashes = plugin.variables["MALWARE_SCAN_ALLOWLIST_HASHES"] or ""
	if allowlist_hashes ~= "" then
		for hash in allowlist_hashes:gmatch("[^,]+") do
			-- Trim whitespace and normalize to lowercase
			hash = hash:gsub("^%s+", ""):gsub("%s+$", ""):lower()
			-- Validate hash format (64 hex characters)
			if hash:match("^[a-f0-9]{64}$") then
				local cache_key = "plugin_malware_scan_allowlist_" .. hash
				plugin.cachestore:set(cache_key, "1", 0)  -- 0 = never expire
				hash_count = hash_count + 1
			else
				logger.log_warn( string.format(
					"[ALLOWLIST] Invalid hash format in MALWARE_SCAN_ALLOWLIST_HASHES: %s (must be 64 hex characters)",
					hash
				))
			end
		end
		if hash_count > 0 then
			logger.log_error( string.format(
				"[ALLOWLIST] Loaded %d hash(es) from config variable",
				hash_count
			))
		end
	end

	-- Load from file
	local allowlist_file = plugin.variables["MALWARE_SCAN_ALLOWLIST_FILE"] or ""
	if allowlist_file ~= "" then
		local file, err = io.open(allowlist_file, "r")
		if not file then
			logger.log_error( string.format(
				"[ALLOWLIST] Failed to open allow list file %s: %s",
				allowlist_file, err or "unknown"
			))
		else
			local file_hash_count = 0
			for line in file:lines() do
				-- Trim whitespace
				line = line:gsub("^%s+", ""):gsub("%s+$", "")
				-- Skip empty lines and comments
				if line ~= "" and not line:match("^#") then
					-- Normalize to lowercase
					line = line:lower()
					-- Validate hash format (64 hex characters)
					if line:match("^[a-f0-9]{64}$") then
						local cache_key = "plugin_malware_scan_allowlist_" .. line
						plugin.cachestore:set(cache_key, "1", 0)  -- 0 = never expire
						file_hash_count = file_hash_count + 1
						hash_count = hash_count + 1
					else
						logger.log_warn( string.format(
							"[ALLOWLIST] Invalid hash format in file %s: %s (must be 64 hex characters)",
							allowlist_file, line
						))
					end
				end
			end
			file:close()

			if file_hash_count > 0 then
				logger.log_error( string.format(
					"[ALLOWLIST] Loaded %d hash(es) from file %s",
					file_hash_count, allowlist_file
				))
			end
		end
	end

	-- Mark cache as populated
	plugin.cachestore:set("plugin_malware_scan_allowlist_populated", "1", 0)

	logger.log_error( string.format(
		"[ALLOWLIST] Cache population complete - %d total hash(es) loaded",
		hash_count
	))

	return true, hash_count
end

-- Clear allow list cache (called on service reload).
--- @param plugin table Plugin instance
--- @return boolean success Always returns true
function file_ops.allowlist_clear(plugin)
	logger.log_error( "[ALLOWLIST] Clearing allow list cache for reload")

	-- Clear the populated flag
	plugin.cachestore:delete("plugin_malware_scan_allowlist_populated")

	-- Note: Individual hash entries will be overwritten on next population
	-- No need to iterate and delete them all (performance optimization)

	return true
end

-- Check if allow list cache is populated.
--- @param plugin table Plugin instance
--- @return boolean populated True if cache is populated
function file_ops.allowlist_is_populated(plugin)
	local populated = plugin.cachestore:get("plugin_malware_scan_allowlist_populated")
	return populated == "1"
end

-- Check if a SHA256 hash is in the allow list.
-- Uses cached allow list for performance (populated on first request).
-- Falls back to direct file/config reading if cache is not available.
--- @param plugin table Plugin instance
--- @param checksum string SHA256 hash to check
--- @return boolean in_list True if hash is in allow list, false otherwise
function file_ops.allowlist_check_hash(plugin, checksum)
	if not checksum or checksum == "" or checksum == "empty_file" then
		return false
	end

	-- Normalize checksum to lowercase for comparison
	checksum = checksum:lower()

	-- Ensure allow list cache is populated (lazy loading on first request)
	if not file_ops.allowlist_is_populated(plugin) then
		plugin:log_debug("[v" .. file_ops.VERSION .. "] [ALLOWLIST] Cache not populated, loading allow list into cache")
		file_ops.allowlist_populate(plugin)
	end

	-- Fast path: Check cache for hash
	local cache_key = "plugin_malware_scan_allowlist_" .. checksum
	local cached = plugin.cachestore:get(cache_key)
	if cached == "1" then
		plugin:log_debug(string.format(
			"[ALLOWLIST] File hash matches allow list (cached): %s",
			checksum
		))
		return true
	end

	-- Not in allow list
	return false
end

-- Return module
return file_ops
