-- BunkerWeb Malware Scan - File Operations Module
-- Handles all file handling, content extraction, validation, and cleanup operations

local sha256 = require("resty.sha256")
local str = require("resty.string")
local utils = require("malware_scan_utils")

local ngx = ngx
local ERR = ngx.ERR
local NOTICE = ngx.NOTICE
local WARN = ngx.WARN
local to_hex = str.to_hex

-- Module table
local file_ops = {}

-- ============================================================================
-- FILE OPERATIONS
-- ============================================================================

-- Get file size in bytes.
-- Returns file size or nil if unable to determine.
--
-- NOTE: This function has a known TOCTOU (Time-of-Check Time-of-Use) race condition
-- where the file could be modified between this size check and subsequent use.
-- This is acceptable because:
-- 1. Files are temporary uploads in a controlled directory (/tmp/bunkerweb/malware-scan/)
-- 2. File size is used primarily for logging and validation, not security decisions
-- 3. Actual file operations use independent file handles with their own error handling
-- (Low severity issue #21 - documented as acceptable)
function file_ops.get_file_size(plugin, file_path)
	local file, err = io.open(file_path, "rb")
	if not file then
		plugin.logger:log(ERR, "failed to open file for size check: " .. (err or "unknown"))
		return nil
	end

	local size = file:seek("end")
	file:close()

	return size
end

-- Extract original filename from multipart upload file.
-- Reads the first few KB of the file to find the Content-Disposition header.
-- Returns filename or nil if not found.
function file_ops.extract_filename_from_upload(plugin, file_path)
	local file, err = io.open(file_path, "rb")
	if not file then
		plugin:log_debug("Could not open file to extract filename: " .. tostring(err))
		return nil
	end

	-- Read first 4KB (should contain headers)
	local header_data = file:read(4096)
	file:close()

	if not header_data then
		return nil
	end

	-- Look for Content-Disposition header with filename
	-- Format: Content-Disposition: form-data; name="file"; filename="example.jpg"
	local filename = header_data:match('filename="([^"]+)"')
	if not filename then
		-- Try alternative format without quotes
		filename = header_data:match("filename=([^%s;]+)")
	end

	if not filename then
		return nil
	end

	-- Validate filename to prevent path traversal (CWE-22) and log injection (CWE-117)
	local valid, err = utils.validate_filename(filename)
	if not valid then
		plugin:log_debug("Invalid filename extracted: " .. utils.sanitize_for_logging(filename) .. " - " .. err)
		return nil
	end

	-- Sanitize filename for safe logging (removes control characters)
	return utils.sanitize_for_logging(filename)
end

-- ============================================================================
-- MULTIPART PARSING
-- ============================================================================

-- Parse multipart/form-data body and extract all uploaded files.
-- Returns success boolean, array of file info tables, and optional attack indicator.
-- Each file info table contains: {filepath, filename, size, content_type}
--
-- Filename injection attack handling (path traversal, null bytes, etc.):
-- Behavior matrix based on BLOCK_ON_FILENAME_INJECTION_ATTACK and RESUME_SCAN_ON_FIRST_HIT:
--
--   BLOCK=yes, RESUME=yes:  Skip file, continue scanning other files, block at end
--   BLOCK=yes, RESUME=no:   Block immediately (default, fastest protection)
--   BLOCK=no,  RESUME=yes:  Log attack, scan file content anyway, continue to other files
--   BLOCK=no,  RESUME=no:   Log attack, scan file content anyway until first virus hit
--
-- When BLOCK=no, files with suspicious filenames are still scanned for actual malware.
-- This is useful for forensics/research to understand what attackers are uploading.
--
-- Returns:
--   - On success: true, files_array, nil
--   - On success with attacks: true, files_array, "filename_attack_detected"
--   - On immediate failure: false, error_message, nil
function file_ops.parse_multipart_files(plugin, body_file, content_type)
	-- Extract boundary from Content-Type header
	local boundary = content_type:match("boundary=([^;%s]+)")
	if not boundary then
		return false, "no boundary found in Content-Type"
	end

	-- Read the entire multipart body
	local file, err = io.open(body_file, "rb")
	if not file then
		return false, "failed to open body file: " .. (err or "unknown")
	end

	-- Check file size to prevent DoS via large uploads (CWE-770)
	local size = file:seek("end")
	file:seek("set", 0)

	local MAX_MULTIPART_SIZE = 100 * 1024 * 1024  -- 100MB
	if size > MAX_MULTIPART_SIZE then
		file:close()
		return false, "multipart body too large (max 100MB)"
	end

	local body_content = file:read("*a")
	file:close()

	if not body_content or body_content == "" then
		return false, "body file is empty"
	end

	plugin:log_debug("[MULTIPART] Parsing multipart body: " .. #body_content .. " bytes, boundary=" .. boundary)

	-- Split by boundary (format: --boundary)
	-- Escape ALL non-alphanumeric characters to prevent pattern injection (Medium severity issue #13)
	local boundary_pattern = "%-%-" .. boundary:gsub("([^%w])", "%%%1")
	local files = {}
	local part_count = 0
	local filename_attack_detected = false
	local block_on_filename_attack = plugin.variables["MALWARE_SCAN_BLOCK_ON_FILENAME_INJECTION_ATTACK"] == "yes"
	local resume_on_hit = plugin.variables["MALWARE_SCAN_RESUME_SCAN_ON_FIRST_HIT"] == "yes"

	-- Find all parts between boundaries
	local pos = 1
	while true do
		-- Find next boundary
		local boundary_start, boundary_end = body_content:find(boundary_pattern, pos)
		if not boundary_start then
			break
		end

		-- Move past the boundary and newline
		pos = boundary_end + 1

		-- Skip CR/LF after boundary
		if body_content:sub(pos, pos) == "\r" then
			pos = pos + 1
		end
		if body_content:sub(pos, pos) == "\n" then
			pos = pos + 1
		end

		-- Find next boundary to get this part's content
		local next_boundary_start = body_content:find(boundary_pattern, pos)
		if not next_boundary_start then
			break
		end

		-- Extract this part (between current position and next boundary)
		local part_content = body_content:sub(pos, next_boundary_start - 1)

		-- Check if this part has a filename (is a file upload)
		local filename = part_content:match('filename="([^"]+)"')
		if not filename then
			-- Try without quotes
			filename = part_content:match("filename=([^%s;]+)")
		end

		if filename then
			-- Sanitize filename once for all logging (prevent log injection)
			local safe_filename = utils.sanitize_for_logging(filename)

			-- Validate filename for security (defense-in-depth)
			local valid, validation_err = utils.validate_filename(filename)
			if not valid then
				plugin.logger:log(ERR, "[MULTIPART] SECURITY ATTACK DETECTED - Invalid filename: " .. safe_filename)
				plugin.logger:log(ERR, "[MULTIPART] Attack type: " .. validation_err)

				-- Behavior matrix for filename injection attacks:
				-- BLOCK=yes, RESUME=yes:  Log attack, extract file with sanitized name, scan content, block at end
				-- BLOCK=yes, RESUME=no:   Block immediately (fast protection)
				-- BLOCK=no,  RESUME=yes:  Log attack, scan this file anyway, continue to other files
				-- BLOCK=no,  RESUME=no:   Log attack, scan this file anyway until first virus hit
				if block_on_filename_attack then
					if resume_on_hit then
						-- Resume mode: Extract and scan file content even with malicious filename
						-- This allows detecting BOTH filename attack AND content malware
						plugin.logger:log(ERR, "[MULTIPART] BLOCK=yes, RESUME=yes - extracting file with sanitized name to scan content, will block at end")
						filename_attack_detected = true
						-- Sanitize filename for safe disk storage (replace dangerous chars with _)
						-- Keep original filename for reporting but use sanitized version for extraction
						filename = filename:gsub("[%z/\\]", "_")
						-- Fall through to normal file processing
					else
						-- Block immediately
						plugin.logger:log(ERR, "[MULTIPART] BLOCK=yes, RESUME=no - blocking immediately")
						return false, "malicious filename detected: " .. validation_err .. " (filename: " .. safe_filename .. ")", nil
					end
				else
					-- BLOCK=no: Log the attack but continue processing this file
					-- The file will still be scanned for actual malware content
					plugin.logger:log(ERR, "[MULTIPART] BLOCK=no - logging attack but continuing to scan file content")
					filename_attack_detected = true
					-- Fall through to normal file processing (no skip, no return)
				end
			end

			part_count = part_count + 1
			plugin:log_debug("[MULTIPART] Found file part #" .. part_count .. ": " .. safe_filename)

			-- Extract content-type if present
			local file_content_type = part_content:match("[Cc]ontent%-[Tt]ype:%s*([^%s\r\n]+)")

			-- Find end of headers (double newline)
			local content_start = part_content:find("\r\n\r\n")
			if content_start then
				content_start = content_start + 4
			else
				content_start = part_content:find("\n\n")
				if content_start then
					content_start = content_start + 2
				else
					plugin.logger:log(ERR, "[MULTIPART] Could not find end of headers for file: " .. safe_filename)
					goto continue
				end
			end

			-- Extract file content (trim trailing CR/LF before boundary)
			local file_content = part_content:sub(content_start)
			-- Remove trailing CRLF or LF
			file_content = file_content:gsub("\r\n$", ""):gsub("\n$", "")

			-- Write to temporary file
			local temp_path = os.tmpname()
			local temp_file, temp_err = io.open(temp_path, "wb")
			if not temp_file then
				plugin.logger:log(ERR, "[MULTIPART] Failed to create temp file for " .. safe_filename .. ": " .. (temp_err or "unknown"))
				goto continue
			end

			temp_file:write(file_content)
			temp_file:close()

			table.insert(files, {
				filepath = temp_path,
				filename = filename,
				size = #file_content,
				content_type = file_content_type or "application/octet-stream"
			})

			plugin.logger:log(ERR, "[MULTIPART] Extracted file: " .. safe_filename .. " (" .. #file_content .. " bytes) -> " .. temp_path)
		end

		::continue::
		pos = next_boundary_start
	end

	if #files == 0 and not filename_attack_detected then
		return false, "no file uploads found in multipart body", nil
	end

	plugin.logger:log(ERR, "[MULTIPART] Parsed " .. #files .. " file(s) from multipart body")

	-- Return with attack indicator if filename attacks were detected
	if filename_attack_detected then
		plugin.logger:log(ERR, "[MULTIPART] Filename injection attack(s) detected - will block request after full scan")
		return true, files, "filename_attack_detected"
	end

	return true, files, nil
end

-- ============================================================================
-- FILE CONTENT EXTRACTION
-- ============================================================================

-- Extract actual file content from multipart body.
-- The temp file contains the entire multipart/form-data body including headers.
-- This function extracts just the file content from the part with filename=.
--
-- SECURITY WARNING: This function searches for the filename pattern in the body
-- but does NOT validate the filename itself. Filename validation MUST be done
-- by the caller (see utils.validate_filename() and parse_multipart_files()).
-- NEVER trust attacker-provided filenames for filesystem operations!
--
-- Returns success boolean and extracted content or error message.
function file_ops.extract_file_content(plugin, file_path)
	local file, err = io.open(file_path, "rb")
	if not file then
		return false, "failed to open file: " .. (err or "unknown")
	end

	-- Read the entire file (should be reasonable size for uploads)
	local content = file:read("*a")
	file:close()

	if not content or content == "" then
		return false, "file is empty"
	end

	-- Find the part that contains filename= (the actual file upload)
	local filename_pos = content:find('filename="')
	if not filename_pos then
		-- Try without quotes
		filename_pos = content:find("filename=")
		if not filename_pos then
			plugin.logger:log(ERR, "could not find filename in multipart body")
			return false, "no file upload found in multipart body"
		end
	end

	-- Find the end of headers for this part (double newline after filename line)
	local content_start = content:find("\r\n\r\n", filename_pos)
	if not content_start then
		-- Try just \n\n (some clients use this)
		content_start = content:find("\n\n", filename_pos)
		if not content_start then
			plugin.logger:log(ERR, "could not find end of file part headers")
			return false, "invalid multipart format"
		end
		content_start = content_start + 2  -- Skip \n\n
	else
		content_start = content_start + 4  -- Skip \r\n\r\n
	end

	-- Find the ending boundary AFTER the file content (starts with --)
	local boundary_pattern = "\r\n%-%-"
	local content_end = content:find(boundary_pattern, content_start)
	if not content_end then
		-- Try just \n--
		boundary_pattern = "\n%-%-"
		content_end = content:find(boundary_pattern, content_start)
		if not content_end then
			plugin.logger:log(ERR, "could not find ending multipart boundary")
			return false, "invalid multipart format"
		end
	end

	-- Extract just the file content (between headers and ending boundary)
	local file_content = content:sub(content_start, content_end - 1)

	plugin:log_debug("Extracted file content: " .. #file_content .. " bytes from " .. #content .. " bytes total")

	return true, file_content
end

-- Calculate SHA256 checksum of a file.
-- Takes file path, returns success boolean and checksum or error message.
-- For multipart uploads, extracts the actual file content first.
-- Returns special value "empty_file" for 0-byte files to skip calculation.
function file_ops.calculate_sha256(plugin, file_path)
	-- Extract actual file content from multipart body
	local ok, file_content = file_ops.extract_file_content(plugin, file_path)
	if not ok then
		plugin.logger:log(ERR, "failed to extract file content: " .. file_content)
		-- Fallback: hash the entire file as-is
		local file, err = io.open(file_path, "rb")
		if not file then
			return false, "failed to open file: " .. (err or "unknown")
		end

		-- Validate file size before reading to prevent DoS (Medium severity issue #17)
		local size = file:seek("end")
		file:seek("set", 0)

		local MAX_FALLBACK_SIZE = 100 * 1024 * 1024  -- 100MB
		if size > MAX_FALLBACK_SIZE then
			file:close()
			return false, "file too large for fallback SHA256 calculation (max 100MB)"
		end

		local sha = sha256:new()
		if not sha then
			file:close()
			return false, "failed to create SHA256 instance"
		end

		while true do
			local chunk = file:read(8192)
			if not chunk then
				break
			end
			sha:update(chunk)
		end

		file:close()
		local checksum = to_hex(sha:final())
		plugin.logger:log(ERR, "calculated SHA256 of entire multipart body (fallback): " .. checksum)
		return true, checksum
	end

	-- Check if file is empty (0 bytes) - skip SHA256 calculation
	if #file_content == 0 then
		plugin.logger:log(ERR, "file is 0 bytes (empty), skipping SHA256 calculation")
		return true, "empty_file"
	end

	-- Calculate SHA256 of extracted file content
	local sha = sha256:new()
	if not sha then
		return false, "failed to create SHA256 instance"
	end

	sha:update(file_content)
	local checksum = to_hex(sha:final())

	plugin.logger:log(ERR, "calculated SHA256 of extracted file content (" .. #file_content .. " bytes): " .. checksum)
	return true, checksum
end

-- ============================================================================
-- FILE CLEANUP OPERATIONS
-- ============================================================================

-- Delete temporary file after scanning.
-- Returns success boolean and error message if failed.
function file_ops.cleanup_file(plugin, file_path)
	if not file_path or file_path == "" then
		return false, "invalid file path"
	end

	-- Use EAFP pattern to avoid race condition (Medium severity issue #18)
	-- Try to remove first, handle error if file doesn't exist
	local ok, err = os.remove(file_path)
	if not ok then
		-- Check if error is "file not found" (already cleaned up, possibly by security software)
		if err and (err:match("No such file") or err:match("cannot find") or err:match("not exist")) then
			plugin.logger:log(NOTICE, "temp file already removed (possibly by security software): " .. file_path)
			return true
		end
		-- Other error (permissions, etc.)
		return false, err or "unknown error"
	end

	plugin.logger:log(NOTICE, "cleaned up temp file: " .. file_path)
	return true
end

-- Clean up orphaned temporary files older than specified age.
-- Scans temp directory and deletes files older than max_age seconds.
-- Returns success boolean and error message if failed.
function file_ops.cleanup_orphaned_files(plugin, max_age)
	-- Validate max_age to prevent command injection (CWE-78)
	local max_age_num = tonumber(max_age)
	if not max_age_num or max_age_num <= 0 or max_age_num > 86400 then
		return false, "invalid max_age value (must be positive number <= 86400)"
	end

	-- Use default nginx temp path for BunkerWeb
	local temp_path = "/var/tmp/bunkerweb/client_temp"

	local find_cmd = string.format(
		"find %s -type f -mmin +%d 2>/dev/null",
		temp_path,
		math.floor(max_age_num / 60)
	)

	local handle = io.popen(find_cmd)
	if not handle then
		return false, "failed to execute find command"
	end

	local cleaned_count = 0
	local error_count = 0

	for file_path in handle:lines() do
		local ok, err = os.remove(file_path)
		if ok then
			cleaned_count = cleaned_count + 1
		else
			-- Check if error is "file not found" (already deleted by security software)
			if err and (err:match("No such file") or err:match("cannot find")) then
				-- File already removed, count as cleaned
				cleaned_count = cleaned_count + 1
			else
				-- Actual error
				error_count = error_count + 1
				plugin.logger:log(
					WARN,
					"failed to remove orphaned file " .. file_path .. ": " .. (err or "unknown")
				)
			end
		end
	end

	handle:close()

	if cleaned_count > 0 then
		plugin.logger:log(
			NOTICE,
			"cleaned up " .. cleaned_count .. " orphaned temp files from " .. temp_path
		)
	end

	return true
end

-- ============================================================================
-- MALWARE SAMPLE SHARING
-- Note: This function has dependencies on VirusTotal module
-- It will be called with virustotal module passed as parameter
-- ============================================================================

-- Share detected malware file with threat intelligence platforms.
-- Uploads unknown malware to VirusTotal for community threat intelligence.
-- Returns success boolean and error message if failed.
function file_ops.share_detected_file(plugin, file_path, checksum, detector_name, virustotal)
	-- Check if file sharing is enabled
	if plugin.variables["MALWARE_SCAN_SHARE_FILES"] ~= "yes" then
		plugin:log_debug("File sharing disabled, not uploading detected malware")
		return true
	end

	-- Check if VirusTotal is enabled for sharing
	if plugin.variables["MALWARE_SCAN_API_USE_VIRUSTOTAL"] ~= "yes" then
		plugin.logger:log(ERR, "File sharing enabled but VirusTotal not configured - cannot share detected file")
		return true
	end

	-- Verify virustotal module is provided
	if not virustotal then
		plugin.logger:log(ERR, "[SHARE] VirusTotal module not loaded - cannot share detected file")
		return true
	end

	plugin.logger:log(ERR, "[SHARE] File detected by " .. detector_name .. ", checking if already known to VirusTotal")

	-- Check if file is already known to VirusTotal
	local vt_ok, vt_found, vt_response = virustotal.virustotal_request(plugin, "/files/" .. checksum)
	if not vt_ok then
		plugin.logger:log(ERR, "[SHARE] VirusTotal check failed: " .. vt_found .. " - cannot determine if file should be shared")
		return true
	end

	if vt_found then
		plugin.logger:log(ERR, "[SHARE] File already known to VirusTotal (detected by " .. detector_name .. ") - skipping upload")
		return true
	end

	-- File is unknown to VirusTotal, upload it
	plugin.logger:log(ERR, "[SHARE] File unknown to VirusTotal, uploading for threat intelligence (detected by " .. detector_name .. ")")
	local upload_ok, analysis_id, file_size = virustotal.virustotal_upload_file(plugin, file_path)

	if not upload_ok then
		plugin.logger:log(ERR, "[SHARE] Failed to upload file to VirusTotal: " .. analysis_id)
		return false, analysis_id
	end

	plugin.logger:log(ERR, "[SHARE] File uploaded successfully (" .. file_size .. " bytes), analysis ID: " .. tostring(analysis_id))

	-- Auto-vote if enabled
	if plugin.variables["MALWARE_SCAN_API_VIRUSTOTAL_AUTO_VOTE"] == "yes" then
		plugin.logger:log(ERR, "[SHARE] Auto-voting file as malicious on VirusTotal")
		local vote_ok, vote_err = virustotal.virustotal_vote(plugin, checksum, "malicious")
		if vote_ok then
			plugin.logger:log(ERR, "[SHARE] Malicious vote submitted successfully")
		else
			plugin.logger:log(ERR, "[SHARE] Failed to submit vote: " .. vote_err)
		end
	end

	return true
end

-- ============================================================================
-- ALLOW LIST (FALSE POSITIVE HANDLING)
-- ============================================================================

-- Populate allow list cache from config and file.
-- Loads all hashes into memory cache for fast lookups.
-- Called once on first request (lazy loading).
-- @param plugin table Plugin instance
-- @return boolean, number Success status and hash count
function file_ops.populate_allowlist_cache(plugin)
	local hash_count = 0

	plugin.logger:log(ERR, "[ALLOWLIST] Populating allow list cache from configuration")

	-- Load from comma-separated config variable
	local allowlist_hashes = plugin.variables["MALWARE_SCAN_ALLOWLIST_HASHES"] or ""
	if allowlist_hashes ~= "" then
		for hash in allowlist_hashes:gmatch("[^,]+") do
			-- Trim whitespace and normalize to lowercase
			hash = hash:gsub("^%s+", ""):gsub("%s+$", ""):lower()
			-- Validate hash format (64 hex characters)
			if hash:match("^[a-f0-9]{64}$") then
				local cache_key = "plugin_malware_scan_allowlist_" .. hash
				plugin.cachestore:set(cache_key, "1", 0)  -- 0 = never expire
				hash_count = hash_count + 1
			else
				plugin.logger:log(WARN, string.format(
					"[ALLOWLIST] Invalid hash format in MALWARE_SCAN_ALLOWLIST_HASHES: %s (must be 64 hex characters)",
					hash
				))
			end
		end
		if hash_count > 0 then
			plugin.logger:log(ERR, string.format(
				"[ALLOWLIST] Loaded %d hash(es) from config variable",
				hash_count
			))
		end
	end

	-- Load from file
	local allowlist_file = plugin.variables["MALWARE_SCAN_ALLOWLIST_FILE"] or ""
	if allowlist_file ~= "" then
		local file, err = io.open(allowlist_file, "r")
		if not file then
			plugin.logger:log(ERR, string.format(
				"[ALLOWLIST] Failed to open allow list file %s: %s",
				allowlist_file, err or "unknown"
			))
		else
			local file_hash_count = 0
			for line in file:lines() do
				-- Trim whitespace
				line = line:gsub("^%s+", ""):gsub("%s+$", "")
				-- Skip empty lines and comments
				if line ~= "" and not line:match("^#") then
					-- Normalize to lowercase
					line = line:lower()
					-- Validate hash format (64 hex characters)
					if line:match("^[a-f0-9]{64}$") then
						local cache_key = "plugin_malware_scan_allowlist_" .. line
						plugin.cachestore:set(cache_key, "1", 0)  -- 0 = never expire
						file_hash_count = file_hash_count + 1
						hash_count = hash_count + 1
					else
						plugin.logger:log(WARN, string.format(
							"[ALLOWLIST] Invalid hash format in file %s: %s (must be 64 hex characters)",
							allowlist_file, line
						))
					end
				end
			end
			file:close()

			if file_hash_count > 0 then
				plugin.logger:log(ERR, string.format(
					"[ALLOWLIST] Loaded %d hash(es) from file %s",
					file_hash_count, allowlist_file
				))
			end
		end
	end

	-- Mark cache as populated
	plugin.cachestore:set("plugin_malware_scan_allowlist_populated", "1", 0)

	plugin.logger:log(ERR, string.format(
		"[ALLOWLIST] Cache population complete - %d total hash(es) loaded",
		hash_count
	))

	return true, hash_count
end

-- Clear allow list cache (called on service reload).
-- @param plugin table Plugin instance
function file_ops.clear_allowlist_cache(plugin)
	plugin.logger:log(ERR, "[ALLOWLIST] Clearing allow list cache for reload")

	-- Clear the populated flag
	plugin.cachestore:delete("plugin_malware_scan_allowlist_populated")

	-- Note: Individual hash entries will be overwritten on next population
	-- No need to iterate and delete them all (performance optimization)

	return true
end

-- Check if allow list cache is populated.
-- @param plugin table Plugin instance
-- @return boolean True if cache is populated
function file_ops.is_allowlist_cache_populated(plugin)
	local populated = plugin.cachestore:get("plugin_malware_scan_allowlist_populated")
	return populated == "1"
end

-- Check if a SHA256 hash is in the allow list.
-- Uses cached allow list for performance (populated on first request).
-- Falls back to direct file/config reading if cache is not available.
-- @param plugin table Plugin instance
-- @param checksum string SHA256 hash to check
-- @return boolean True if hash is in allow list, false otherwise
function file_ops.is_hash_allowlisted(plugin, checksum)
	if not checksum or checksum == "" or checksum == "empty_file" then
		return false
	end

	-- Normalize checksum to lowercase for comparison
	checksum = checksum:lower()

	-- Ensure allow list cache is populated (lazy loading on first request)
	if not file_ops.is_allowlist_cache_populated(plugin) then
		plugin:log_debug("[ALLOWLIST] Cache not populated, loading allow list into cache")
		file_ops.populate_allowlist_cache(plugin)
	end

	-- Fast path: Check cache for hash
	local cache_key = "plugin_malware_scan_allowlist_" .. checksum
	local cached = plugin.cachestore:get(cache_key)
	if cached == "1" then
		plugin:log_debug(string.format(
			"[ALLOWLIST] File hash matches allow list (cached): %s",
			checksum
		))
		return true
	end

	-- Not in allow list
	return false
end

-- Return module
return file_ops
