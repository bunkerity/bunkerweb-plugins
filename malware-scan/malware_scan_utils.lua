-- BunkerWeb Malware Scan - Utility Functions
-- Common utility functions for validation, sanitization, and type checking

local utils = {}

-- Module version
utils.VERSION = "0.8.0"

-- ============================================================================
-- TYPE ALIASES (BunkerWeb Variable Definition Types)
-- ============================================================================
-- These type aliases represent BunkerWeb variable configuration types
-- from plugin.json. They're used in type annotations for validation functions.

---@alias Input any
---@alias Default any
---@alias Minimum number
---@alias Maximum number
---@alias Variable string
---@alias First number
---@alias Second number
---@alias Numerator number
---@alias Denominator number

-- ============================================================================
-- NUMERICAL VALIDATION
-- ============================================================================

-- Validate and sanitize a numerical value.
-- Ensures value is a positive number within optional min/max bounds.
-- Returns sanitized number or default value if invalid.
--
--- @overload fun(value: Input, default: Default): number
--- @overload fun(value: Input, default: Default, min: Minimum): number
--- @overload fun(value: Input, default: Default, min: Minimum, max: Maximum): number
--- @param value Input value to validate (any type)
--- @param default Default value if validation fails
--- @param min Minimum allowed value (optional)
--- @param max Maximum allowed value (optional)
--- @param name Variable name for error messages (optional)
--- @return number result Validated number, or default if invalid
function utils.validate_number(value, default, min, max, name)
	-- Convert to number if string
	local num = tonumber(value)
	
	-- Check if conversion succeeded
	if not num then
		return default
	end
	
	-- Check for NaN or infinity
	if num ~= num or num == math.huge or num == -math.huge then
		return default
	end
	
	-- Check minimum bound
	if min and num < min then
		return default
	end
	
	-- Check maximum bound
	if max and num > max then
		return default
	end
	
	return num
end

-- Validate a positive integer (whole number > 0).
-- Returns sanitized integer or default value if invalid.
--
--- @param value Input value to validate
--- @param default Default value if validation fails
--- @param max Maximum allowed value (optional)
--- @param name Variable name for error messages (optional)
--- @return number result Validated positive integer, or default
function utils.validate_positive_integer(value, default, max, name)
	local num = utils.validate_number(value, default, 1, max, name)
	
	-- Ensure it's a whole number
	if num ~= math.floor(num) then
		return default
	end
	
	return num
end

-- Validate a non-negative integer (whole number >= 0).
-- Returns sanitized integer or default value if invalid.
--
--- @param value Input value to validate
--- @param default Default value if validation fails
--- @param max Maximum allowed value (optional)
--- @param name Variable name for error messages (optional)
--- @return number result Validated non-negative integer, or default
function utils.validate_nonnegative_integer(value, default, max, name)
	local num = utils.validate_number(value, default, 0, max, name)
	
	-- Ensure it's a whole number
	if num ~= math.floor(num) then
		return default
	end
	
	return num
end

-- Validate file size (positive integer with reasonable upper bound).
-- Returns sanitized file size or 0 if invalid.
--
--- @param size Input size value
--- @param max_size Maximum allowed size (default: 10GB)
--- @return number result Validated file size in bytes (>= 0)
function utils.validate_file_size(size, max_size)
	max_size = max_size or (10 * 1024 * 1024 * 1024)  -- Default: 10GB
	return utils.validate_nonnegative_integer(size, 0, max_size, "file_size")
end

-- Validate disk space (positive integer).
-- Returns sanitized space value or 0 if invalid.
--
--- @param space Input space value
--- @return number result Validated disk space in bytes (>= 0)
function utils.validate_disk_space(space)
	-- Allow up to 1PB (petabyte) as upper bound
	local max_space = 1024 * 1024 * 1024 * 1024 * 1024
	return utils.validate_nonnegative_integer(space, 0, max_space, "disk_space")
end

-- Validate TTL (time-to-live) value in seconds.
-- Returns sanitized TTL or default if invalid.
--
--- @param ttl Input TTL value
--- @param default Default TTL if validation fails (default: 86400 = 1 day)
--- @param max_ttl Maximum allowed TTL (default: 31536000 = 1 year)
--- @return number result Validated TTL in seconds
function utils.validate_ttl(ttl, default, max_ttl)
	default = default or 86400  -- 1 day
	max_ttl = max_ttl or 31536000  -- 1 year
	return utils.validate_positive_integer(ttl, default, max_ttl, "ttl")
end

-- Validate timeout value in milliseconds.
-- Returns sanitized timeout or default if invalid.
--
--- @param timeout Input timeout value
--- @param default Default timeout if validation fails (default: 30000 = 30 seconds)
--- @param max_timeout Maximum allowed timeout (default: 300000 = 5 minutes)
--- @return number result Validated timeout in milliseconds
function utils.validate_timeout(timeout, default, max_timeout)
	default = default or 30000  -- 30 seconds
	max_timeout = max_timeout or 300000  -- 5 minutes
	return utils.validate_positive_integer(timeout, default, max_timeout, "timeout")
end

-- Validate retry count.
-- Returns sanitized retry count or default if invalid.
--
--- @param retries Input retry count
--- @param default Default retry count if validation fails (default: 3)
--- @param max_retries Maximum allowed retries (default: 10)
--- @return number result Validated retry count
function utils.validate_retry_count(retries, default, max_retries)
	default = default or 3
	max_retries = max_retries or 10
	return utils.validate_nonnegative_integer(retries, default, max_retries, "retries")
end

-- Validate port number.
-- Returns sanitized port or default if invalid.
--
--- @param port Input port number
--- @param default Default port if validation fails
--- @return number result Validated port number (1-65535)
function utils.validate_port(port, default)
	return utils.validate_positive_integer(port, default, 65535, "port")
end

-- ============================================================================
-- SAFE ARITHMETIC OPERATIONS
-- ============================================================================

-- Safe addition with overflow protection.
-- Returns sum or max value if overflow would occur.
--
--- @overload fun(a: First, b: Second): number
--- @param a First number
--- @param b Second number
--- @param max Maximum allowed result (optional)
--- @return number result Sum of a + b, capped at max
function utils.safe_add(a, b, max)
	a = utils.validate_number(a, 0)
	b = utils.validate_number(b, 0)
	
	local sum = a + b
	
	-- Check for overflow or infinity
	if sum == math.huge or sum ~= sum then
		return max or a  -- Return max or original value
	end
	
	-- Cap at maximum if specified
	if max and sum > max then
		return max
	end
	
	return sum
end

-- Safe multiplication with overflow protection.
-- Returns product or max value if overflow would occur.
--
--- @overload fun(a: First, b: Second): number
--- @param a First number
--- @param b Second number
--- @param max Maximum allowed result (optional)
--- @return number result Product of a * b, capped at max
function utils.safe_multiply(a, b, max)
	a = utils.validate_number(a, 0)
	b = utils.validate_number(b, 0)
	
	local product = a * b
	
	-- Check for overflow or infinity
	if product == math.huge or product ~= product then
		return max or a  -- Return max or original value
	end
	
	-- Cap at maximum if specified
	if max and product > max then
		return max
	end
	
	return product
end

-- Safe division with zero-check.
-- Returns quotient or default if division by zero.
--
--- @overload fun(a: Numerator, b: Denominator): number
--- @param a Numerator
--- @param b Denominator
--- @param default Default value if b is zero (default: 0)
--- @return number result Quotient of a / b, or default if b is zero
function utils.safe_divide(a, b, default)
	a = utils.validate_number(a, 0)
	b = utils.validate_number(b, 0)
	default = default or 0
	
	-- Prevent division by zero
	if b == 0 then
		return default
	end
	
	local quotient = a / b
	
	-- Check for infinity or NaN
	if quotient == math.huge or quotient == -math.huge or quotient ~= quotient then
		return default
	end
	
	return quotient
end

-- ============================================================================
-- PATH SANITIZATION (Command Injection Prevention)
-- ============================================================================

--- Validate path for shell command safety.
-- Checks if path contains only safe characters to prevent command injection.
-- Allows: alphanumeric, slash, dash, underscore, dot, space
-- Blocks: semicolons, pipes, backticks, $(), redirects, etc.
---
--- @param path string Path to validate
--- @return boolean, string|nil
function utils.validate_safe_path(path)
	if not path or path == "" then
		return false, "path is empty"
	end

	-- Check for dangerous characters that could enable command injection
	-- Allow: alphanumeric, /, -, _, ., and space
	-- Block: ; | & $ ` ( ) < > \ " ' * ? [ ] { } ! \n \r
	if path:match("[^%w%/%-%_%. ]") then
		return false, "path contains unsafe characters (potential command injection)"
	end

	-- Check for path traversal attempts
	if path:match("%.%.") then
		return false, "path contains '..' (potential path traversal)"
	end

	-- Check for suspicious patterns
	if path:match("%$%(") or path:match("`") then
		return false, "path contains command substitution characters"
	end

	return true, nil
end

--- Shell-escape a path for safe use in commands.
-- Wraps path in single quotes and escapes any single quotes within.
-- This is the most secure way to pass paths to shell commands.
---
--- @param path string Path to escape
--- @return string escaped_path
function utils.shell_escape_path(path)
	if not path then
		return "''"
	end

	-- Replace single quotes with '\'' (end quote, escaped quote, start quote)
	local escaped = path:gsub("'", "'\\''")

	-- Wrap in single quotes
	return "'" .. escaped .. "'"
end

--- Validate and escape path for shell commands.
-- Combines validation and escaping for safe shell command usage.
-- Returns escaped path or nil with error message.
---
--- @param path string Path to validate and escape
--- @return string|nil, string|nil
function utils.validate_and_escape_path(path)
	local valid, err = utils.validate_safe_path(path)
	if not valid then
		return nil, err
	end

	return utils.shell_escape_path(path), nil
end

---
--- Sanitize string for safe logging.
--- Prevents log injection attacks by escaping control characters
--- and truncating long strings.
---
--- @param str string String to sanitize
--- @return string Sanitized string safe for logging
function utils.log_sanitize(str)
	if not str or str == "" then
		return ""
	end

	-- Convert to string if not already
	local sanitized = tostring(str)

	-- Escape control characters (CR, LF, TAB, NULL, etc.)
	sanitized = sanitized:gsub("[\r\n\t%z\1-\31]", function(c)
		return string.format("\\x%02x", string.byte(c))
	end)

	-- Truncate to prevent log flooding
	if #sanitized > 200 then
		sanitized = sanitized:sub(1, 197) .. "..."
	end

	return sanitized
end

---
--- Validate filename for security.
--- Checks for path traversal, null bytes, and other injection attacks.
---
--- @param filename string Filename to validate
--- @return boolean, string|nil
function utils.file_validate_name(filename)
	if not filename or filename == "" then
		return false, "empty filename"
	end

	-- Check for path traversal attempts
	if filename:match("%.%.") then
		return false, "path traversal attempt (..)"
	end

	-- Check for absolute paths
	if filename:match("^/") or filename:match("^\\") then
		return false, "absolute path not allowed"
	end

	-- Check for null bytes
	if filename:match("%z") then
		return false, "null byte in filename"
	end

	-- Check for other control characters
	if filename:match("[\1-\31]") then
		return false, "control characters in filename"
	end

	-- Check length (max 255 for most filesystems)
	if #filename > 255 then
		return false, "filename too long"
	end

	return true, nil
end

-- ============================================================================
-- URL PARSING AND VALIDATION
-- ============================================================================

--- Parse and validate webhook URL.
-- Validates URL format and security (SSRF prevention, hostname validation).
-- Returns parsed components or nil with error message.
---
--- @param url string URL to parse
--- @return table|nil, string|nil
function utils.parse_webhook_url(url)
	-- Validate URL starts with http:// or https:// to prevent SSRF (CWE-918)
	if not url:match("^https?://") then
		return nil, "URL must start with http:// or https://"
	end

	local scheme, host, port, path = url:match("^(https?)://([^/:]+):?(%d*)(.*)$")

	if not scheme or not host then
		return nil, "invalid URL format"
	end

	-- Validate hostname doesn't contain suspicious characters that could enable URL injection
	-- Reject: spaces, quotes, angle brackets, percent signs (used in URL encoding attacks)
	if host:match("[%s<>\"'%%]") then
		return nil, "invalid characters in hostname"
	end

	-- Validate port is in valid range (1-65535)
	if port ~= "" then
		local port_num = tonumber(port)
		if not port_num or port_num < 1 or port_num > 65535 then
			return nil, "invalid port number (must be 1-65535)"
		end
		port = tostring(port_num)
	end

	-- Default ports
	if port == "" then
		port = (scheme == "https") and "443" or "80"
	end

	-- Default path
	if path == "" then
		path = "/"
	end

	return {
		scheme = scheme,
		host = host,
		port = tonumber(port),
		path = path,
		ssl = (scheme == "https")
	}, nil
end

-- ============================================================================
-- REDIS HASH BUCKETING
-- ============================================================================

--- Get bucketed Redis key for SHA256 hash.
-- Distributes 1M+ hashes across 16 bucket keys (0-9, A-F) for faster lookups.
-- Uses first character of SHA256 hash for bucketing.
---
--- @param sha256 string SHA256 hash (first character used for bucketing)
--- @return string Bucketed hash key like "malware_scan:hashes:A"
function utils.get_hash_bucket(sha256)
	if not sha256 or #sha256 == 0 then
		return "malware_scan:hashes:0"
	end

	-- Get first character of SHA256 (uppercase for consistency)
	local first_char = sha256:sub(1, 1):upper()

	-- Create bucket key with first character suffix
	return "malware_scan:hashes:" .. first_char
end

--- Get all 16 hash bucket keys.
-- Returns array of all bucket keys for full database operations.
---
--- @return table Array of all 16 bucket keys
function utils.get_all_hash_buckets()
	local buckets = {}
	-- Add numeric buckets (0-9)
	for i = 0, 9 do
		table.insert(buckets, "malware_scan:hashes:" .. i)
	end
	-- Add hex buckets (A-F)
	for i = 10, 15 do
		table.insert(buckets, "malware_scan:hashes:" .. string.char(65 + i - 10))  -- 65 = 'A'
	end
	return buckets
end

-- ============================================================================
-- DATA MASKING FOR SECURITY
-- ============================================================================

--- Mask sensitive data (API keys, webhook URLs, tokens) for safe logging.
--- Prevents accidental exposure of credentials in logs, error messages, or debug output.
--- Only shows full values if unmask_setting matches the specific phrase "I want to expose everything, I know what I'm doing".
---
--- Masking rules:
--- - Empty or nil values: Returns empty string ""
--- - Short values (<=8 chars): Returns "***"
--- - Long values (>8 chars): Shows first 4 characters + "***" (e.g., "abc1***")
--- - Unmask override: If unmask_setting == "I want to expose everything, I know what I'm doing", returns original value
---
--- Security note: Never log masked values without verifying unmask_setting is not set in production.
---
--- Example:
---   utils.data_mask_sensitive("secret_key_12345", nil) → "secr***"
---   utils.data_mask_sensitive("abc", nil) → "***"
---   utils.data_mask_sensitive("secret", "I want to expose everything, I know what I'm doing") → "secret"
---
--- @param value string|nil The sensitive value to mask (API key, token, webhook URL, etc.)
--- @param unmask_setting string|nil The MALWARE_SCAN_UNMASK_KEYS setting (only specific phrase disables masking)
--- @return string Masked string or original value if unmasking is enabled
function utils.data_mask_sensitive(value, unmask_setting)
	-- Check for unmask override (exact phrase match required)
	if unmask_setting == "I want to expose everything, I know what I'm doing" then
		return value or ""
	end

	-- Mask empty or nil values
	if not value or value == "" then
		return ""
	end

	-- Simple masking: show first 4 chars + "***" for long strings, "***" for short strings
	if #value > 8 then
		return value:sub(1, 4) .. "***"
	end
	return "***"
end

-- Return module
return utils
