-- Webhook Notification Module for BunkerWeb Malware Scanner
-- Supports Microsoft Teams and Discord webhooks for malware detection alerts
-- Handles rate limiting, retry logic, and automatic webhook type detection

local _M = {}

local cjson = require("cjson.safe")
local http = require("resty.http")

-- Parse webhook URL into components for manual HTTP connection
-- This handles complex URLs that resty.http's request_uri() may have issues with
-- @param url string The webhook URL to parse
-- @return table URL components (scheme, host, port, path, ssl) or nil, error
local function parse_url(url)
	local scheme, host, port, path = url:match("^(https?)://([^/:]+):?(%d*)(.*)$")

	if not scheme or not host then
		return nil, "invalid URL format"
	end

	-- Default ports
	if port == "" then
		port = (scheme == "https") and "443" or "80"
	end

	-- Default path
	if path == "" then
		path = "/"
	end

	return {
		scheme = scheme,
		host = host,
		port = tonumber(port),
		path = path,
		ssl = (scheme == "https")
	}
end

-- Mask sensitive webhook URL for logging
-- Only shows full URL if MALWARE_SCAN_UNMASK_KEYS is set to the specific phrase
-- @param url string The URL to mask
-- @param plugin table Plugin instance for checking settings
-- @return string Masked or unmasked URL
local function mask_webhook_url(url, plugin)
	if not url or url == "" then
		return ""
	end

	-- Check if unmasking is explicitly enabled
	local unmask = plugin.variables["MALWARE_SCAN_UNMASK_KEYS"]
	if unmask == "I_WANT_TO_LEAK_MY_SECRETS_TO_LOG" then
		return url
	end

	-- Mask webhook URL (show protocol and domain prefix only)
	if url:match("^https?://") then
		local protocol, rest = url:match("^(https?://)(.+)$")
		if protocol then
			local domain = rest:match("^([^/]+)")
			if domain then
				-- Show protocol and domain prefix only
				local domain_prefix = domain:sub(1, math.min(#domain, 10))
				return protocol .. domain_prefix .. "***"
			end
		end
	end
	return "https://***"
end

-- Clean webhook URL by removing quotes, brackets, and whitespace
-- @param webhook_url string The URL to clean
-- @param plugin table Plugin instance for logging
-- @return string Cleaned URL
local function clean_webhook_url(webhook_url, plugin)
	-- Remove common wrapping characters
	webhook_url = webhook_url:gsub("^['\"%[]", ""):gsub("['\"%]]$", "")
	-- Remove whitespace
	webhook_url = webhook_url:gsub("^%s+", ""):gsub("%s+$", "")

	plugin.logger:log(ngx.ERR, "[WEBHOOK] Cleaned URL: " .. mask_webhook_url(webhook_url, plugin))
	return webhook_url
end

-- Build JSON payload for webhook notification
-- Auto-detects webhook type (Discord, Power Automate, or Teams) from URL
-- @param webhook_url string The webhook URL to send to
-- @param checksum string SHA256 hash of the malicious file
-- @param detections table Scanner detection results {scanner_name = detection_info}
-- @param client_ip string Client IP address
-- @param server_name string Server/domain name
-- @param request_uri string Request URI path
-- @return string JSON payload
local function build_json_payload(webhook_url, checksum, detections, client_ip, server_name, request_uri)
	-- Build detection summary and separate cached vs fresh results
	local detection_list = {}
	local scanners_detected = {}
	local cached_scanners = {}
	local fresh_scanners = {}

	for scanner, detection in pairs(detections or {}) do
		-- Check if this is a cached result
		if scanner:match("%(cached%)") then
			local base_name = scanner:gsub(" %(cached%)", "")
			table.insert(cached_scanners, base_name)
		else
			table.insert(fresh_scanners, scanner)
		end
		table.insert(scanners_detected, scanner)
		table.insert(detection_list, "**" .. scanner .. "**: " .. detection)
	end

	local hit_rate = table.concat(scanners_detected, ", ")
	if hit_rate == "" then
		hit_rate = "unknown"
	end

	-- Build cached info string
	local cached_info = nil
	if #cached_scanners > 0 then
		cached_info = table.concat(cached_scanners, ", ")
	end

	-- Detect webhook type from URL
	local is_discord = webhook_url:find("discord%.com/api/webhooks") or webhook_url:find("discordapp%.com/api/webhooks")
	local is_power_automate = webhook_url:find("powerplatform%.com") or webhook_url:find("powerautomate")

	local card

	if is_discord then
		-- Discord embed format
		local fields = {
			{name = "Client IP", value = client_ip, inline = true},
			{name = "Destination Domain", value = server_name, inline = true},
			{name = "Request URI", value = request_uri, inline = false},
			{name = "SHA256 Checksum", value = checksum or "not available", inline = false},
			{name = "Detected By", value = hit_rate, inline = false}
		}

		-- Add cached results indicator if any
		if cached_info then
			table.insert(fields, {
				name = "âš¡ Cached Results",
				value = cached_info .. " (from cache, not re-scanned)",
				inline = false
			})
		end

		-- Add detection details
		for scanner, detection in pairs(detections or {}) do
			table.insert(fields, {
				name = scanner,
				value = detection,
				inline = false
			})
		end

		card = {
			embeds = {
				{
					title = "ðŸ›¡ï¸ MALWARE DETECTED",
					description = "BunkerWeb Malware Scanner Alert",
					color = 16711680,  -- Red color in decimal
					fields = fields,
					timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
				}
			}
		}
	elseif is_power_automate then
		-- Power Automate simple JSON format
		card = {
			title = "ðŸ›¡ï¸ MALWARE DETECTED",
			client_ip = client_ip,
			server_name = server_name,
			request_uri = request_uri,
			checksum = checksum or "not available",
			detected_by = hit_rate,
			cached_results = cached_info,
			detections = detections
		}
	else
		-- Microsoft Teams MessageCard format (Incoming Webhook)
		local facts = {
			{name = "Client IP", value = client_ip},
			{name = "Destination Domain", value = server_name},
			{name = "Request URI", value = request_uri},
			{name = "SHA256 Checksum", value = checksum or "not available"},
			{name = "Detected By", value = hit_rate}
		}

		-- Add cached results indicator if any
		if cached_info then
			table.insert(facts, {name = "âš¡ Cached Results", value = cached_info .. " (from cache, not re-scanned)"})
		end

		card = {
			["@type"] = "MessageCard",
			["@context"] = "https://schema.org/extensions",
			themeColor = "FF0000",  -- Red color for alerts
			summary = "Malware Detected",
			sections = {
				{
					activityTitle = "ðŸ›¡ï¸ MALWARE DETECTED",
					activitySubtitle = "BunkerWeb Malware Scanner Alert",
					facts = facts,
					markdown = true
				}
			}
		}

		-- Add detection details section if available
		if #detection_list > 0 then
			table.insert(card.sections, {
				title = "Detection Details",
				text = table.concat(detection_list, "\n\n")
			})
		end
	end

	return cjson.encode(card)
end

-- Send webhook HTTP request with retry logic
-- @param url_parts table Parsed URL components
-- @param json_body string JSON payload to send
-- @param plugin table Plugin instance for logging
-- @param webhook_type string Type of webhook ("Teams" or "Discord") for logging
-- @return boolean Success status
local function send_webhook_request(url_parts, json_body, plugin, webhook_type)
	-- Retry configuration
	local max_retries = 3
	local base_delay = 1  -- 1 second base delay
	local max_delay = 20  -- 20 seconds max delay

	-- Transient error status codes that should be retried
	local transient_errors = {
		[412] = true,  -- Precondition Failed
		[429] = true,  -- Too Many Requests (rate limit)
		[502] = true,  -- Bad Gateway
		[504] = true,  -- Gateway Timeout
	}

	-- Retry loop with exponential backoff
	for attempt = 1, max_retries do
		local httpc = http.new()
		httpc:set_timeout(5000)  -- 5 second timeout

		-- Use manual connection for complex URLs
		local ok, err = httpc:connect(url_parts.host, url_parts.port)
		if not ok then
			plugin.logger:log(ngx.ERR, "[WEBHOOK] " .. webhook_type .. " connection failed: " .. (err or "unknown"))
			if attempt < max_retries then
				local delay = math.min(math.pow(2, attempt - 1) * base_delay, max_delay)
				plugin.logger:log(ngx.NOTICE, "[WEBHOOK] " .. webhook_type .. " retrying in " .. delay .. "s...")
				ngx.sleep(delay)
			end
		else
			-- Set SSL if needed
			if url_parts.ssl then
				local session, err = httpc:ssl_handshake(nil, url_parts.host, false)
				if not session then
					plugin.logger:log(ngx.ERR, "[WEBHOOK] " .. webhook_type .. " SSL handshake failed: " .. (err or "unknown"))
					httpc:close()
					if attempt < max_retries then
						local delay = math.min(math.pow(2, attempt - 1) * base_delay, max_delay)
						ngx.sleep(delay)
					end
					goto continue
				end
			end

			-- Send request
			local res, err = httpc:request({
				method = "POST",
				path = url_parts.path,
				headers = {
					["Host"] = url_parts.host,
					["Content-Type"] = "application/json",
					["Content-Length"] = tostring(#json_body)
				},
				body = json_body
			})

			httpc:close()

			-- Success case
			if res and res.status >= 200 and res.status < 300 then
				if attempt > 1 then
					plugin.logger:log(ngx.NOTICE, "[WEBHOOK] " .. webhook_type .. " notification sent successfully after " .. attempt .. " attempts")
				else
					plugin.logger:log(ngx.NOTICE, "[WEBHOOK] " .. webhook_type .. " notification sent successfully")
				end
				return true
			end

			-- Determine if error is transient and should be retried
			local should_retry = false
			local error_msg = ""

			if not res then
				-- Connection error or timeout
				should_retry = (attempt < max_retries)
				error_msg = "connection error: " .. (err or "unknown error")
			elseif transient_errors[res.status] then
				-- Transient HTTP error
				should_retry = (attempt < max_retries)
				error_msg = "HTTP " .. res.status .. ": " .. (res.body or "no body")
			else
				-- Non-retryable error (4xx other than 412/429, or 5xx other than 502/504)
				should_retry = false
				error_msg = "HTTP " .. res.status .. ": " .. (res.body or "no body")
			end

			-- Log the error
			if should_retry then
				plugin.logger:log(ngx.NOTICE, "[WEBHOOK] " .. webhook_type .. " attempt " .. attempt .. "/" .. max_retries .. " failed (" .. error_msg .. "), retrying...")
			else
				plugin.logger:log(ngx.ERR, "[WEBHOOK] " .. webhook_type .. " failed: " .. error_msg)
				return false
			end

			-- Calculate exponential backoff delay with jitter (only if retrying)
			if should_retry and attempt < max_retries then
				local delay = math.min(math.pow(2, attempt - 1) * base_delay, max_delay)
				-- Add random jitter (Â±20%)
				local jitter = delay * 0.2 * (math.random() * 2 - 1)
				delay = delay + jitter

				plugin.logger:log(ngx.NOTICE, "[WEBHOOK] " .. webhook_type .. " backing off for " .. string.format("%.2f", delay) .. " seconds")
				ngx.sleep(delay)
			end
		end

		::continue::
	end

	-- All retries exhausted
	plugin.logger:log(ngx.ERR, "[WEBHOOK] " .. webhook_type .. " failed after " .. max_retries .. " attempts")
	return false
end

-- Main entry point: Send notification to configured webhooks
-- Processes both Teams and Discord webhooks if configured
-- @param plugin table Plugin instance with variables and logger
-- @param checksum string SHA256 hash of the malicious file
-- @param detections table Scanner detection results {scanner_name = detection_info}
-- @return boolean Success status (true if all configured webhooks succeeded)
function _M.send_notification(plugin, checksum, detections)
	local success = true

	-- Get request information
	local client_ip = ngx.var.remote_addr or "unknown"
	local server_name = ngx.var.server_name or ngx.var.host or "unknown"
	local request_uri = plugin.ctx.bw.uri or "unknown"

	-- Process Teams webhook
	local teams_url = plugin.variables["MALWARE_SCAN_TEAMS_WEBHOOK_URL"]
	if teams_url and teams_url ~= "" and teams_url ~= "your_webhook_url" then
		plugin.logger:log(ngx.ERR, "[WEBHOOK] Processing Teams webhook")

		-- Check rate limit with hard cap at Microsoft Teams' limit (200/min)
		local TEAMS_HARD_LIMIT = 200
		local user_rate_limit = tonumber(plugin.variables["MALWARE_SCAN_TEAMS_WEBHOOK_RATE_LIMIT"]) or 6
		local rate_limit = user_rate_limit

		if user_rate_limit == 0 then
			rate_limit = TEAMS_HARD_LIMIT
		elseif user_rate_limit > TEAMS_HARD_LIMIT then
			rate_limit = TEAMS_HARD_LIMIT
			plugin.logger:log(ngx.WARN, "[WEBHOOK] Teams rate limit " .. user_rate_limit .. " exceeds maximum (" .. TEAMS_HARD_LIMIT .. "/min) - enforcing hard cap")
		end

		-- Apply rate limiting
		local cache_key = "plugin_malware_scan_teams_webhook_count"
		local ok, count = plugin.cachestore:get(cache_key)

		if ok and count then
			count = tonumber(count) or 0
			if count >= rate_limit then
				plugin.logger:log(ngx.NOTICE, "[WEBHOOK] Teams rate limit exceeded (" .. count .. "/" .. rate_limit .. " per minute) - skipping notification")
			else
				-- Increment counter
				plugin.cachestore:set(cache_key, count + 1, 60)

				-- Clean URL and parse
				teams_url = clean_webhook_url(teams_url, plugin)
				local url_parts, err = parse_url(teams_url)
				if not url_parts then
					plugin.logger:log(ngx.ERR, "[WEBHOOK] Teams URL parse failed: " .. err)
					success = false
				else
					-- Build and send
					local json_body = build_json_payload(teams_url, checksum, detections, client_ip, server_name, request_uri)
					if not send_webhook_request(url_parts, json_body, plugin, "Teams") then
						success = false
					end
				end
			end
		else
			-- Initialize counter with 60 second TTL
			plugin.cachestore:set(cache_key, 1, 60)

			-- Clean URL and parse
			teams_url = clean_webhook_url(teams_url, plugin)
			local url_parts, err = parse_url(teams_url)
			if not url_parts then
				plugin.logger:log(ngx.ERR, "[WEBHOOK] Teams URL parse failed: " .. err)
				success = false
			else
				-- Build and send
				local json_body = build_json_payload(teams_url, checksum, detections, client_ip, server_name, request_uri)
				if not send_webhook_request(url_parts, json_body, plugin, "Teams") then
					success = false
				end
			end
		end
	end

	-- Process Discord webhook
	local discord_url = plugin.variables["MALWARE_SCAN_DISCORD_WEBHOOK_URL"]
	if discord_url and discord_url ~= "" and discord_url ~= "your_webhook_url" then
		plugin.logger:log(ngx.ERR, "[WEBHOOK] Processing Discord webhook")

		-- Check rate limit with hard cap at Discord's limit (30 per 60 seconds)
		local DISCORD_HARD_LIMIT = 30
		local user_rate_limit = tonumber(plugin.variables["MALWARE_SCAN_DISCORD_WEBHOOK_RATE_LIMIT"]) or 5
		local rate_limit = user_rate_limit

		if user_rate_limit == 0 then
			rate_limit = DISCORD_HARD_LIMIT
		elseif user_rate_limit > DISCORD_HARD_LIMIT then
			rate_limit = DISCORD_HARD_LIMIT
			plugin.logger:log(ngx.WARN, "[WEBHOOK] Discord rate limit " .. user_rate_limit .. " exceeds maximum (" .. DISCORD_HARD_LIMIT .. "/60s) - enforcing hard cap")
		end

		-- Apply rate limiting (60 second window for Discord)
		local cache_key = "plugin_malware_scan_discord_webhook_count"
		local ok, count = plugin.cachestore:get(cache_key)

		if ok and count then
			count = tonumber(count) or 0
			if count >= rate_limit then
				plugin.logger:log(ngx.NOTICE, "[WEBHOOK] Discord rate limit exceeded (" .. count .. "/" .. rate_limit .. " per 60s) - skipping notification")
			else
				-- Increment counter
				plugin.cachestore:set(cache_key, count + 1, 60)

				-- Clean URL and parse
				discord_url = clean_webhook_url(discord_url, plugin)
				local url_parts, err = parse_url(discord_url)
				if not url_parts then
					plugin.logger:log(ngx.ERR, "[WEBHOOK] Discord URL parse failed: " .. err)
					success = false
				else
					-- Build and send
					local json_body = build_json_payload(discord_url, checksum, detections, client_ip, server_name, request_uri)
					if not send_webhook_request(url_parts, json_body, plugin, "Discord") then
						success = false
					end
				end
			end
		else
			-- Initialize counter with 60 second TTL
			plugin.cachestore:set(cache_key, 1, 60)

			-- Clean URL and parse
			discord_url = clean_webhook_url(discord_url, plugin)
			local url_parts, err = parse_url(discord_url)
			if not url_parts then
				plugin.logger:log(ngx.ERR, "[WEBHOOK] Discord URL parse failed: " .. err)
				success = false
			else
				-- Build and send
				local json_body = build_json_payload(discord_url, checksum, detections, client_ip, server_name, request_uri)
				if not send_webhook_request(url_parts, json_body, plugin, "Discord") then
					success = false
				end
			end
		end
	end

	return success
end

return _M
