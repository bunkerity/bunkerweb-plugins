-- Webhook Notification Module for BunkerWeb Malware Scanner
-- Supports Microsoft Teams and Discord webhooks for malware detection alerts
-- Handles rate limiting, retry logic, and automatic webhook type detection

local logger = require("malware_scan_logger")
local utils = require("malware_scan_utils")

local webhook = {}

-- Module version
webhook.VERSION = "0.8.0"

local cjson = require("cjson.safe")
local http = require("resty.http")

-- Try to load cache module for attacker tracking (optional)
local cache = pcall(require, "malware_scan_cache") and require("malware_scan_cache") or nil

-- Mask sensitive webhook URL for logging
-- Only shows full URL if MALWARE_SCAN_UNMASK_KEYS is set to the specific phrase
--- @param url string The URL to mask
--- @param plugin table Plugin instance for checking settings
--- @return string result Masked or unmasked URL
local function webhook_mask_webhook_url(url, plugin)
	if not url or url == "" then
		return ""
	end

	-- Check if unmasking is explicitly enabled
	local unmask = plugin.variables["MALWARE_SCAN_UNMASK_KEYS"]
	if unmask == "I_WANT_TO_LEAK_MY_SECRETS_TO_LOG" then
		return url
	end

	-- Mask webhook URL (show protocol and domain prefix only)
	if url:match("^https?://") then
		local protocol, rest = url:match("^(https?://)(.+)$")
		if protocol then
			local domain = rest:match("^([^/]+)")
			if domain then
				-- Show protocol and domain prefix only
				local domain_prefix = domain:sub(1, math.min(#domain, 10))
				return protocol .. domain_prefix .. "***"
			end
		end
	end
	return "https://***"
end

-- Clean webhook URL by removing quotes, brackets, and whitespace
--- @param webhook_url string The URL to clean
--- @param plugin table Plugin instance for logging
--- @return string result Cleaned URL
local function webhook_clean_webhook_url(webhook_url, plugin)
	-- Remove common wrapping characters
	webhook_url = webhook_url:gsub("^['\"%[]", ""):gsub("['\"%]]$", "")
	-- Remove whitespace
	webhook_url = webhook_url:gsub("^%s+", ""):gsub("%s+$", "")

	logger.log_error( "[WEBHOOK] Cleaned URL: " .. webhook_mask_webhook_url(webhook_url, plugin))
	return webhook_url
end

-- Parse ClamAV signature name into components
-- Format: {platform}.{category}.{name}-{signature_id}-{revision}
-- Example: Win.Trojan.Zusy-9935890-0
--- @param signature string The ClamAV signature name
--- @return table|nil parsed Parsed components table or nil if not parseable
local function webhook_parse_clamav_signature(signature)
	if not signature or signature == "" then
		return nil
	end

	-- ClamAV signature format: Platform.Category.Name-SignatureID-Revision
	local platform, category, name, sig_id, revision = signature:match("^([^%.]+)%.([^%.]+)%.([^%-]+)%-(%d+)%-(%d+)$")

	if platform and category and name and sig_id and revision then
		return {
			platform = platform,
			category = category,
			name = name,
			signature_id = sig_id,
			revision = revision,
			full_name = signature
		}
	end

	-- Fallback: just return the full name if parsing fails
	return {
		full_name = signature
	}
end

-- Truncate virus/malware name to fit in webhook messages
-- Limits virus names to 20 characters to prevent webhook message overflow
--- @param virus_name string The virus/malware name to truncate
--- @return string result Truncated virus name with ellipsis if needed
local function webhook_truncate_virus_name(virus_name)
	if not virus_name or virus_name == "" then
		return ""
	end

	local max_len = 20
	if #virus_name > max_len then
		return virus_name:sub(1, max_len - 3) .. "..."
	end
	return virus_name
end

-- Truncate string to maximum length with ellipsis if needed
--- @param str string The string to truncate
--- @param max_len number Maximum length (default 1024 for Discord/Teams limits)
--- @return string result Truncated string
local function webhook_truncate_string(str, max_len)
	max_len = max_len or 1024
	if not str then
		return ""
	end
	if #str <= max_len then
		return str
	end
	return str:sub(1, max_len - 3) .. "..."
end

-- Anonymize IP address for GDPR data minimization in webhooks
-- Masks the last octet/group to provide network-level information without exposing full IP
-- IPv4: 192.168.1.123 -> 192.168.1.x
-- IPv6: 2001:db8:1234:5678:90ab:cdef:1234:5678 -> 2001:db8:1234:5678:90ab:cdef:1234:x
--- @param ip string The IP address to anonymize
--- @return string result Anonymized IP address
local function webhook_anonymize_ip_for_webhook(ip)
	if not ip or ip == "" or ip == "unknown" then
		return ip
	end

	-- Detect IPv6 (contains colons)
	if ip:find(":") then
		-- IPv6: Replace last group with x
		-- Handle both full notation (2001:db8::1) and compressed notation
		local last_colon = ip:match("^(.+):")
		if last_colon then
			return last_colon .. ":x"
		end
		return ip  -- Fallback if parsing fails
	else
		-- IPv4: Replace last octet with x
		local first_three = ip:match("^(%d+%.%d+%.%d+)%.")
		if first_three then
			return first_three .. ".x"
		end
		return ip  -- Fallback if parsing fails
	end
end

-- Build JSON payload for webhook notification
-- Auto-detects webhook type (Discord, Power Automate, or Teams) from URL
--- @param webhook_url string The webhook URL to send to
--- @param checksum string SHA256 hash of the malicious file
--- @param detections table Scanner detection results {scanner_name = detection_info}
--- @param client_ip string Client IP address
--- @param server_name string Server/domain name
--- @param request_uri string Request URI path
--- @param hostname string Hostname of the BunkerWeb instance
--- @param worker_info string Worker process information (PID and ID)
--- @param attacker_count number Number of previous malware uploads from this IP (0 if none)
--- @param first_upload_time number Unix timestamp of first malware upload from this IP (nil if none)
--- @return string json JSON payload formatted for webhook
local function webhook_build_json_payload(webhook_url, checksum, detections, client_ip, server_name, request_uri, hostname, worker_info, attacker_count, first_upload_time)
	-- Build detection summary and separate cached vs fresh results
	local detection_list = {}
	local scanners_detected = {}
	local cached_scanners = {}
	local fresh_scanners = {}
	local signature_breakdown = {}  -- Store parsed ClamAV signatures

	for scanner, detection in pairs(detections or {}) do
		-- Check if this is a cached result
		if scanner:match("%(cached%)") then
			local base_name = scanner:gsub(" %(cached%)", "")
			table.insert(cached_scanners, base_name)
		else
			table.insert(fresh_scanners, scanner)
		end
		table.insert(scanners_detected, scanner)

		-- Truncate virus name to 20 chars to prevent webhook message overflow
		local detection_truncated = webhook_truncate_virus_name(detection)

		-- Parse ClamAV signatures for enhanced display
		local detection_display = detection_truncated
		if scanner:match("ClamAV") then
			local parsed = webhook_parse_clamav_signature(detection)
			if parsed and parsed.platform and parsed.category then
				-- Store for later use
				signature_breakdown[scanner] = parsed
				-- Enhanced display with breakdown (using truncated name)
				detection_display = string.format("%s (`%s` on `%s`)",
					detection_truncated, parsed.category, parsed.platform)
			end
		end

		-- Additional truncate for safety (Discord/Teams 1024 char limit per field)
		detection_display = webhook_truncate_string(detection_display, 900)
		table.insert(detection_list, "**" .. scanner .. "**: " .. detection_display)
	end

	local hit_rate = table.concat(scanners_detected, ", ")
	if hit_rate == "" then
		hit_rate = "unknown"
	end

	-- Build cached info string
	local cached_info = nil
	if #cached_scanners > 0 then
		cached_info = table.concat(cached_scanners, ", ")
	end

	-- Build attacker history info strings
	local attacker_info = nil
	local tracking_duration = nil
	if attacker_count and attacker_count > 0 and first_upload_time then
		-- Format first upload time (UTC)
		local first_upload_str = os.date("!%Y-%m-%d %H:%M:%S UTC", first_upload_time)

		-- Calculate tracking duration
		local current_time = os.time()
		local duration_seconds = current_time - first_upload_time
		local duration_hours = math.floor(duration_seconds / 3600)
		local duration_minutes = math.floor((duration_seconds % 3600) / 60)

		-- Format tracking duration
		if duration_hours > 24 then
			local days = math.floor(duration_hours / 24)
			local hours = duration_hours % 24
			tracking_duration = string.format("%d day(s) %d hour(s)", days, hours)
		elseif duration_hours > 0 then
			tracking_duration = string.format("%d hour(s) %d min(s)", duration_hours, duration_minutes)
		else
			tracking_duration = string.format("%d minute(s)", duration_minutes)
		end

		attacker_info = string.format("%d previous malware upload(s) from this IP\nFirst upload: %s\nTracking duration: %s",
			attacker_count, first_upload_str, tracking_duration)
	end

	-- Detect webhook type from URL
	local is_discord = webhook_url:find("discord%.com/api/webhooks") or webhook_url:find("discordapp%.com/api/webhooks")
	local is_power_automate = webhook_url:find("powerplatform%.com") or webhook_url:find("powerautomate")

	local card

	-- Format detection timestamp (UTC)
	local detection_time = os.date("!%Y-%m-%d %H:%M:%S UTC")

	if is_discord then
		-- Discord embed format
		local fields = {
			{name = "ðŸ•’ Detection Time", value = webhook_truncate_string(detection_time, 1024), inline = true},
			{name = "ðŸ–¥ï¸ BunkerWeb Instance", value = webhook_truncate_string(hostname or "unknown", 1024), inline = true},
			{name = "âš™ï¸ Worker", value = webhook_truncate_string(worker_info or "unknown", 1024), inline = true},
			{name = "Client IP", value = webhook_truncate_string(client_ip, 1024), inline = true},
			{name = "Destination Domain", value = webhook_truncate_string(server_name, 1024), inline = true},
			{name = "Request URI", value = webhook_truncate_string(request_uri, 1024), inline = false},
			{name = "SHA256 Checksum", value = webhook_truncate_string(checksum or "not available", 1024), inline = false},
			{name = "Detected By", value = webhook_truncate_string(hit_rate, 1024), inline = false}
		}

		-- Add signature breakdown if ClamAV signatures were parsed
		if next(signature_breakdown) then
			local breakdown_lines = {}
			for scanner, parsed in pairs(signature_breakdown) do
				if parsed.platform and parsed.category then
					-- Truncate name to 20 chars to keep breakdown compact
					local name_truncated = webhook_truncate_virus_name(parsed.name)
					table.insert(breakdown_lines, string.format(
						"â€¢ **Platform**: %s | **Category**: %s | **Name**: %s\n  ID: %s-r%s",
						parsed.platform, parsed.category, name_truncated,
						parsed.signature_id, parsed.revision
					))
				end
			end
			if #breakdown_lines > 0 then
				table.insert(fields, {
					name = "ðŸ”¬ Signature Details",
					value = table.concat(breakdown_lines, "\n"),
					inline = false
				})
			end
		end

		-- Add attacker history if available
		if attacker_info then
			table.insert(fields, {
				name = "ðŸš¨ Repeat Offender",
				value = webhook_truncate_string(attacker_info, 1024),
				inline = false
			})
		end

		-- Add cached results indicator if any
		if cached_info then
			table.insert(fields, {
				name = "âš¡ Cached Results",
				value = webhook_truncate_string(cached_info .. " (from cache, not re-scanned)", 1024),
				inline = false
			})
		end

		-- Add detection details (truncate to prevent Discord field limit issues)
		for scanner, detection in pairs(detections or {}) do
			table.insert(fields, {
				name = webhook_truncate_string(scanner, 256),  -- Discord field name limit: 256 chars
				value = webhook_truncate_string(detection, 1024),  -- Discord field value limit: 1024 chars
				inline = false
			})
		end

		card = {
			embeds = {
				{
					title = "ðŸ›¡ï¸ MALWARE DETECTED",
					description = "BunkerWeb Malware Scanner Alert",
					color = 16711680,  -- Red color in decimal
					fields = fields,
					timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
				}
			}
		}
	elseif is_power_automate then
		-- Power Automate simple JSON format
		card = {
			title = "ðŸ›¡ï¸ MALWARE DETECTED",
			detection_time = detection_time,
			bunkerweb_instance = hostname or "unknown",
			worker = worker_info or "unknown",
			client_ip = client_ip,
			server_name = server_name,
			request_uri = request_uri,
			checksum = checksum or "not available",
			detected_by = hit_rate,
			signature_breakdown = signature_breakdown,  -- Include parsed signatures
			previous_uploads = attacker_count or 0,
			repeat_offender = (attacker_count and attacker_count > 0) or false,
			first_upload = first_upload_time and os.date("!%Y-%m-%d %H:%M:%S UTC", first_upload_time) or nil,
			tracking_duration = tracking_duration,
			cached_results = cached_info,
			detections = detections
		}
	else
		-- Microsoft Teams MessageCard format (Incoming Webhook)
		local facts = {
			{name = "ðŸ•’ Detection Time", value = webhook_truncate_string(detection_time, 1024)},
			{name = "ðŸ–¥ï¸ BunkerWeb Instance", value = webhook_truncate_string(hostname or "unknown", 1024)},
			{name = "âš™ï¸ Worker", value = webhook_truncate_string(worker_info or "unknown", 1024)},
			{name = "Client IP", value = webhook_truncate_string(client_ip, 1024)},
			{name = "Destination Domain", value = webhook_truncate_string(server_name, 1024)},
			{name = "Request URI", value = webhook_truncate_string(request_uri, 1024)},
			{name = "SHA256 Checksum", value = webhook_truncate_string(checksum or "not available", 1024)},
			{name = "Detected By", value = webhook_truncate_string(hit_rate, 1024)}
		}

		-- Add signature breakdown if ClamAV signatures were parsed
		if next(signature_breakdown) then
			local breakdown_lines = {}
			for scanner, parsed in pairs(signature_breakdown) do
				if parsed.platform and parsed.category then
					-- Truncate name to 20 chars to keep breakdown compact
					local name_truncated = webhook_truncate_virus_name(parsed.name)
					table.insert(breakdown_lines, string.format(
						"â€¢ Platform: %s | Category: %s | Name: %s | ID: %s-r%s",
						parsed.platform, parsed.category, name_truncated,
						parsed.signature_id, parsed.revision
					))
				end
			end
			if #breakdown_lines > 0 then
				table.insert(facts, {
					name = "ðŸ”¬ Signature Details",
					value = table.concat(breakdown_lines, "\n")
				})
			end
		end

		-- Add attacker history if available
		if attacker_info then
			table.insert(facts, {name = "ðŸš¨ Repeat Offender", value = webhook_truncate_string(attacker_info, 1024)})
		end

		-- Add cached results indicator if any
		if cached_info then
			table.insert(facts, {name = "âš¡ Cached Results", value = webhook_truncate_string(cached_info .. " (from cache, not re-scanned)", 1024)})
		end

		card = {
			["@type"] = "MessageCard",
			["@context"] = "https://schema.org/extensions",
			themeColor = "FF0000",  -- Red color for alerts
			summary = "Malware Detected",
			sections = {
				{
					activityTitle = "ðŸ›¡ï¸ MALWARE DETECTED",
					activitySubtitle = "BunkerWeb Malware Scanner Alert",
					facts = facts,
					markdown = true
				}
			}
		}

		-- Add detection details section if available
		if #detection_list > 0 then
			table.insert(card.sections, {
				title = "Detection Details",
				text = webhook_truncate_string(table.concat(detection_list, "\n\n"), 5000)  -- Teams text limit
			})
		end
	end

	return cjson.encode(card)
end

-- Attempt a single webhook HTTP request (helper for retry logic)
--- @param url_parts table Parsed URL components
--- @param json_body string JSON payload to send
--- @param plugin table Plugin instance for logging
--- @param webhook_type string Type of webhook ("Teams" or "Discord") for logging
--- @return table|nil response Response object on success, nil on connection/SSL failure
--- @return string|nil error Error message on failure
local function webhook_attempt_webhook_request(url_parts, json_body, plugin, webhook_type)
	local httpc = http.new()
	httpc:set_timeout(5000)  -- 5 second timeout

	-- Connect to webhook server
	local ok, err = httpc:connect(url_parts.host, url_parts.port)
	if not ok then
		return nil, "connection failed: " .. (err or "unknown")
	end

	-- Perform SSL handshake if needed
	if url_parts.ssl then
		local session, ssl_err = httpc:ssl_handshake(nil, url_parts.host, false)
		if not session then
			httpc:close()
			return nil, "SSL handshake failed: " .. (ssl_err or "unknown")
		end
	end

	-- Send POST request
	local res, req_err = httpc:request({
		method = "POST",
		path = url_parts.path,
		headers = {
			["Host"] = url_parts.host,
			["Content-Type"] = "application/json",
			["Content-Length"] = tostring(#json_body)
		},
		body = json_body
	})

	httpc:close()
	return res, req_err
end

-- Send webhook HTTP request with retry logic
--- @param url_parts table Parsed URL components
--- @param json_body string JSON payload to send
--- @param plugin table Plugin instance for logging
--- @param webhook_type string Type of webhook ("Teams" or "Discord") for logging
--- @return boolean success True if webhook sent successfully, false otherwise
local function webhook_send_webhook_request(url_parts, json_body, plugin, webhook_type)
	-- Retry configuration
	local max_retries = 3
	local base_delay = 1  -- 1 second base delay
	local max_delay = 20  -- 20 seconds max delay

	-- Transient error status codes that should be retried
	local transient_errors = {
		[412] = true,  -- Precondition Failed
		[429] = true,  -- Too Many Requests (rate limit)
		[502] = true,  -- Bad Gateway
		[504] = true,  -- Gateway Timeout
	}

	-- Retry loop with exponential backoff
	for attempt = 1, max_retries do
		-- Attempt the webhook request
		local res, err = webhook_attempt_webhook_request(url_parts, json_body, plugin, webhook_type)

		-- Success case
		if res and res.status >= 200 and res.status < 300 then
			if attempt > 1 then
				logger.log_notice( "[WEBHOOK] " .. webhook_type .. " notification sent successfully after " .. attempt .. " attempts")
			else
				logger.log_notice( "[WEBHOOK] " .. webhook_type .. " notification sent successfully")
			end
			return true
		end

		-- Determine if error is transient and should be retried
		local should_retry = false
		local error_msg = ""

		if not res then
			-- Connection error, SSL error, or timeout
			should_retry = (attempt < max_retries)
			error_msg = err or "unknown error"
		elseif transient_errors[res.status] then
			-- Transient HTTP error
			should_retry = (attempt < max_retries)
			error_msg = "HTTP " .. res.status .. ": " .. (res.body or "no body")
		else
			-- Non-retryable error (4xx other than 412/429, or 5xx other than 502/504)
			should_retry = false
			error_msg = "HTTP " .. res.status .. ": " .. (res.body or "no body")
		end

		-- Log the error
		if should_retry then
			logger.log_notice( "[WEBHOOK] " .. webhook_type .. " attempt " .. attempt .. "/" .. max_retries .. " failed (" .. error_msg .. "), retrying...")
		else
			logger.log_error( "[WEBHOOK] " .. webhook_type .. " failed: " .. error_msg)
			return false
		end

		-- Calculate exponential backoff delay with jitter (only if retrying)
		if should_retry and attempt < max_retries then
			local delay = math.min(math.pow(2, attempt - 1) * base_delay, max_delay)
			-- Add random jitter (Â±20%)
			local jitter = delay * 0.2 * (math.random() * 2 - 1)
			delay = delay + jitter

			logger.log_notice( "[WEBHOOK] " .. webhook_type .. " backing off for " .. string.format("%.2f", delay) .. " seconds")
			ngx.sleep(delay)
		end
	end

	-- All retries exhausted
	logger.log_error( "[WEBHOOK] " .. webhook_type .. " failed after " .. max_retries .. " attempts")
	return false
end

-- Safe wrapper: Send webhook notification with built-in error handling.
-- Handles nil module checks, empty data validation, and error logging.
-- This wrapper centralizes all error handling to eliminate code duplication.
--
-- Use this function from other modules instead of calling notification_send directly.
--
--- @param webhook_module table The webhook module (can be nil)
--- @param plugin table Plugin instance
--- @param checksum string SHA256 hash of the malicious file (can be nil)
--- @param detections table Scanner detection results (can be empty)
--- @return boolean success True if notification sent successfully, false otherwise
function webhook.notify(webhook_module, plugin, checksum, detections)
	-- Silent return if webhook module not loaded
	if not webhook_module then
		return false
	end

	-- Silent return if no checksum or detections
	if not checksum or not detections or next(detections) == nil then
		return false
	end

	-- Call notification_send with error handling
	local ok, err = pcall(webhook.notification_send, plugin, checksum, detections)
	if not ok then
		logger.log_error( "[WEBHOOK] Failed to send notification: " .. tostring(err))
		return false
	end

	return true
end

-- Main entry point: Send notification to configured webhooks
-- Processes both Teams and Discord webhooks if configured
--- @param plugin table Plugin instance with variables and logger
--- @param checksum string SHA256 hash of the malicious file
--- @param detections table Scanner detection results {scanner_name = detection_info}
--- @return boolean success True if all configured webhooks succeeded, false otherwise
function webhook.notification_send(plugin, checksum, detections)
	local success = true

	-- Get request information
	local client_ip = ngx.var.remote_addr or "unknown"
	local server_name = ngx.var.server_name or ngx.var.host or "unknown"
	local request_uri = plugin.ctx.bw.uri or "unknown"

	-- Get worker/instance information
	local hostname = ngx.var.hostname or "unknown"
	local worker_pid = ngx.worker.pid()
	local worker_id = ngx.worker.id()
	local worker_info = string.format("PID:%d ID:%d", worker_pid or 0, worker_id or 0)

	-- Get attacker history if tracking is enabled (using ORIGINAL IP before anonymization)
	local attacker_count = 0
	local first_upload_time = nil
	if cache and cache.attacker_get then
		local attacker_data = cache.attacker_get(plugin, client_ip)
		if attacker_data and attacker_data.upload_count then
			attacker_count = attacker_data.upload_count
			first_upload_time = attacker_data.first_upload
			logger.log_notice( string.format("[v" .. webhook.VERSION .. "] [WEBHOOK] Attacker history: IP %s has %d previous malware upload(s)", client_ip, attacker_count))
		end
	end

	-- Apply IP anonymization for GDPR data minimization (Article 5(1)(c))
	-- Anonymize by default to minimize data shared with third parties (Microsoft/Discord)
	local anonymize_ips = plugin.variables["MALWARE_SCAN_ANONYMIZE_WEBHOOK_IPS"]
	if anonymize_ips == nil or anonymize_ips == "" or anonymize_ips == "yes" then
		local original_ip = client_ip
		client_ip = webhook_anonymize_ip_for_webhook(client_ip)
		if client_ip ~= original_ip then
			logger.log_notice( string.format("[v" .. webhook.VERSION .. "] [WEBHOOK] IP anonymized for third-party sharing: %s -> %s", original_ip, client_ip))
		end
	end

	-- Process Teams webhook
	local teams_url = plugin.variables["MALWARE_SCAN_TEAMS_WEBHOOK_URL"]
	if teams_url and teams_url ~= "" and teams_url ~= "your_webhook_url" then
		logger.log_error( "[WEBHOOK] Processing Teams webhook")

		-- Check rate limit with hard cap at Microsoft Teams' limit (200/min)
		local TEAMS_HARD_LIMIT = 200
		local user_rate_limit = tonumber(plugin.variables["MALWARE_SCAN_TEAMS_WEBHOOK_RATE_LIMIT"]) or 3
		local rate_limit = user_rate_limit

		if user_rate_limit == 0 then
			rate_limit = TEAMS_HARD_LIMIT
		elseif user_rate_limit > TEAMS_HARD_LIMIT then
			rate_limit = TEAMS_HARD_LIMIT
			logger.log_warn( "[WEBHOOK] Teams rate limit " .. user_rate_limit .. " exceeds maximum (" .. TEAMS_HARD_LIMIT .. "/min) - enforcing hard cap")
		end

		-- Apply rate limiting
		local cache_key = "plugin_malware_scan_teams_webhook_count"
		local ok, count = plugin.cachestore:get(cache_key)

		if ok and count then
			count = tonumber(count) or 0
			if count >= rate_limit then
				logger.log_notice( "[WEBHOOK] Teams rate limit exceeded (" .. count .. "/" .. rate_limit .. " per minute) - skipping notification")
			else
				-- Increment counter
				plugin.cachestore:set(cache_key, count + 1, 60)

				-- Clean URL and parse
				teams_url = webhook_clean_webhook_url(teams_url, plugin)
				local url_parts, err = utils.parse_webhook_url(teams_url)
				if not url_parts then
					logger.log_error( "[WEBHOOK] Teams URL parse failed: " .. err)
					success = false
				else
					-- Build and send
					local json_body = webhook_build_json_payload(teams_url, checksum, detections, client_ip, server_name, request_uri, hostname, worker_info, attacker_count, first_upload_time)
					if not webhook_send_webhook_request(url_parts, json_body, plugin, "Teams") then
						success = false
					end
				end
			end
		else
			-- Initialize counter with 60 second TTL
			plugin.cachestore:set(cache_key, 1, 60)

			-- Clean URL and parse
			teams_url = webhook_clean_webhook_url(teams_url, plugin)
			local url_parts, err = utils.parse_webhook_url(teams_url)
			if not url_parts then
				logger.log_error( "[WEBHOOK] Teams URL parse failed: " .. err)
				success = false
			else
				-- Build and send
				local json_body = webhook_build_json_payload(teams_url, checksum, detections, client_ip, server_name, request_uri, hostname, worker_info, attacker_count, first_upload_time)
				if not webhook_send_webhook_request(url_parts, json_body, plugin, "Teams") then
					success = false
				end
			end
		end
	end

	-- Process Discord webhook
	local discord_url = plugin.variables["MALWARE_SCAN_DISCORD_WEBHOOK_URL"]
	if discord_url and discord_url ~= "" and discord_url ~= "your_webhook_url" then
		logger.log_error( "[WEBHOOK] Processing Discord webhook")

		-- Check rate limit with hard cap at Discord's limit (30 per 60 seconds)
		local DISCORD_HARD_LIMIT = 30
		local user_rate_limit = tonumber(plugin.variables["MALWARE_SCAN_DISCORD_WEBHOOK_RATE_LIMIT"]) or 3
		local rate_limit = user_rate_limit

		if user_rate_limit == 0 then
			rate_limit = DISCORD_HARD_LIMIT
		elseif user_rate_limit > DISCORD_HARD_LIMIT then
			rate_limit = DISCORD_HARD_LIMIT
			logger.log_warn( "[WEBHOOK] Discord rate limit " .. user_rate_limit .. " exceeds maximum (" .. DISCORD_HARD_LIMIT .. "/60s) - enforcing hard cap")
		end

		-- Apply rate limiting (60 second window for Discord)
		local cache_key = "plugin_malware_scan_discord_webhook_count"
		local ok, count = plugin.cachestore:get(cache_key)

		if ok and count then
			count = tonumber(count) or 0
			if count >= rate_limit then
				logger.log_notice( "[WEBHOOK] Discord rate limit exceeded (" .. count .. "/" .. rate_limit .. " per 60s) - skipping notification")
			else
				-- Increment counter
				plugin.cachestore:set(cache_key, count + 1, 60)

				-- Clean URL and parse
				discord_url = webhook_clean_webhook_url(discord_url, plugin)
				local url_parts, err = utils.parse_webhook_url(discord_url)
				if not url_parts then
					logger.log_error( "[WEBHOOK] Discord URL parse failed: " .. err)
					success = false
				else
					-- Build and send
					local json_body = webhook_build_json_payload(discord_url, checksum, detections, client_ip, server_name, request_uri, hostname, worker_info, attacker_count, first_upload_time)
					if not webhook_send_webhook_request(url_parts, json_body, plugin, "Discord") then
						success = false
					end
				end
			end
		else
			-- Initialize counter with 60 second TTL
			plugin.cachestore:set(cache_key, 1, 60)

			-- Clean URL and parse
			discord_url = webhook_clean_webhook_url(discord_url, plugin)
			local url_parts, err = utils.parse_webhook_url(discord_url)
			if not url_parts then
				logger.log_error( "[WEBHOOK] Discord URL parse failed: " .. err)
				success = false
			else
				-- Build and send
				local json_body = webhook_build_json_payload(discord_url, checksum, detections, client_ip, server_name, request_uri, hostname, worker_info, attacker_count, first_upload_time)
				if not webhook_send_webhook_request(url_parts, json_body, plugin, "Discord") then
					success = false
				end
			end
		end
	end

	return success
end

return webhook
