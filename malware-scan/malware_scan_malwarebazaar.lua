-- BunkerWeb Malware Scan - MalwareBazaar Hash Database Module
-- Redis-backed hash lookup for MalwareBazaar threat intelligence
--
-- Features:
-- - 1M+ malware hashes from MalwareBazaar (abuse.ch) in Redis
-- - Bucketed storage across 16 Redis keys for 16x faster lookups
-- - Sub-millisecond hash lookups (<1ms) vs API calls (100-500ms)
-- - Automatic hourly updates from sysangels.ai mirror
-- - Infinite persistence (freshness maintained by scheduler)
--
-- Data Source: https://bazaar.abuse.ch (MalwareBazaar Project)
-- Mirror: https://bazaar.sysangels.ai/bunkerweb/

local cjson = require("cjson")
local logger = require("malware_scan_logger")
local utils = require("malware_scan_utils")
local database = require("malware_scan_database")

-- Module table
local malwarebazaar = {}

-- Module version
malwarebazaar.VERSION = "0.8.0"

local ngx = ngx

--------------------------------------------------------------------------------
-- MALWAREBAZAAR HASH LOOKUP (Redis-based)
--------------------------------------------------------------------------------

-- Check if SHA256 hash exists in MalwareBazaar database
--- @param plugin Plugin instance
--- @param checksum string SHA256 hash (64 hex chars)
--- @param file_size number Optional file size (not used for Redis lookup)
--- @return boolean success True if lookup succeeded
--- @return string result "clean" if not found, malware name if detected
function malwarebazaar.hash_check(plugin, checksum, file_size)
	-- DEBUG: Log function entry
	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] === hash_check() called ===", malwarebazaar.VERSION))
	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Input checksum: %s", malwarebazaar.VERSION, tostring(checksum)))
	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Input file_size: %s", malwarebazaar.VERSION, tostring(file_size)))

	-- Check if feature is enabled
	local feature_enabled = plugin.variables and plugin.variables["MALWARE_SCAN_MALWAREBAZAAR_HASH_LOOKUP"] == "yes"
	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Feature enabled check: %s (value: %s)",
		malwarebazaar.VERSION,
		tostring(feature_enabled),
		tostring(plugin.variables and plugin.variables["MALWARE_SCAN_MALWAREBAZAAR_HASH_LOOKUP"] or "nil")))

	if not feature_enabled then
		logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Feature disabled, returning clean", malwarebazaar.VERSION))
		return true, "clean"
	end

	-- Check if Redis is available
	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Redis available: %s", malwarebazaar.VERSION, tostring(database.is_available(plugin))))
	if not database.is_available(plugin) then
		logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Redis not available, returning clean", malwarebazaar.VERSION))
		logger.log_error( "MalwareBazaar hash lookup enabled but Redis not available")
		return true, "clean"
	end

	-- Two-tier lookup strategy:
	-- 1. Check recent cache (fast path for frequently seen malware)
	-- 2. Check bucketed full hash table (slower but complete)
	-- Store format: HSET malware_scan:hashes:X <sha256> <signature>|<clamav>
	-- Uppercase checksum for case-insensitive matching (hashes stored uppercase in Redis)
	local checksum_upper = checksum:upper()
	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Uppercase checksum: %s", malwarebazaar.VERSION, checksum_upper))

	-- Track lookup source for logging
	local lookup_source = "none"

	-- TIER 1: Check recent cache first (fast path)
	local recent_key = "malware_scan:hashes:recent"
	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Checking recent cache: %s", malwarebazaar.VERSION, recent_key))

	local data = database.hget(plugin, recent_key, checksum_upper)
	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Recent cache response: %s (type: %s)",
		malwarebazaar.VERSION,
		tostring(data),
		type(data)))

	if data and data ~= ngx.null then
		-- Found in recent cache - fast path!
		lookup_source = "recent"
		logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] ✓ FOUND IN RECENT CACHE (fast path)", malwarebazaar.VERSION))
	else
		-- TIER 2: Not in recent cache, check bucketed full hash table
		logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Not in recent cache, checking full hash table", malwarebazaar.VERSION))

		local hash_key = utils.get_hash_bucket(checksum_upper)
		logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Bucket key: %s", malwarebazaar.VERSION, hash_key))

		data = database.hget(plugin, hash_key, checksum_upper)
		logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Full table response: %s (type: %s)",
			malwarebazaar.VERSION,
			tostring(data),
			type(data)))

		if data and data ~= ngx.null then
			-- Found in full table - cache it in recent for future quick lookups
			lookup_source = "bucket:" .. hash_key:sub(-1)
			logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] ✓ FOUND IN FULL TABLE, caching to recent", malwarebazaar.VERSION))

			-- Add to recent cache (fire and forget - don't check result)
			pcall(function()
				database.hset(plugin, recent_key, checksum_upper, data)
			end)
		end
	end

	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] data == ngx.null: %s",
		malwarebazaar.VERSION,
		tostring(data == ngx.null)))

	if not data or data == ngx.null then
		-- Hash not found in either recent or full table - file is clean or unknown
		logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Hash not found in Redis (data is nil or ngx.null), returning clean", malwarebazaar.VERSION))
		return true, "clean"
	end

	-- Parse stored data: "signature|clamav" (pipe-delimited, 2 fields)
	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Parsing data: %s", malwarebazaar.VERSION, data))

	-- Split by pipe delimiter
	local fields = {}
	for field in string.gmatch(data, "([^|]+)") do
		table.insert(fields, field)
	end

	local signature = fields[1] or ""
	local clamav = fields[2] or ""

	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Parsed signature: %s", malwarebazaar.VERSION, signature))
	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Parsed clamav: %s", malwarebazaar.VERSION, clamav))

	-- Normalize empty/placeholder values
	-- Treat "n/a" as empty since it's a placeholder for missing data
	if signature == "n/a" or signature == "N/A" then
		signature = ""
	end
	if clamav == "n/a" or clamav == "N/A" then
		clamav = ""
	end

	-- Build combined result intelligently:
	-- IMPORTANT: Hash match in database = confirmed malware, even if signature names are missing
	-- 1. If both fields have values, show both (signature is MalwareBazaar name, clamav is ClamAV signature)
	-- 2. If only one has a value, use that one
	-- 3. If both are empty, use generic detection name (hash is in database = malware)
	-- 4. Prefer clamav field for consistency with ClamAV scanner output
	local combined_result
	if signature ~= "" and clamav ~= "" then
		-- Both fields present - show both for maximum context
		combined_result = clamav .. " (MalwareBazaar: " .. signature .. ")"
	elseif clamav ~= "" then
		-- Only ClamAV signature present - use it directly
		combined_result = clamav
	elseif signature ~= "" then
		-- Only MalwareBazaar signature present - use it
		combined_result = signature
	else
		-- Both empty but hash exists in database - still malware!
		-- Use generic detection name to indicate confirmed malware with unknown signature
		combined_result = "MalwareBazaar.Generic"
		logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Hash match but both signatures empty - using generic name", malwarebazaar.VERSION))
	end

	-- Found match - return both signatures
	logger.log_error( string.format(
		"[v%s] [MALWAREBAZAAR] ✓ HASH MATCH: %s... = %s (source: %s)",
		malwarebazaar.VERSION,
		checksum_upper:sub(1, 16),
		combined_result,
		lookup_source
	))

	logger.log_error(string.format("[v%s] [HASH_CHECK_DEBUG] Returning malware detection: %s", malwarebazaar.VERSION, combined_result))
	return true, combined_result
end

-- Legacy alias for backward compatibility
malwarebazaar.check_malwarebazaar = malwarebazaar.hash_check

return malwarebazaar
